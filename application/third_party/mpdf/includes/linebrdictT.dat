is->WriteHTML($html);
	$this->fixedPosBlockSave = $save_fpb;

	$this->breakpoints[$this->CurrCol][] = $this->y; 	// *COLUMNS*
}
/*-- END INDEX --*/


function AcceptPageBreak() {
	if (count($this->cellBorderBuffer)) { $this->printcellbuffer(); }	// *TABLES*
/*-- COLUMNS --*/
	if ($this->ColActive==1) {
	    if($this->CurrCol<$this->NbCol-1) {
        	//Go to the next column
		$this->CurrCol++;
       	$this->SetCol($this->CurrCol);
		$this->y=$this->y0;
       	$this->ChangeColumn=1;	// Number (and direction) of columns changed +1, +2, -2 etc.
		// DIRECTIONALITY RTL
		if ($this->directionality == 'rtl') { $this->ChangeColumn = -($this->ChangeColumn); }	// *OTL*
 
       	//Stay on the page
        	return false;
	   }
	   else {
    		//Go back to the first column - NEW PAGE
		if (count($this->columnbuffer)) { $this->printcolumnbuffer(); }
		$this->SetCol(0);
		$this->y0 = $this->tMargin;
        	$this->ChangeColumn= -($this->NbCol-1);
		// DIRECTIONALITY RTL
		if ($this->directionality == 'rtl') { $this->ChangeColumn = -($this->ChangeColumn); }	// *OTL*
        	//Page break
       	return true;
	   }
	}
/*-- END COLUMNS --*/
/*-- TABLES --*/
	else if ($this->table_rotate) {
		if ($this->tablebuffer) { $this->printtablebuffer(); }
		return true;
	}
/*-- END TABLES --*/
	else {	// *COLUMNS*
        	$this->ChangeColumn=0;
		return $this->autoPageBreak;
	}	// *COLUMNS*
	return $this->autoPageBreak;
}


//----------- COLUMNS ---------------------
/*-- COLUMNS --*/

function SetColumns($NbCol,$vAlign='',$gap=5) {
// NbCol = number of columns
// Anything less than 2 turns columns off
	if ($NbCol<2) {	// SET COLUMNS OFF
		if ($this->ColActive) { 
			$this->ColActive=0;
			if (count($this->columnbuffer)) { $this->printcolumnbuffer(); }
			$this->NbCol=1;
			$this->ResetMargins(); 
			$this->pgwidth = $this->w - $this->lMargin - $this->rMargin;
			$this->divwidth = 0;
			$this->Ln(); 
		}
		$this->ColActive=0;
		$this->columnbuffer = array();
		$this->ColDetails = array();
		$this->columnLinks = array();
		$this->columnAnnots = array();
		$this->columnForms = array();
		$this->col_BMoutlines = array();
		$this->col_toc = array();
		$this->breakpoints = array();
	}
	else {	// SET COLUMNS ON
		if ($this->ColActive) { 
			$this->ColActive=0;
			if (count($this->columnbuffer)) { $this->printcolumnbuffer(); }
			$this->ResetMargins(); 
		}
		if (isset($this->y) && $this->y>$this->tMargin) $this->Ln();
		$this->NbCol=$NbCol;
		$this->ColGap = $gap;
		$this->divwidth = 0;
		$this->ColActive=1;
		$this->ColumnAdjust = true;	// enables column height adjustment for the page
		$this->columnbuffer = array();
		$this->ColDetails = array();
		$this->columnLinks = array();
		$this->columnAnnots = array();
		$this->columnForms = array();
		$this->col_BMoutlines = array();
		$this->col_toc = array();
		$this->breakpoints = array();
		if ((strtoupper($vAlign) == 'J') || (strtoupper($vAlign) == 'JUSTIFY')) { $vAlign = 'J'; } 
		else { $vAlign = ''; }
		$this->colvAlign = $vAlign;
		//Save the ordinate
		$absL = $this->DeflMargin-($gap/2);
		$absR = $this->DefrMargin-($gap/2);
		$PageWidth = $this->w-$absL-$absR;	// virtual pagewidth for calculation only
		$ColWidth = (($PageWidth - ($gap * ($NbCol)))/$NbCol);
		$this->ColWidth = $ColWidth;
/*-- OTL --*/

		if ($this->directionality == 'rtl') { 
			for ($i=0;$i<$this->NbCol;$i++) {
				$this->ColL[$i] = $absL + ($gap/2) + (($NbCol - ($i+1))*($PageWidth/$NbCol)) ;
				$this->ColR[$i] = $this->ColL[$i] + $ColWidth;	// NB This is not R margin -> R pos
			}
		} 
		else { 
/*-- END OTL --*/
			for ($i=0;$i<$this->NbCol;$i++) {
				$this->ColL[$i] = $absL + ($gap/2) + ($i* ($PageWidth/$NbCol)   );
				$this->ColR[$i] = $this->ColL[$i] + $ColWidth;	// NB This is not R margin -> R pos
			}
		}	// *OTL*
		$this->pgwidth = $ColWidth;
		$this->SetCol(0);
		$this->y0=$this->y;
	}
	$this->x = $this->lMargin;
}

function SetCol($CurrCol) {
// Used internally to set column by number: 0 is 1st column
	//Set position on a column
	$this->CurrCol=$CurrCol;
	$x = $this->ColL[$CurrCol];
	$xR = $this->ColR[$CurrCol];	// NB This is not R margin -> R pos
	if (($this->mirrorMargins) && (($this->page)%2==0)) {	// EVEN
		$x += $this->MarginCorrection ;
		$xR += $this->MarginCorrection ;
	}
	$this->SetMargins($x,($this->w - $xR),$this->tMargin);
}

function AddColumn() {
	$this->NewColumn();
	$this->ColumnAdjust = false;	// disables all column height adjustment for the page.
}
function NewColumn() {
	if ($this->ColActive==1) {
	    if($this->CurrCol<$this->NbCol-1) {
        	//Go to the next column
		$this->CurrCol++;
        	$this->SetCol($this->CurrCol);
        	$this->y = $this->y0;
        	$this->ChangeColumn=1;
		// DIRECTIONALITY RTL
		if ($this->directionality == 'rtl') { $this->ChangeColumn = -($this->ChangeColumn); }	// *OTL*
        	//Stay on the page
    		}
    		else {
    		//Go back to the first column
        	//Page break
		if (count($this->columnbuffer)) { $this->printcolumnbuffer(); }
		$this->AddPage($this->CurOrientation);
		$this->SetCol(0);
		$this->y0 = $this->tMargin;
        	$this->ChangeColumn= -($this->NbCol-1);
		// DIRECTIONALITY RTL
		if ($this->directionality == 'rtl') { $this->ChangeColumn = -($this->ChangeColumn); }	// *OTL*
    		}
		$this->x = $this->lMargin;
	}
	else {
		$this->AddPage($this->CurOrientation);
	}
}

function printcolumnbuffer() {
   // Columns ended (but page not ended) -> try to match all columns - unless disabled by using a custom column-break
   if (!$this->ColActive && $this->ColumnAdjust && !$this->keepColumns) {
	// Calculate adjustment to add to each column to calculate rel_y value
	$this->ColDetails[0]['add_y'] = 0;
	$last_col = 0;
	// Recursively add previous column's height
	for($i=1;$i<$this->NbCol;$i++) { 
		if (isset($this->ColDetails[$i]['bottom_margin']) && $this->ColDetails[$i]['bottom_margin']) { // If any entries in the column
			$this->ColDetails[$i]['add_y'] = ($this->ColDetails[$i-1]['bottom_margin'] - $this->y0) + $this->ColDetails[$i-1]['add_y'];
			$last_col = $i; 	// Last column actually printed
		}
	}

	// Calculate value for each position sensitive entry as though for one column
	foreach($this->columnbuffer AS $key=>$s) { 
		$t = $s['s'];
		if ($t == 'ACROFORM') {
			$this->columnbuffer[$key]['rel_y'] = $s['y'] + $this->ColDetails[$s['col']]['add_y'] - $this->y0;
			$this->columnbuffer[$key]['s'] = '';
		}
		else if (preg_match('/BT \d+\.\d\d+ (\d+\.\d\d+) Td/',$t)) {
			$this->columnbuffer[$key]['rel_y'] = $s['y'] + $this->ColDetails[$s['col']]['add_y'] - $this->y0;
		}
		else if (preg_match('/\d+\.\d\d+ (\d+\.\d\d+) \d+\.\d\d+ [\-]{0,1}\d+\.\d\d+ re/',$t)) {
			$this->columnbuffer[$key]['rel_y'] = $s['y'] + $this->ColDetails[$s['col']]['add_y'] - $this->y0;
		}
		else if (preg_match('/\d+\.\d\d+ (\d+\.\d\d+) m/',$t)) {
			$this->columnbuffer[$key]['rel_y'] = $s['y'] + $this->ColDetails[$s['col']]['add_y'] - $this->y0;
		}
		else if (preg_match('/\d+\.\d\d+ (\d+\.\d\d+) l/',$t)) {
			$this->columnbuffer[$key]['rel_y'] = $s['y'] + $this->ColDetails[$s['col']]['add_y'] - $this->y0;
		}
		else if (preg_match('/q \d+\.\d\d+ 0 0 \d+\.\d\d+ \d+\.\d\d+ (\d+\.\d\d+) cm \/(I|FO)\d+ Do Q/',$t)) { 
			$this->columnbuffer[$key]['rel_y'] = $s['y'] + $this->ColDetails[$s['col']]['add_y'] - $this->y0;
		}
		else if (preg_match('/\d+\.\d\d+ (\d+\.\d\d+) \d+\.\d\d+ \d+\.\d\d+ \d+\.\d\d+ \d+\.\d\d+ c/',$t)) {
			$this->columnbuffer[$key]['rel_y'] = $s['y'] + $this->ColDetails[$s['col']]['add_y'] - $this->y0;
		}
	}
	foreach($this->internallink AS $key => $f) {
	  if (is_array($f) && isset($f['col'])) {
		$this->internallink[$key]['rel_y'] = $f['Y'] + $this->ColDetails[$f['col']]['add_y'] - $this->y0;
	  }
	}

	$breaks = array();
	foreach($this->breakpoints AS $c => $bpa) { 
		foreach($bpa AS $rely) {
			$breaks[] = $rely + $this->ColDetails[$c]['add_y'] - $this->y0;
		}
	}


	if (isset($this->ColDetails[$last_col]['bottom_margin'])) { $lcbm = $this->ColDetails[$last_col]['bottom_margin']; }
	else { $lcbm = 0; }
	$sum_h = $this->ColDetails[$last_col]['add_y'] + $lcbm - $this->y0;
	//$sum_h = max($this->ColDetails[$last_col]['add_y'] + $this->ColDetails[$last_col]['bottom_margin'] - $this->y0, end($breaks));
	$target_h = ($sum_h / $this->NbCol);

	$cbr = array();
	for($i=1;$i<$this->NbCol;$i++) { 
		$th = ($sum_h * $i / $this->NbCol);
		foreach($breaks AS $bk=>$val) {
			if ($val > $th) {
				if (($val-$th) < ($th-$breaks[$bk-1])) { $cbr[$i-1] = $val; }
				else  { $cbr[$i-1] = $breaks[$bk-1]; }
				break;
			}
		}
	}
	$cbr[($this->NbCol-1)] = $sum_h;

	// mPDF 6
	// Avoid outputing with 1st column empty
	if (isset($cbr[0]) && $cbr[0]==0) { 
		for ($i=0;$i<$this->NbCol-1;$i++) { $cbr[$i] = $cbr[$i+1]; }
	}

	// Now update the columns - divide into columns of approximately equal value
	$last_new_col = 0; 
	$yadj = 0;	// mm
	$xadj = 0;
	$last_col_bottom = 0;
	$lowest_bottom_y = 0;
	$block_bottom = 0;
	$newcolumn = 0;
	foreach($this->columnbuffer AS $key=>$s) { 
	  if (isset($s['rel_y'])) {	// only process position sensitive data
		if ($s['rel_y'] >= $cbr[$newcolumn]) {
			$newcolumn++;
		}
		else {
			$newcolumn = $last_new_col ;
		}


		$block_bottom = max($block_bottom,($s['rel_y']+$s['h']));

		if ($this->directionality == 'rtl') {	// *OTL*
			$xadj = -(($newcolumn - $s['col']) * ($this->ColWidth + $this->ColGap));	// *OTL*
		}	// *OTL*
		else {	// *OTL*
			$xadj = ($newcolumn - $s['col']) * ($this->ColWidth + $this->ColGap);
		}	// *OTL*

		if ($last_new_col != $newcolumn) {	// Added new column
			$last_col_bottom = $this->columnbuffer[$key]['rel_y'];
			$block_bottom = 0;
		}
		$yadj = ($s['rel_y'] - $s['y']) - ($last_col_bottom)+$this->y0;
		// callback function
		$t = $s['s'];

		// mPDF 5.7+
		$t = $this->columnAdjustPregReplace('Td', $xadj, $yadj, '/BT (\d+\.\d\d+) (\d+\.\d\d+) Td/', $t);
		$t = $this->columnAdjustPregReplace('re', $xadj, $yadj, '/(\d+\.\d\d+) (\d+\.\d\d+) (\d+\.\d\d+) ([\-]{0,1}\d+\.\d\d+) re/', $t);
		$t = $this->columnAdjustPregReplace('l', $xadj, $yadj, '/(\d+\.\d\d+) (\d+\.\d\d+) l/', $t);
		$t = $this->columnAdjustPregReplace('img', $xadj, $yadj, '/q (\d+\.\d\d+) 0 0 (\d+\.\d\d+) (\d+\.\d\d+) (\d+\.\d\d+) cm \/(I|FO)/', $t);
		$t = $this->columnAdjustPregReplace('draw', $xadj, $yadj, '/(\d+\.\d\d+) (\d+\.\d\d+) m/', $t);
		$t = $this->columnAdjustPregReplace('bezier',$xadj, $yadj, '/(\d+\.\d\d+) (\d+\.\d\d+) (\d+\.\d\d+) (\d+\.\d\d+) (\d+\.\d\d+) (\d+\.\d\d+) c/', $t);

		$this->columnbuffer[$key]['s'] = $t;
		$this->columnbuffer[$key]['newcol'] = $newcolumn;
		$this->columnbuffer[$key]['newy'] = $s['y'] + $yadj;
		$last_new_col = $newcolumn;
		$clb = $s['y'] + $yadj + $s['h'] ;	// bottom_margin of current
		if ((isset($this->ColDetails[$newcolumn]['max_bottom']) && $clb > $this->ColDetails[$newcolumn]['max_bottom']) || (!isset($this->ColDetails[$newcolumn]['max_bottom']) && $clb)) { $this->ColDetails[$newcolumn]['max_bottom'] = $clb; }
		if ($clb > $lowest_bottom_y) { $lowest_bottom_y = $clb; }
		// Adjust LINKS
		if (isset($this->columnLinks[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])])) {
			$ref = $this->columnLinks[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])];
			$this->PageLinks[$this->page][$ref][0] += ($xadj*_MPDFK);
			$this->PageLinks[$this->page][$ref][1] -= ($yadj*_MPDFK);
			unset($this->columnLinks[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])]);
		}
		// Adjust FORM FIELDS
		if (isset($this->columnForms[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])])) {
			$ref = $this->columnForms[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])];
			$this->mpdfform->forms[$ref]['x'] += ($xadj);
			$this->mpdfform->forms[$ref]['y'] += ($yadj);
			unset($this->columnForms[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])]);
		}
/*-- ANNOTATIONS --*/
		if (isset($this->columnAnnots[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])])) {
			$ref = $this->columnAnnots[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])];
			if ($this->PageAnnots[$this->page][$ref]['x'] < 0) {
				 $this->PageAnnots[$this->page][$ref]['x'] -= ($xadj);
			}
			else {
				 $this->PageAnnots[$this->page][$ref]['x'] += ($xadj);
			}
			$this->PageAnnots[$this->page][$ref]['y'] += ($yadj);	// unlike PageLinks, Page annots has y values from top in mm
			unset($this->columnAnnots[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])]);
		}
/*-- END ANNOTATIONS --*/
	  }
	}

/*-- BOOKMARKS --*/
	// Adjust Bookmarks
	foreach($this->col_BMoutlines AS $v) {
		$this->BMoutlines[]=array('t'=>$v['t'],'l'=>$v['l'],'y'=>$this->y0,'p'=>$v['p']);
	}
/*-- END BOOKMARKS --*/

/*-- TOC --*/
	 
	 // Adjust ToC
	 foreach($this->col_toc AS $v) {
		$this->tocontents->_toc[]=array('t'=>$v['t'],'l'=>$v['l'],'p'=>$v['p'],'link'=>$v['link'],'toc_id'=>$v['toc_id']);
		$this->links[$v['link']][1] = $this->y0; 
	 }
/*-- END TOC --*/

	// Adjust column length to be equal
	if ($this->colvAlign == 'J') {
	 foreach($this->columnbuffer AS $key=>$s) { 
	   if (isset($s['rel_y'])) {	// only process position sensitive data
	    // Set ratio to expand y values or heights
	    if (isset($this->ColDetails[$s['newcol']]['max_bottom']) && $this->ColDetails[$s['newcol']]['max_bottom']  && $this->ColDetails[$s['newcol']]['max_bottom']!=$this->y0) {
		$ratio = ($lowest_bottom_y - ($this->y0)) / ($this->ColDetails[$s['newcol']]['max_bottom'] - ($this->y0));
	    }
	    else { $ratio = 1; }
	    if (($ratio > 1) && ($ratio <= $this->max_colH_correction)) {
		$yadj = ($s['newy'] - $this->y0) * ($ratio - 1);

		// Adjust LINKS
		if (isset($this->columnLinks[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])])) {
			$ref = $this->columnLinks[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])];
			$this->PageLinks[$this->page][$ref][1] -= ($yadj*_MPDFK);	// y value
			$this->PageLinks[$this->page][$ref][3] *= $ratio;	// height
			unset($this->columnLinks[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])]);
		}
		// Adjust FORM FIELDS
		if (isset($this->columnForms[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])])) {
			$ref = $this->columnForms[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])];
			$this->mpdfform->forms[$ref]['x'] += ($xadj);
			$this->mpdfform->forms[$ref]['y'] += ($yadj);
			unset($this->columnForms[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])]);
		}
/*-- ANNOTATIONS --*/
		if (isset($this->columnAnnots[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])])) {
			$ref = $this->columnAnnots[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])];
			$this->PageAnnots[$this->page][$ref]['y'] += ($yadj);
			unset($this->columnAnnots[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])]);
		}
/*-- END ANNOTATIONS --*/
	    }
	  }
	 }
	foreach($this->internallink AS $key => $f) {
	  if (is_array($f) && isset($f['col'])) {
		$last_col_bottom = 0;
		for ($nbc=0; $nbc<$this->NbCol; $nbc++) {
			if ($f['rel_y'] >= $cbr[$nbc]) { $last_col_bottom = $cbr[$nbc]; }
		}
		$yadj = ($f['rel_y'] - $f['Y']) - $last_col_bottom + $this->y0;
		$f['Y'] += $yadj;
		unset($f['col']);
		unset($f['rel_y']);
		$this->internallink[$key] = $f;
	  }
	}

	 $last_col = -1;
	 $trans_on = false;
	 foreach($this->columnbuffer AS $key=>$s) { 
		if (isset($s['rel_y'])) {	// only process position sensitive data
			// Set ratio to expand y values or heights
			if (isset($this->ColDetails[$s['newcol']]['max_bottom']) && $this->ColDetails[$s['newcol']]['max_bottom']  && $this->ColDetails[$s['newcol']]['max_bottom']!=$this->y0) { 
				$ratio = ($lowest_bottom_y - ($this->y0)) / ($this->ColDetails[$s['newcol']]['max_bottom'] - ($this->y0));
			}
			else { $ratio = 1; }
			if (($ratio > 1) && ($ratio <= $this->max_colH_correction)) {
				//Start Transformation
				$this->pages[$this->page] .= $this->StartTransform(true)."\n";
				$this->pages[$this->page] .= $this->transformScale(100, $ratio*100, $x='', $this->y0, true)."\n";
				$trans_on = true;
			}
		}
		// Now output the adjusted values
		$this->pages[$this->page] .= $s['s']."\n"; 
		if (isset($s['rel_y']) && ($ratio > 1) && ($ratio <= $this->max_colH_correction)) {	// only process position sensitive data
			//Stop Transformation
			$this->pages[$this->page] .= $this->StopTransform(true)."\n";
	 		$trans_on = false;
		}
	 }
	 if ($trans_on) { $this->pages[$this->page] .= $this->StopTransform(true)."\n"; }
	}
	else {	// if NOT $this->colvAlign == 'J' 
		// Now output the adjusted values
		foreach($this->columnbuffer AS $s) { 
			$this->pages[$this->page] .= $s['s']."\n"; 
		}
	}
	if ($lowest_bottom_y > 0) { $this->y = $lowest_bottom_y ; }
   }

   // Columns not ended but new page -> align columns (can leave the columns alone - just tidy up the height)
   else if ($this->colvAlign == 'J' && $this->ColumnAdjust && !$this->keepColumns)  {
	// calculate the lowest bottom margin
	$lowest_bottom_y = 0;
	foreach($this->columnbuffer AS $key=>$s) { 
	   // Only process output data
	   $t = $s['s'];
	   if ($t == 'ACROFORM' || (preg_match('/BT \d+\.\d\d+ (\d+\.\d\d+) Td/',$t)) || (preg_match('/\d+\.\d\d+ (\d+\.\d\d+) \d+\.\d\d+ [\-]{0,1}\d+\.\d\d+ re/',$t)) ||
		(preg_match('/\d+\.\d\d+ (\d+\.\d\d+) l/',$t)) || 
		(preg_match('/q \d+\.\d\d+ 0 0 \d+\.\d\d+ \d+\.\d\d+ (\d+\.\d\d+) cm \/(I|FO)\d+ Do Q/',$t)) || 
		(preg_match('/\d+\.\d\d+ (\d+\.\d\d+) m/',$t)) || 
		(preg_match('/\d+\.\d\d+ (\d+\.\d\d+) \d+\.\d\d+ \d+\.\d\d+ \d+\.\d\d+ \d+\.\d\d+ c/',$t)) ) { 

		$clb = $s['y'] + $s['h'];
		if ((isset($this->ColDetails[$s['col']]['max_bottom']) && $clb > $this->ColDetails[$s['col']]['max_bottom']) || !isset($this->ColDetails[$s['col']]['max_bottom'])) { $this->ColDetails[$s['col']]['max_bottom'] = $clb; }
		if ($clb > $lowest_bottom_y) { $lowest_bottom_y = $clb; }
		$this->columnbuffer[$key]['rel_y'] = $s['y'];	// Marks position sensitive data to process later
		if ($t == 'ACROFORM') { $this->columnbuffer[$key]['s'] = ''; }
	   }
	}
	// Adjust column length equal
	 foreach($this->columnbuffer AS $key=>$s) { 
	    // Set ratio to expand y values or heights
	    if (isset($this->ColDetails[$s['col']]['max_bottom']) && $this->ColDetails[$s['col']]['max_bottom']) { 
		$ratio = ($lowest_bottom_y - ($this->y0)) / ($this->ColDetails[$s['col']]['max_bottom'] - ($this->y0));
	    }
	    else { $ratio = 1; }
	    if (($ratio > 1) && ($ratio <= $this->max_colH_correction)) {
		$yadj = ($s['y'] - $this->y0) * ($ratio - 1);

		// Adjust LINKS
		if (isset($s['rel_y'])) {	// only process position sensitive data
		   // otherwise triggers for all entries in column buffer (.e.g. formatting) and makes below adjustments more than once
		   if (isset($this->columnLinks[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])])) {
			$ref = $this->columnLinks[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])];
			$this->PageLinks[$this->page][$ref][1] -= ($yadj*_MPDFK);	// y value
			$this->PageLinks[$this->page][$ref][3] *= $ratio;	// height
			unset($this->columnLinks[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])]);	
		   }
		   // Adjust FORM FIELDS
		   if (isset($this->columnForms[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])])) {
			$ref = $this->columnForms[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])];
			$this->mpdfform->forms[$ref]['x'] += ($xadj);
			$this->mpdfform->forms[$ref]['y'] += ($yadj);
			unset($this->columnForms[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])]);
		   }
/*-- ANNOTATIONS --*/
		   if (isset($this->columnAnnots[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])])) {
			$ref = $this->columnAnnots[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])];
			$this->PageAnnots[$this->page][$ref]['y'] += ($yadj);
			unset($this->columnAnnots[$s['col']][INTVAL($s['x'])][INTVAL($s['y'])]);
		   }
/*-- END ANNOTATIONS --*/
		}
	    }
	 }

/*-- BOOKMARKS --*/

	// Adjust Bookmarks
	foreach($this->col_BMoutlines AS $v) {
		$this->BMoutlines[]=array('t'=>$v['t'],'l'=>$v['l'],'y'=>$this->y0,'p'=>$v['p']);
	}
/*-- END BOOKMARKS --*/

/*-- TOC --*/
	 
	 // Adjust ToC
	 foreach($this->col_toc AS $v) {
		$this->tocontents->_toc[]=array('t'=>$v['t'],'l'=>$v['l'],'p'=>$v['p'],'link'=>$v['link'],'toc_id'=>$v['toc_id']);
		$this->links[$v['link']][1] = $this->y0; 
	 }
/*-- END TOC --*/
	 $trans_on = false;
	 foreach($this->columnbuffer AS $key=>$s) { 
		if (isset($s['rel_y'])) {	// only process position sensitive data
			// Set ratio to expand y values or heights
			if ($this->ColDetails[$s['col']]['max_bottom']) { 
				$ratio = ($lowest_bottom_y - ($this->y0)) / ($this->ColDetails[$s['col']]['max_bottom'] - ($this->y0));
			}
			else { $ratio = 1; }
			if (($ratio > 1) && ($ratio <= $this->max_colH_correction)) {
				//Start Transformation
				$this->pages[$this->page] .= $this->StartTransform(true)."\n";
				$this->pages[$this->page] .= $this->transformScale(100, $ratio*100, $x='', $this->y0, true)."\n";
	 			$trans_on = true;
			}
		}
		// Now output the adjusted values
		$this->pages[$this->page] .= $s['s']."\n"; 
		if (isset($s['rel_y']) && ($ratio > 1) && ($ratio <= $this->max_colH_correction)) {
			//Stop Transformation
			$this->pages[$this->page] .= $this->StopTransform(true)."\n";
	 		$trans_on = false;
		}
	 }
	 if ($trans_on) { $this->pages[$this->page] .= $this->StopTransform(true)."\n"; }

	if ($lowest_bottom_y > 0) { $this->y = $lowest_bottom_y ; }
   }


   // Just reproduce the page as it was
   else {
	// If page has not ended but height adjustment was disabled by custom column-break - adjust y
	$lowest_bottom_y = 0;
	if (!$this->ColActive && (!$this->ColumnAdjust || $this->keepColumns)) {
		// calculate the lowest bottom margin
		foreach($this->columnbuffer AS $key=>$s) { 
		   // Only process output data
		   $t = $s['s'];
		   if ($t == 'ACROFORM' || (preg_match('/BT \d+\.\d\d+ (\d+\.\d\d+) Td/',$t)) || (preg_match('/\d+\.\d\d+ (\d+\.\d\d+) \d+\.\d\d+ [\-]{0,1}\d+\.\d\d+ re/',$t)) ||
			(preg_match('/\d+\.\d\d+ (\d+\.\d\d+) l/',$t)) || 
			(preg_match('/q \d+\.\d\d+ 0 0 \d+\.\d\d+ \d+\.\d\d+ (\d+\.\d\d+) cm \/(I|FO)\d+ Do Q/',$t)) || 
			(preg_match('/\d+\.\d\d+ (\d+\.\d\d+) m/',$t)) || 
			(preg_match('/\d+\.\d\d+ (\d+\.\d\d+) \d+\.\d\d+ \d+\.\d\d+ \d+\.\d\d+ \d+\.\d\d+ c/',$t)) ) { 

			$clb = $s['y'] + $s['h'];
			if ($clb > $this->ColDetails[$s['col']]['max_bottom']) { $this->ColDetails[$s['col']]['max_bottom'] = $clb; }
			if ($clb > $lowest_bottom_y) { $lowest_bottom_y = $clb; }
		   }
		}
	}
	foreach($this->columnbuffer AS $key=>$s) { 
		if ($s['s'] != 'ACROFORM') 
			$this->pages[$this->page] .= $s['s']."\n"; 
	}
	if ($lowest_bottom_y > 0) { $this->y = $lowest_bottom_y ; }
/*-- BOOKMARKS --*/
      // Output Bookmarks
      foreach($this->col_BMoutlines AS $v) {
		$this->BMoutlines[]=array('t'=>$v['t'],'l'=>$v['l'],'y'=>$v['y'],'p'=>$v['p']);
      }
/*-- END BOOKMARKS --*/
/*-- TOC --*/
      // Output ToC
      foreach($this->col_toc AS $v) {
		$this->tocontents->_toc[]=array('t'=>$v['t'],'l'=>$v['l'],'p'=>$v['p'],'link'=>$v['link'],'toc_id'=>$v['toc_id']);
      }
/*-- END TOC --*/
   }
   foreach($this->internallink AS $key => $f) {
	if (isset($this->internallink[$key]['col'])) unset($this->internallink[$key]['col']);
	if (isset($this->internallink[$key]['rel_y'])) unset($this->internallink[$key]['rel_y']);
   }

   $this->columnbuffer = array();
   $this->ColDetails = array();
   $this->columnLinks = array();
   $this->columnAnnots = array();
   $this->columnForms = array();
   
   $this->col_BMoutlines = array();
   $this->col_toc = array();
   $this->breakpoints = array();
}

// mPDF 5.7+
function columnAdjustPregReplace($type, $xadj, $yadj, $pattern, $subject) {
	preg_match($pattern, $subject, $matches);
	if (!count($matches)) { return $subject; }
	if (!isset($matches[3])) { $matches[3] = 0; }
	if (!isset($matches[4])) { $matches[4] = 0; }
	if (!isset($matches[5])) { $matches[5] = 0; }
	if (!isset($matches[6])) { $matches[6] = 0; }
	return str_replace($matches[0], $this->columnAdjustAdd($type, _MPDFK, $xadj, $yadj, $matches[1], $matches[2], $matches[3], $matches[4], $matches[5], $matches[6]), $subject);
}

/*-- END COLUMNS --*/


//==================================================================
/*-- TABLES --*/
function printcellbuffer() {
	if (count($this->cellBorderBuffer )) {
		sort($this->cellBorderBuffer);
		foreach($this->cellBorderBuffer AS $cbb) {
			$cba = unpack("A16dom/nbord/A1side/ns/dbw/a6ca/A10style/dx/dy/dw/dh/dmbl/dmbr/dmrt/dmrb/dmtl/dmtr/dmlt/dmlb/dcpd/dover/", $cbb);
			$side = $cba['side'];
			$color = str_pad($cba['ca'], 6, "\x00");
			$details = array();
			$details[$side]['dom'] = (float) $cba['dom'];
			$details[$side]['s'] = $cba['s'];
			$details[$side]['w'] = $cba['bw'];
			$details[$side]['c'] = $color;
			$details[$side]['style'] = trim($cba['style']);
			$details['mbw']['BL'] = $cba['mbl'];
			$details['mbw']['BR'] = $cba['mbr'];
			$details['mbw']['RT'] = $cba['mrt'];
			$details['mbw']['RB'] = $cba['mrb'];
			$details['mbw']['TL'] = $cba['mtl'];
			$details['mbw']['TR'] = $cba['mtr'];
			$details['mbw']['LT'] = $cba['mlt'];
			$details['mbw']['LB'] = $cba['mlb'];
			$details['cellposdom'] = $cba['cpd'];
			$details['p'] = $side;
			if ($cba['over']==1) { $details[$side]['overlay'] = true;  }
			else { $details[$side]['overlay'] = false; }
			$this->_tableRect($cba['x'],$cba['y'],$cba['w'],$cba['h'],$cba['bord'],$details, false, false);

		}
		$this->cellBorderBuffer = array();
	}
}
//==================================================================
function printtablebuffer() {

	if (!$this->table_rotate) { 
		$this->pages[$this->page] .= $this->tablebuffer;
		foreach($this->tbrot_Links AS $p => $l) {
		   foreach($l AS $v) {
			$this->PageLinks[$p][] = $v;
		   }
		}
		$this->tbrot_Links = array();
/*-- ANNOTATIONS --*/
		foreach($this->tbrot_Annots AS $p => $l) {
		   foreach($l AS $v) {
			$this->PageAnnots[$p][] = $v;
		   }
		}
		$this->tbrot_Annots = array();
/*-- END ANNOTATIONS --*/

/*-- BOOKMARKS --*/
	      // Output Bookmarks
	      foreach($this->tbrot_BMoutlines AS $v) {
			$this->BMoutlines[]=array('t'=>$v['t'],'l'=>$v['l'],'y'=>$v['y'],'p'=>$v['p']);
	      }
		$this->tbrot_BMoutlines = array();
/*-- END BOOKMARKS --*/

/*-- TOC --*/
	      // Output ToC
	      foreach($this->tbrot_toc AS $v) {
			$this->tocontents->_toc[]=array('t'=>$v['t'],'l'=>$v['l'],'p'=>$v['p'],'link'=>$v['link'],'toc_id'=>$v['toc_id']);
	      }
		$this->tbrot_toc = array();
/*-- END TOC --*/

		return; 
	}
	// else if rotated
	$lm = $this->lMargin + $this->blk[$this->blklvl]['outer_left_margin'] + $this->blk[$this->blklvl]['border_left']['w'] + $this->blk[$this->blklvl]['padding_left'];
	$pw = $this->blk[$this->blklvl]['inner_width'];
	//Start Transformation
	$this->pages[$this->page] .= $this->StartTransform(true)."\n";

	if ($this->table_rotate > 1) {	// clockwise
	   if ($this->tbrot_align == 'L') {
		$xadj = $this->tbrot_h ;	// align L (as is)
	   }
	   else if ($this->tbrot_align == 'R') {
		$xadj = $lm-$this->tbrot_x0+($pw) ;	// align R
	   }
	   else {
		$xadj = $lm-$this->tbrot_x0+(($pw + $this->tbrot_h)/2) ;	// align C
	   }
	   $yadj = 0;
	}
	else {	// anti-clockwise
	   if ($this->tbrot_align == 'L') {
		$xadj = 0 ;	// align L (as is)
	   }
	   else if ($this->tbrot_align == 'R') {
		$xadj = $lm-$this->tbrot_x0+($pw - $this->tbrot_h) ;	// align R
	   }
	   else {
		$xadj = $lm-$this->tbrot_x0+(($pw - $this->tbrot_h)/2) ;	// align C
	   }
	   $yadj = $this->tbrot_w;
	}


	$this->pages[$this->page] .= $this->transformTranslate($xadj, $yadj , true)."\n";
	$this->pages[$this->page] .= $this->transformRotate($this->table_rotate, $this->tbrot_x0 , $this->tbrot_y0 , true)."\n";

	// Now output the adjusted values
	$this->pages[$this->page] .= $this->tablebuffer; 


	foreach($this->tbrot_Links AS $p => $l) {
	    foreach($l AS $v) {
		$w = $v[2]/_MPDFK;
		$h = $v[3]/_MPDFK;
		$ax = ($v[0]/_MPDFK) - $this->tbrot_x0;
		$ay = (($this->hPt-$v[1])/_MPDFK) - $this->tbrot_y0;
		if ($this->table_rotate > 1) {	// clockwise
			$bx = $this->tbrot_x0+$xadj-$ay-$h;
			$by = $this->tbrot_y0+$yadj+$ax;
		}
		else {
			$bx = $this->tbrot_x0+$xadj+$ay;
			$by = $this->tbrot_y0+$yadj-$ax-$w;
		}
		$v[0] = $bx*_MPDFK;
		$v[1] = ($this->h-$by)*_MPDFK;
		$v[2] = $h*_MPDFK;	// swap width and height
		$v[3] = $w*_MPDFK;
		$this->PageLinks[$p][] = $v;
	    }
	}
	$this->tbrot_Links = array();
	foreach($this->internallink AS $key => $f) {
		if (is_array($f) && isset($f['tbrot'])) {
			$f['Y'] = $this->tbrot_y0;
			$f['PAGE'] = $this->page;
			unset($f['tbrot']);
			$this->internallink[$key] = $f;
		}
	}
/*-- ANNOTATIONS --*/
	foreach($this->tbrot_Annots AS $p => $l) {
	    foreach($l AS $v) {
		$ax = abs($v['x']) - $this->tbrot_x0;	// abs because -ve values are internally set and held for reference if annotMargin set
		$ay = $v['y'] - $this->tbrot_y0;
		if ($this->table_rotate > 1) {	// clockwise
			$bx = $this->tbrot_x0+$xadj-$ay;
			$by = $this->tbrot_y0+$yadj+$ax;
		}
		else {
			$bx = $this->tbrot_x0+$xadj+$ay;
			$by = $this->tbrot_y0+$yadj-$ax;
		}
		if ($v['x'] < 0) {
			$v['x'] = -$bx;
		}
		else {
			$v['x'] = $bx;
		}
		$v['y'] = ($by);
		$this->PageAnnots[$p][] = $v;
	    }
	}
	$this->tbrot_Annots = array();
/*-- END ANNOTATIONS --*/


/*-- BOOKMARKS --*/

	// Adjust Bookmarks
	foreach($this->tbrot_BMoutlines AS $v) {
		$v['y'] = $this->tbrot_y0;
		$this->BMoutlines[]=array('t'=>$v['t'],'l'=>$v['l'],'y'=>$v['y'],'p'=>$this->page);
	}
/*-- END BOOKMARKS --*/

/*-- TOC --*/

	// Adjust ToC - uses document page number
	foreach($this->tbrot_toc AS $v) {
		$this->tocontents->_toc[]=array('t'=>$v['t'],'l'=>$v['l'],'p'=>$this->page,'link'=>$v['link'],'toc_id'=>$v['toc_id']);
		$this->links[$v['link']][1] = $this->tbrot_y0; 
	}
/*-- END TOC --*/



	$this->tbrot_BMoutlines = array();
	$this->tbrot_toc = array();

	//Stop Transformation
	$this->pages[$this->page] .= $this->StopTransform(true)."\n";


	$this->y = $this->tbrot_y0 + $this->tbrot_w;
	$this->x = $this->lMargin;

	$this->tablebuffer = '';
}

//==================================================================
// Keep-with-table This buffers contents of h1-6 to keep on page with table
function printkwtbuffer() {
	if (!$this->kwt_moved) { 
		foreach($this->kwt_buffer AS $s) { $this->pages[$this->page] .= $s['s']."\n"; }
		foreach($this->kwt_Links AS $p => $l) {
		   foreach($l AS $v) {
			$this->PageLinks[$p][] = $v;
		   }
		}
		$this->kwt_Links = array();
/*-- ANNOTATIONS --*/
		foreach($this->kwt_Annots AS $p => $l) {
		   foreach($l AS $v) {
			$this->PageAnnots[$p][] = $v;
		   }
		}
		$this->kwt_Annots = array();
/*-- END ANNOTATIONS --*/

/*-- INDEX --*/
	      // Output Reference (index)
	      foreach($this->kwt_Reference AS $v) {
			$Present=0;
			for ($i=0;$i<count($this->Reference);$i++){
				if ($this->Reference[$i]['t']==$v['t']){
					$Present=1;
					if (!in_array($v['op'],$this->Reference[$i]['p'])) {
						$this->Reference[$i]['p'][] = $v['op'];
					}
				}
			}
			if ($Present==0) {
				$this->Reference[]=array('t'=>$v['t'],'p'=>array($v['op']));
			}
	      }
		$this->kwt_Reference = array();
/*-- END INDEX --*/

/*-- BOOKMARKS --*/
	      // Output Bookmarks
	      foreach($this->kwt_BMoutlines AS $v) {
			$this->BMoutlines[]=array('t'=>$v['t'],'l'=>$v['l'],'y'=>$v['y'],'p'=>$v['p']);
	      }
		$this->kwt_BMoutlines = array();
/*-- END BOOKMARKS --*/

/*-- TOC --*/
	      // Output ToC
	      foreach($this->kwt_toc AS $v) {
			$this->tocontents->_toc[]=array('t'=>$v['t'],'l'=>$v['l'],'p'=>$v['p'],'link'=>$v['link'],'toc_id'=>$v['toc_id']);
	      }
		$this->kwt_toc = array();
/*-- END TOC --*/

		$this->pageoutput[$this->page] = array();	// mPDF 6
		return; 
	}

	//Start Transformation
	$this->pages[$this->page] .= $this->StartTransform(true)."\n";
	$xadj = $this->lMargin - $this->kwt_x0 ;
	//$yadj = $this->y - $this->kwt_y0 ;
	$yadj = $this->tMargin - $this->kwt_y0 ;

	$this->pages[$this->page] .= $this->transformTranslate($xadj, $yadj , true)."\n";

	// Now output the adjusted values
	foreach($this->kwt_buffer AS $s) { $this->pages[$this->page] .= $s['s']."\n"; }

	// Adjust hyperLinks
	foreach($this->kwt_Links AS $p => $l) {
	    foreach($l AS $v) {
		$bx = $this->kwt_x0+$xadj;
		$by = $this->kwt_y0+$yadj;
		$v[0] = $bx*_MPDFK;
		$v[1] = ($this->h-$by)*_MPDFK;
		$this->PageLinks[$p][] = $v;
	    }
	}
	foreach($this->internallink AS $key => $f) {
		if (is_array($f) && isset($f['kwt'])) {
			$f['Y'] += $yadj;
			$f['PAGE'] = $this->page;
			unset($f['kwt']);
			$this->internallink[$key] = $f;
		}
	}
/*-- ANNOTATIONS --*/
	foreach($this->kwt_Annots AS $p => $l) {
	    foreach($l AS $v) {
		$bx = $this->kwt_x0+$xadj;
		$by = $this->kwt_y0+$yadj;
		if ($v['x'] < 0) {
			$v['x'] = -$bx;
		}
		else {
			$v['x'] = $bx;
		}
		$v['y'] = $by;
		$this->PageAnnots[$p][] = $v;
	    }
	}
/*-- END ANNOTATIONS --*/

/*-- BOOKMARKS --*/

	// Adjust Bookmarks
	foreach($this->kwt_BMoutlines AS $v) {
		if ($v['y'] != 0) { $v['y'] += $yadj; }
		$this->BMoutlines[]=array('t'=>$v['t'],'l'=>$v['l'],'y'=>$v['y'],'p'=>$this->page);
	}
/*-- END BOOKMARKS --*/

/*-- INDEX --*/

	// Adjust Reference (index)
	foreach($this->kwt_Reference AS $v) {
		$Present=0;
		//Search the reference (AND Ref/PageNo) in the array
		for ($i=0;$i<count($this->Reference);$i++){
			if ($this->Reference[$i]['t']==$v['t']){
				$Present=1;
				if (!in_array($this->page,$this->Reference[$i]['p'])) {
					$this->Reference[$i]['p'][] = $this->page;
				}
			}
		}
		if ($Present==0) {
			$this->Reference[]=array('t'=>$v['t'],'p'=>array($this->page));
		}
	}
/*-- END INDEX --*/

/*-- TOC --*/

	// Adjust ToC
	foreach($this->kwt_toc AS $v) {
		$this->tocontents->_toc[]=array('t'=>$v['t'],'l'=>$v['l'],'p'=>$this->page,'link'=>$v['link'],'toc_id'=>$v['toc_id']);
		$this->links[$v['link']][0] = $this->page;
		$this->links[$v['link']][1] += $yadj;
	}
/*-- END TOC --*/


	$this->kwt_Links = array();
	$this->kwt_Annots = array();

	$this->kwt_Reference = array();
	$this->kwt_BMoutlines = array();
	$this->kwt_toc = array();
	//Stop Transformation
	$this->pages[$this->page] .= $this->StopTransform(true)."\n";

	$this->kwt_buffer = array();

	$this->y += $this->kwt_height;
	$this->pageoutput[$this->page] = array();	// mPDF 6
}

/*-- END TABLES --*/


//==================================================================

function printfloatbuffer() {
	if (count($this->floatbuffer)) {
		$this->objectbuffer = $this->floatbuffer;
		$this->printobjectbuffer(false);
		$this->objectbuffer = array();
		$this->floatbuffer = array();
		$this->floatmargins = array();
	}
}
//==================================================================



//==================================================================
// Added ELLIPSES and CIRCLES
function Circle($x,$y,$r,$style='S') {
	$this->Ellipse($x,$y,$r,$r,$style);
}

function Ellipse($x,$y,$rx,$ry,$style='S') {
	if($style=='F') { $op='f'; }
	elseif($style=='FD' or $style=='DF') { $op='B'; }
	else { $op='S'; }
	$lx=4/3*(M_SQRT2-1)*$rx;
	$ly=4/3*(M_SQRT2-1)*$ry;
	$h=$this->h;
	$this->_out(sprintf('%.3F %.3F m %.3F %.3F %.3F %.3F %.3F %.3F c', ($x+$rx)*_MPDFK,($h-$y)*_MPDFK, ($x+$rx)*_MPDFK,($h-($y-$ly))*_MPDFK, ($x+$lx)*_MPDFK,($h-($y-$ry))*_MPDFK, $x*_MPDFK,($h-($y-$ry))*_MPDFK));
	$this->_out(sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c', ($x-$lx)*_MPDFK,($h-($y-$ry))*_MPDFK, ($x-$rx)*_MPDFK,($h-($y-$ly))*_MPDFK, ($x-$rx)*_MPDFK,($h-$y)*_MPDFK)); 
	$this->_out(sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c', ($x-$rx)*_MPDFK,($h-($y+$ly))*_MPDFK, ($x-$lx)*_MPDFK,($h-($y+$ry))*_MPDFK, $x*_MPDFK,($h-($y+$ry))*_MPDFK)); 
	$this->_out(sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c %s', ($x+$lx)*_MPDFK,($h-($y+$ry))*_MPDFK, ($x+$rx)*_MPDFK,($h-($y+$ly))*_MPDFK, ($x+$rx)*_MPDFK,($h-$y)*_MPDFK, $op));
}

/*-- DIRECTW --*/
// Added adaptation of shaded_box = AUTOSIZE-TEXT
function AutosizeText($text,$w,$font,$style,$szfont=72) {

	$text = ' '.$text.' ';

 	$this->SetFont($font,$style,$szfont,false);

	$text = $this->purify_utf8_text($text);
	if ($this->text_input_as_HTML) {
		$text = $this->all_entities_to_utf8($text);
	}
	if ($this->usingCoreFont) { $text = mb_convert_encoding($text,$this->mb_enc,'UTF-8'); }

	// DIRECTIONALITY
	if (preg_match("/([".$this->pregRTLchars."])/u", $text)) { $this->biDirectional = true; }	// *OTL*

	$textvar = 0;
	$save_OTLtags = $this->OTLtags;
	$this->OTLtags = array();
	if ($this->useKerning) {
		if ($this->CurrentFont['haskernGPOS']) { $this->OTLtags['Plus'] .= ' kern'; }
		else { $textvar = ($textvar | FC_KERNING); }
	}

/*-- OTL --*/
	// Use OTL OpenType Table Layout - GSUB & GPOS
	if (isset($this->CurrentFont['useOTL']) && $this->CurrentFont['useOTL']) {
		$text = $this->otl->applyOTL($text, $this->CurrentFont['useOTL']);
		$OTLdata = $this->otl->OTLdata;
	}
/*-- END OTL --*/
	$this->OTLtags = $save_OTLtags ;

	$this->magic_reverse_dir($text, $this->directionality, $OTLdata);


	$width = $this->ConvertSize($w);
	$loop   = 0;
	while ( $loop == 0 ) {
		$this->SetFont($font,$style,$szfont,false);
		$sz = $this->GetStringWidth( $text, true, $OTLdata, $textvar );
		if ( $sz > $w ) { $szfont --; }
		else { $loop ++; }
	}
 	$this->SetFont($font,$style,$szfont,true,true);
	$this->Cell($w, 0, $text, 0, 0, "C",0,'',0,0,0,'M', 0, false, $OTLdata, $textvar );
}
/*-- END DIRECTW --*/





// ====================================================
// ====================================================

function magic_reverse_dir(&$chunk, $dir, &$chunkOTLdata) {
/*-- OTL --*/
	if ($this->usingCoreFont) { return 0; }
	if ($chunk=='') { return 0; }

	if ($this->biDirectional || $dir=='rtl')  {
		// check if string contains RTL text
		// including any added from OTL tables (in PUA)
		$pregRTLchars = $this->pregRTLchars;
		if (isset($this->CurrentFont['rtlPUAstr']) && $this->CurrentFont['rtlPUAstr']) { $pregRTLchars .= $this->CurrentFont['rtlPUAstr']; }
		if (!preg_match("/[".$pregRTLchars."]/u",$chunk) && $dir!='rtl') { return 0; }   // Chunk doesn't contain RTL characters

		$unicode = $this->UTF8StringToArray($chunk, false);

		$is_strong = false;
		if (empty($chunkOTLdata)) { $this->getBasicOTLdata($chunkOTLdata, $unicode, $is_strong); }

		if (isset($this->CurrentFont['useOTL']) && ($this->CurrentFont['useOTL'] & 0x80) ) { $useGPOS = true; }
		else { $useGPOS = false; }

		// NB Returned $chunk may be a shorter string (with adjusted $cOTLdata) by removal of LRE, RLE etc embedding codes.
		list($chunk ,$rtl_content) = $this->otl->_bidiSort($unicode, $chunk, $dir, $chunkOTLdata, $useGPOS);

		return $rtl_content;
	}
/*-- END OTL --*/
	return 0;
}


/*-- OTL --*/
function getBasicOTLdata(&$chunkOTLdata, $unicode, &$is_strong) {
	if (!class_exists('otl', false)) { include(_MPDF_PATH.'classes/otl.php'); }
	if (empty($this->otl)) { $this->otl = new otl($this); }
	$chunkOTLdata['group'] = '';
	$chunkOTLdata['GPOSinfo'] = array();
	$chunkOTLdata['char_data'] = array();
	foreach($unicode as $char) {
		$ucd_record = UCDN::get_ucd_record($char);
		$chunkOTLdata['char_data'][] = array('bidi_class' => $ucd_record[2], 'uni' => $char);
		if ($ucd_record[2]==0 || $ucd_record[2]==3 || $ucd_record[2]==4) { $is_strong = true; } // contains strong character
		if ($ucd_record[0] == UCDN::UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) { $chunkOTLdata['group'] .=  'M'; }
		else if ($char == 32 || $char == 12288) { $chunkOTLdata['group'] .=  'S'; }
		else { $chunkOTLdata['group'] .=  'C'; }
	}
}

function _setBidiCodes($mode='start', $bdf) {
	$s = '';
	if ($mode=='end') {
		// PDF comes before PDI to close isolate-override (e.g. "LRILROPDFPDI")
		if (strpos($bdf, 'PDF')!==false) { $s .= code2utf(0x202C); }	// POP DIRECTIONAL FORMATTING
		if (strpos($bdf, 'PDI')!==false) { $s .= code2utf(0x2069); }	// POP DIRECTIONAL ISOLATE
	}
	else if ($mode=='start') {
		// LRI comes before LRO to open isolate-override (e.g. "LRILROPDFPDI")
		if (strpos($bdf, 'LRI')!==false) { $s .= code2utf(0x2066); }	// U+2066 LRI  
		else if (strpos($bdf, 'RLI')!==false) { $s .= code2utf(0x2067); }	// U+2067 RLI 
		else if (strpos($bdf, 'FSI')!==false) { $s .= code2utf(0x2068); }	// U+2068 FSI
		if (strpos($bdf, 'LRO')!==false) { $s .= code2utf(0x202D); }	// U+202D LRO
		else if (strpos($bdf, 'RLO')!==false) { $s .= code2utf(0x202E); }	// U+202E RLO
		else if (strpos($bdf, 'LRE')!==false) { $s .= code2utf(0x202A); }	// U+202A LRE
		else if (strpos($bdf, 'RLE')!==false) { $s .= code2utf(0x202B); }	// U+202B RLE
	}
	return $s;
}

/*-- END OTL --*/

// 
// ****************************

// ****************************


function SetSubstitutions() {
	$subsarray = array();
	@include(_MPDF_PATH.'includes/subs_win-1252.php');
	$this->substitute = array();
	foreach($subsarray AS $key => $val) {
		$this->substitute[code2utf($key)] = $val;
	}
}


function SubstituteChars($html) {
	// only substitute characters between tags
	if (count($this->substitute)) {
		$a=preg_split('/(<.*?>)/ms',$html,-1,PREG_SPLIT_DELIM_CAPTURE);
		$html = '';
		foreach($a as $i => $e) {
			if($i%2==0) {
			   $e = strtr($e, $this->substitute);
			}
			$html .= $e;
		}
	}
	return $html;
}


function SubstituteCharsSIP(&$writehtml_a, &$writehtml_i, &$writehtml_e) {
	if (preg_match("/^(.*?)([\x{20000}-\x{2FFFF}]+)(.*)/u", $writehtml_e, $m)) { 
	   if (isset($this->CurrentFont['sipext']) && $this->CurrentFont['sipext']) {
		$font = $this->CurrentFont['sipext']; 
		if (!in_array($font, $this->available_unifonts)) { return 0; }
		$writehtml_a[$writehtml_i] = $writehtml_e = $m[1];
		array_splice($writehtml_a, $writehtml_i+1, 0, array('span style="font-family: '.$font.'"', $m[2], '/span', $m[3]));
		$this->subPos = $writehtml_i;
		return 4;
	   }
	}
	return 0; 
}

// If core font is selected in document which is not onlyCoreFonts - substitute with non-core font
function SubstituteCharsNonCore(&$writehtml_a, &$writehtml_i, &$writehtml_e) {
	// Ignore if in Textarea
	if ($writehtml_i > 0 && strtolower(substr($writehtml_a[$writehtml_i-1],0,8)) == 'textarea') { return 0; }
	if (mb_convert_encoding(mb_convert_encoding($writehtml_e, $this->mb_enc, "UTF-8"), "UTF-8", $this->mb_enc) == $writehtml_e) {
		return 0;
	}
	$cw = &$this->CurrentFont['cw'];
	$unicode = $this->UTF8StringToArray($writehtml_e, false);
	$start = -1;
	$end = 0;
	$flag = 0;
	$ftype = '';
	$u = array();
	if (!$this->subArrMB) { 
		include(_MPDF_PATH.'includes/subs_core.php'); 
		$this->subArrMB['a'] = $aarr;
		$this->subArrMB['s'] = $sarr;
		$this->subArrMB['z'] = $zarr;
	}
	foreach($unicode AS $c => $char) {
		if (($char> 127 || ($flag==1 && $char==32)) && $char != 173 && (!isset($this->subArrMB['a'][$char]) || ($flag==1 && $char==32)) && ($char<1536 ||  ($char>1791 && $char < 2304) || $char>3455)) { 
			if ($flag==0) { $start=$c; }
			$flag=1; 
			$u[] = $char;
		}
		else if ($flag>0) { $end=$c-1; break; }
	}
	if ($flag>0 && !$end) { $end=count($unicode)-1; }
	if ($start==-1) { return 0; }
	// TRY IN BACKUP SUBS FONT
	if (!is_array($this->backupSubsFont)) { $this->backupSubsFont = array("$this->backupSubsFont"); }
	foreach($this->backupSubsFont AS $bsfctr=>$bsf) {
		if ($this->fonttrans[$bsf] == 'chelvetica' || $this->fonttrans[$bsf] == 'ctimes' || $this->fonttrans[$bsf] == 'ccourier') { continue; }
		$font = $bsf; 
		unset($cw);
		$cw = '';
		if (isset($this->fonts[$font])) { $cw = &$this->fonts[$font]['cw']; }
		else if (file_exists(_MPDF_TTFONTDATAPATH.$font.'.cw.dat')) { $cw = @file_get_contents(_MPDF_TTFONTDATAPATH.$font.'.cw.dat'); }
		else {

			$prevFontFamily = $this->FontFamily;
			$prevFontStyle = $this->currentfontstyle;
			$prevFontSizePt = $this->FontSizePt;
			$this->SetFont($bsf, '', '', false);
			$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.$font.'.cw.dat');
			$this->SetFont($prevFontFamily, $prevFontStyle, $prevFontSizePt, false);
		}
		if (!$cw) { continue; }
		$l = 0;
		foreach($u AS $char) {
			if ($char == 173 || $this->_charDefined($cw,$char) || ($char>1536 && $char<1791) || ($char>2304 && $char<3455 )) {
				$l++;
			}
			else {
				if ($l==0 && $bsfctr == (count($this->backupSubsFont)-1)) {	// Not found even in last backup font
					$cont = mb_substr($writehtml_e, $start+1);
					$writehtml_e = mb_substr($writehtml_e, 0, $start+1, 'UTF-8');
					array_splice($writehtml_a, $writehtml_i+1, 0, array('', $cont));
					$this->subPos = $writehtml_i+1;
					return 2;
				}
				else { break; }
			}
		}
		if ($l > 0) {
			$patt = mb_substr($writehtml_e, $start, $l, 'UTF-8');
			if (preg_match("/(.*?)(".preg_quote($patt,'/').")(.*)/u", $writehtml_e, $m)) {
				$writehtml_e = $m[1];
				array_splice($writehtml_a, $writehtml_i+1, 0, array('span style="font-family: '.$font.'"', $m[2], '/span', $m[3]));
				$this->subPos = $writehtml_i+3;
				return 4;
			}
		}
	}

	unset($cw); 
	return 0;
}


function SubstituteCharsMB(&$writehtml_a, &$writehtml_i, &$writehtml_e) {
	// Ignore if in Textarea
	if ($writehtml_i > 0 && strtolower(substr($writehtml_a[$writehtml_i-1],0,8)) == 'textarea') { return 0; }
	$cw = &$this->CurrentFont['cw'];
	$unicode = $this->UTF8StringToArray($writehtml_e, false);
	$start = -1;
	$end = 0;
	$flag = 0;
	$ftype = '';
	$u = array();
	foreach($unicode AS $c => $char) {
		if (($flag == 0 || $flag==2) && (!$this->_charDefined($cw,$char) || ($flag==2 && $char==32)) && $this->checkSIP && $char > 131071) { 	// Unicode Plane 2 (SIP)
			if (in_array($this->FontFamily ,$this->available_CJK_fonts)) { return 0; }
			if ($flag==0) { $start=$c; }
			$flag=2; 
			$u[] = $char;
		}
		//else if (($flag == 0 || $flag==1) && $char != 173 && !$this->_charDefined($cw,$char) && ($char<1423 ||  ($char>3583 && $char < 11263))) { 
		else if (($flag == 0 || $flag==1) && $char != 173 && (!$this->_charDefined($cw,$char) || ($flag==1 && $char==32)) && ($char<1536 ||  ($char>1791 && $char < 2304) || $char>3455)) { 
			if ($flag==0) { $start=$c; }
			$flag=1; 
			$u[] = $char;
		}
		else if ($flag>0) { $end=$c-1; break; }
	}
	if ($flag>0 && !$end) { $end=count($unicode)-1; }
	if ($start==-1) { return 0; }
	if ($flag == 2) { 	// SIP
		// Check if current CJK font has a ext-B related font
	   if (isset($this->CurrentFont['sipext']) && $this->CurrentFont['sipext']) {
		$font = $this->CurrentFont['sipext']; 
		unset($cw);
		$cw = '';
		if (isset($this->fonts[$font])) { $cw = &$this->fonts[$font]['cw']; }
		else if (file_exists(_MPDF_TTFONTDATAPATH.$font.'.cw.dat')) { $cw = @file_get_contents(_MPDF_TTFONTDATAPATH.$font.'.cw.dat'); }
		else {
			$prevFontFamily = $this->FontFamily;
			$prevFontStyle = $this->currentfontstyle;
			$prevFontSizePt = $this->FontSizePt;
			$this->SetFont($font, '', '', false);
			$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.$font.'.cw.dat');
			$this->SetFont($prevFontFamily, $prevFontStyle, $prevFontSizePt, false);
		}
		if (!$cw) { return 0; }
		$l = 0;
		foreach($u AS $char) {
			if ($this->_charDefined($cw,$char) || $char > 131071) {
				$l++;
			}
			else { break; }
		}
		if ($l > 0) {
			$patt = mb_substr($writehtml_e, $start, $l);
			if (preg_match("/(.*?)(".preg_quote($patt,'/').")(.*)/u", $writehtml_e, $m)) {
				$writehtml_e = $m[1];
				array_splice($writehtml_a, $writehtml_i+1, 0, array('span style="font-family: '.$font.'"', $m[2], '/span', $m[3]));
				$this->subPos = $writehtml_i+3;
				return 4;
			}
		}
	   }
		// Check Backup SIP font (defined in config_fonts.php)
	   if (isset($this->backupSIPFont) && $this->backupSIPFont) {
		if ($this->currentfontfamily != $this->backupSIPFont) { $font = $this->backupSIPFont; }
		else { unset($cw); return 0; }
		unset($cw);
		$cw = '';
		if (isset($this->fonts[$font])) { $cw = &$this->fonts[$font]['cw']; }
		else if (file_exists(_MPDF_TTFONTDATAPATH.$font.'.cw.dat')) { $cw = @file_get_contents(_MPDF_TTFONTDATAPATH.$font.'.cw.dat'); }
		else {
			$prevFontFamily = $this->FontFamily;
			$prevFontStyle = $this->currentfontstyle;
			$prevFontSizePt = $this->FontSizePt;
			$this->SetFont($this->backupSIPFont, '', '', false);
			$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.$font.'.cw.dat');
			$this->SetFont($prevFontFamily, $prevFontStyle, $prevFontSizePt, false);
		}
		if (!$cw) { return 0; }
		$l = 0;
		foreach($u AS $char) {
			if ($this->_charDefined($cw,$char) || $char > 131071) {
				$l++;
			}
			else { break; }
		}
		if ($l > 0) {
			$patt = mb_substr($writehtml_e, $start, $l);
			if (preg_match("/(.*?)(".preg_quote($patt,'/').")(.*)/u", $writehtml_e, $m)) {
				$writehtml_e = $m[1];
				array_splice($writehtml_a, $writehtml_i+1, 0, array('span style="font-family: '.$font.'"', $m[2], '/span', $m[3]));
				$this->subPos = $writehtml_i+3;
				return 4;
			}
		}
	   }
	   return 0; 
	}


	// FIRST TRY CORE FONTS (when appropriate)
	if (!$this->PDFA && !$this->PDFX && !$this->biDirectional) { 	// mPDF 6
	  $repl = array();
	  if (!$this->subArrMB) { 
		include(_MPDF_PATH.'includes/subs_core.php'); 
		$this->subArrMB['a'] = $aarr;
		$this->subArrMB['s'] = $sarr;
		$this->subArrMB['z'] = $zarr;
	  }
	  if (isset($this->subArrMB['a'][$u[0]])) { 
		$font = 'tta'; $ftype = 'C'; 
		foreach($u AS $char) {
			if (isset($this->subArrMB['a'][$char])) { $repl[] = $this->subArrMB['a'][$char]; }
			else { break; }
		}
	  }
	  else if (isset($this->subArrMB['z'][$u[0]])) { 
		$font = 'ttz'; $ftype = 'C'; 
		foreach($u AS $char) {
			if (isset($this->subArrMB['z'][$char])) { $repl[] = $this->subArrMB['z'][$char]; }
			else { break; }
		}
	  }
	  else if (isset($this->subArrMB['s'][$u[0]])) { 
		$font = 'tts'; $ftype = 'C'; 
		foreach($u AS $char) {
			if (isset($this->subArrMB['s'][$char])) { $repl[] = $this->subArrMB['s'][$char]; }
			else { break; }
		}
	  }
	  if ($ftype=='C') {
		$patt = mb_substr($writehtml_e, $start, count($repl));
		if (preg_match("/(.*?)(".preg_quote($patt,'/').")(.*)/u", $writehtml_e, $m)) {
			$writehtml_e = $m[1];
			array_splice($writehtml_a, $writehtml_i+1, 0, array($font, implode('|', $repl), '/'.$font, $m[3]));	// e.g. <tts>
			$this->subPos = $writehtml_i+3;
			return 4;
		}
		return 0;
	  }
	}

	// LASTLY TRY IN BACKUP SUBS FONT
	if (!is_array($this->backupSubsFont)) { $this->backupSubsFont = array("$this->backupSubsFont"); }
	foreach($this->backupSubsFont AS $bsfctr=>$bsf) {
		if ($this->currentfontfamily != $bsf) { $font = $bsf; }
		else { continue; }
		unset($cw);
		$cw = '';
		if (isset($this->fonts[$font])) { $cw = &$this->fonts[$font]['cw']; }
		else if (file_exists(_MPDF_TTFONTDATAPATH.$font.'.cw.dat')) { $cw = @file_get_contents(_MPDF_TTFONTDATAPATH.$font.'.cw.dat'); }
		else {
			$prevFontFamily = $this->FontFamily;
			$prevFontStyle = $this->currentfontstyle;
			$prevFontSizePt = $this->FontSizePt;
			$this->SetFont($bsf, '', '', false);
			$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.$font.'.cw.dat');
			$this->SetFont($prevFontFamily, $prevFontStyle, $prevFontSizePt, false);
		}
		if (!$cw) { continue; }
		$l = 0;
		foreach($u AS $char) {
			if ($char == 173 || $this->_charDefined($cw,$char) || ($char>1536 && $char<1791) || ($char>2304 && $char<3455 )) { 	// Arabic and Indic 
				$l++;
			}
			else {
				if ($l==0 && $bsfctr == (count($this->backupSubsFont)-1)) {	// Not found even in last backup font
					$cont = mb_substr($writehtml_e, $start+1);
					$writehtml_e = mb_substr($writehtml_e, 0, $start+1);
					array_splice($writehtml_a, $writehtml_i+1, 0, array('', $cont));
					$this->subPos = $writehtml_i+1;
					return 2;
				}
				else { break; }
			}
		}
		if ($l > 0) {
			$patt = mb_substr($writehtml_e, $start, $l);
			if (preg_match("/(.*?)(".preg_quote($patt,'/').")(.*)/u", $writehtml_e, $m)) {
				$writehtml_e = $m[1];
				array_splice($writehtml_a, $writehtml_i+1, 0, array('span style="font-family: '.$font.'"', $m[2], '/span', $m[3]));
				$this->subPos = $writehtml_i+3;
				return 4;
			}
		}
	}

	unset($cw); 
	return 0;
}


function setHiEntitySubstitutions() {
	$entarr = array (
  'nbsp' => '160',  'iexcl' => '161',  'cent' => '162',  'pound' => '163',  'curren' => '164',  'yen' => '165',  'brvbar' => '166',  'sect' => '167',
  'uml' => '168',  'copy' => '169',  'ordf' => '170',  'laquo' => '171',  'not' => '172',  'shy' => '173',  'reg' => '174',  'macr' => '175',
  'deg' => '176',  'plusmn' => '177',  'sup2' => '178',  'sup3' => '179',  'acute' => '180',  'micro' => '181',  'para' => '182',  'middot' => '183',
  'cedil' => '184',  'sup1' => '185',  'ordm' => '186',  'raquo' => '187',  'frac14' => '188',  'frac12' => '189',  'frac34' => '190',
  'iquest' => '191',  'Agrave' => '192',  'Aacute' => '193',  'Acirc' => '194',  'Atilde' => '195',  'Auml' => '196',  'Aring' => '197',
  'AElig' => '198',  'Ccedil' => '199',  'Egrave' => '200',  'Eacute' => '201',  'Ecirc' => '202',  'Euml' => '203',  'Igrave' => '204',
  'Iacute' => '205',  'Icirc' => '206',  'Iuml' => '207',  'ETH' => '208',  'Ntilde' => '209',  'Ograve' => '210',  'Oacute' => '211',
  'Ocirc' => '212',  'Otilde' => '213',  'Ouml' => '214',  'times' => '215',  'Oslash' => '216',  'Ugrave' => '217',  'Uacute' => '218',
  'Ucirc' => '219',  'Uuml' => '220',  'Yacute' => '221',  'THORN' => '222',  'szlig' => '223',  'agrave' => '224',  'aacute' => '225',
  'acirc' => '226',  'atilde' => '227',  'auml' => '228',  'aring' => '229',  'aelig' => '230',  'ccedil' => '231',  'egrave' => '232',
  'eacute' => '233',  'ecirc' => '234',  'euml' => '235',  'igrave' => '236',  'iacute' => '237',  'icirc' => '238',  'iuml' => '239',
  'eth' => '240',  'ntilde' => '241',  'ograve' => '242',  'oacute' => '243',  'ocirc' => '244',  'otilde' => '245',  'ouml' => '246',
  'divide' => '247',  'oslash' => '248',  'ugrave' => '249',  'uacute' => '250',  'ucirc' => '251',  'uuml' => '252',  'yacute' => '253',
  'thorn' => '254',  'yuml' => '255',  'OElig' => '338',  'oelig' => '339',  'Scaron' => '352',  'scaron' => '353',  'Yuml' => '376',
  'fnof' => '402',  'circ' => '710',  'tilde' => '732',  'Alpha' => '913',  'Beta' => '914',  'Gamma' => '915',  'Delta' => '916',
  'Epsilon' => '917',  'Zeta' => '918',  'Eta' => '919',  'Theta' => '920',  'Iota' => '921',  'Kappa' => '922',  'Lambda' => '923',
  'Mu' => '924',  'Nu' => '925',  'Xi' => '926',  'Omicron' => '927',  'Pi' => '928',  'Rho' => '929',  'Sigma' => '931',  'Tau' => '932',
  'Upsilon' => '933',  'Phi' => '934',  'Chi' => '935',  'Psi' => '936',  'Omega' => '937',  'alpha' => '945',  'beta' => '946',  'gamma' => '947',
  'delta' => '948',  'epsilon' => '949',  'zeta' => '950',  'eta' => '951',  'theta' => '952',  'iota' => '953',  'kappa' => '954',
  'lambda' => '955',  'mu' => '956',  'nu' => '957',  'xi' => '958',  'omicron' => '959',  'pi' => '960',  'rho' => '961',  'sigmaf' => '962',
  'sigma' => '963',  'tau' => '964',  'upsilon' => '965',  'phi' => '966',  'chi' => '967',  'psi' => '968',  'omega' => '969',
  'thetasym' => '977',  'upsih' => '978',  'piv' => '982',  'ensp' => '8194',  'emsp' => '8195',  'thinsp' => '8201',  'zwnj' => '8204',
  'zwj' => '8205',  'lrm' => '8206',  'rlm' => '8207',  'ndash' => '8211',  'mdash' => '8212',  'lsquo' => '8216',  'rsquo' => '8217',
  'sbquo' => '8218',  'ldquo' => '8220',  'rdquo' => '8221',  'bdquo' => '8222',  'dagger' => '8224',  'Dagger' => '8225',  'bull' => '8226',
  'hellip' => '8230',  'permil' => '8240',  'prime' => '8242',  'Prime' => '8243',  'lsaquo' => '8249',  'rsaquo' => '8250',  'oline' => '8254',
  'frasl' => '8260',  'euro' => '8364',  'image' => '8465',  'weierp' => '8472',  'real' => '8476',  'trade' => '8482',  'alefsym' => '8501',
  'larr' => '8592',  'uarr' => '8593',  'rarr' => '8594',  'darr' => '8595',  'harr' => '8596',  'crarr' => '8629',  'lArr' => '8656',
  'uArr' => '8657',  'rArr' => '8658',  'dArr' => '8659',  'hArr' => '8660',  'forall' => '8704',  'part' => '8706',  'exist' => '8707',
  'empty' => '8709',  'nabla' => '8711',  'isin' => '8712',  'notin' => '8713',  'ni' => '8715',  'prod' => '8719',  'sum' => '8721',
  'minus' => '8722',  'lowast' => '8727',  'radic' => '8730',  'prop' => '8733',  'infin' => '8734',  'ang' => '8736',  'and' => '8743',
  'or' => '8744',  'cap' => '8745',  'cup' => '8746',  'int' => '8747',  'there4' => '8756',  'sim' => '8764',  'cong' => '8773',
  'asymp' => '8776',  'ne' => '8800',  'equiv' => '8801',  'le' => '8804',  'ge' => '8805',  'sub' => '8834',  'sup' => '8835',  'nsub' => '8836',
  'sube' => '8838',  'supe' => '8839',  'oplus' => '8853',  'otimes' => '8855',  'perp' => '8869',  'sdot' => '8901',  'lceil' => '8968',
  'rceil' => '8969',  'lfloor' => '8970',  'rfloor' => '8971',  'lang' => '9001',  'rang' => '9002',  'loz' => '9674',  'spades' => '9824',
  'clubs' => '9827',  'hearts' => '9829',  'diams' => '9830',
 );
	foreach($entarr AS $key => $val) {
		$this->entsearch[] = '&'.$key.';';
		$this->entsubstitute[] = code2utf($val);
	}
}

function SubstituteHiEntities($html) {
	// converts html_entities > ASCII 127 to unicode
	// Leaves in particular &lt; to distinguish from tag marker
	if (count($this->entsearch)) {
		$html = str_replace($this->entsearch,$this->entsubstitute,$html);
	}
	return $html;
}


// Edited v1.2 Pass by reference; option to continue if invalid UTF-8 chars
function is_utf8(&$string) {
	if ($string === mb_convert_encoding(mb_convert_encoding($string, "UTF-32", "UTF-8"), "UTF-8", "UTF-32")) {
		return true;
	} 
	else {
	  if ($this->ignore_invalid_utf8) {
		$string = mb_convert_encoding(mb_convert_encoding($string, "UTF-32", "UTF-8"), "UTF-8", "UTF-32") ;
		return true;
	  }
	  else {
		return false;
	  }
	}
} 


function purify_utf8($html,$lo=true) {
	// For HTML
	// Checks string is valid UTF-8 encoded
	// converts html_entities > ASCII 127 to UTF-8
	// Only exception - leaves low ASCII entities e.g. &lt; &amp; etc.
	// Leaves in particular &lt; to distinguish from tag marker
	if (!$this->is_utf8($html)) { 
		echo "<p><b>HTML contains invalid UTF-8 character(s)</b></p>"; 
		while (mb_convert_encoding(mb_convert_encoding($html, "UTF-32", "UTF-8"), "UTF-8", "UTF-32") != $html) {
			$a = iconv('UTF-8', 'UTF-8', $html);
			echo ($a);
			$pos = $start = strlen($a);
			$err = '';
			while ( ord(substr($html,$pos,1)) > 128 ) {
				$err .= '[[#'.ord(substr($html,$pos,1)).']]';
				$pos++;
			}
			echo '<span style="color:red; font-weight:bold">'.$err.'</span>';
			$html = substr($html, $pos);
		}
		echo $html;
		$this->Error(""); 
	}
	$html = preg_replace("/\r/", "", $html );

	// converts html_entities > ASCII 127 to UTF-8 
	// Leaves in particular &lt; to distinguish from tag marker
	$html = $this->SubstituteHiEntities($html);

	// converts all &#nnn; or &#xHHH; to UTF-8 multibyte
	// If $lo==true then includes ASCII < 128
	$html = strcode2utf($html,$lo);
	return ($html);
}

function purify_utf8_text($txt) {
	// For TEXT
	// Make sure UTF-8 string of characters
	if (!$this->is_utf8($txt)) { $this->Error("Text contains invalid UTF-8 character(s)"); }

	$txt = preg_replace("/\r/", "", $txt );

	return ($txt);
}
function all_entities_to_utf8($txt) {
	// converts txt_entities > ASCII 127 to UTF-8 
	// Leaves in particular &lt; to distinguish from tag marker
	$txt = $this->SubstituteHiEntities($txt);

	// converts all &#nnn; or &#xHHH; to UTF-8 multibyte
	$txt = strcode2utf($txt);

	$txt = $this->lesser_entity_decode($txt);
	return ($txt);
}


// ====================================================
/*-- BARCODES --*/
// UPC/EAN barcode
// EAN13, EAN8, UPCA, UPCE, ISBN, ISSN
// Accepts 12 or 13 digits with or without - hyphens
function WriteBarcode($code, $showtext=1, $x='', $y='', $size=1, $border=0, $paddingL=1, $paddingR=1, $paddingT=2, $paddingB=2, $height=1, $bgcol=false, $col=false, $btype='ISBN', $supplement='0', $supplement_code='', $k=1) {
			if (empty($code)) {
				return;
			}
			$codestr = $code;
			$code = preg_replace('/\-/','',$code);

			if (!class_exists('PDFBarcode', false)) { 
				include(_MPDF_PATH.'classes/barcode.php'); 
			}
			$this->barcode = new PDFBarcode();
			if ($btype == 'ISSN' || $btype == 'ISBN') {
				$arrcode = $this->barcode->getBarcodeArray($code, 'EAN13');
			}
			else { $arrcode = $this->barcode->getBarcodeArray($code, $btype); }

			if ($arrcode === false) { $this->Error('Error in barcode string: '.$codestr); }
			if((($btype=='EAN13' || $btype=='ISBN' || $btype=='ISSN') && strlen($code) == 12) || ($btype=='UPCA' && strlen($code) == 11)
				|| ($btype=='UPCE' && strlen($code) == 11) || ($btype=='EAN8' && strlen($code) == 7)) {
				$code .= $arrcode['checkdigit'];
				if (stristr($codestr,'-')) { $codestr .= '-' . $arrcode['checkdigit']; }
				else { $codestr .= $arrcode['checkdigit']; }
			}
			if ($btype == 'ISBN') { $codestr = 'ISBN '.$codestr; }
			if ($btype == 'ISSN') { $codestr = 'ISSN '.$codestr; }

			if (empty($x)) {
				$x = $this->x;
			}
			if (empty($y)) {
				$y = $this->y;
			}
			// set foreground color
			$prevDrawColor = $this->DrawColor;
			$prevTextColor = $this->TextColor;
			$prevFillColor = $this->FillColor;
			$lw = $this->LineWidth;
			$this->SetLineWidth(0.01);

			$size /= $k;	// in case resized in a table

			$xres = $arrcode['nom-X'] * $size;
			$llm = $arrcode['lightmL'] * $arrcode['nom-X'] * $size;	// Left Light margin
			$rlm = $arrcode['lightmR'] * $arrcode['nom-X'] * $size;	// Right Light margin

			$bcw = ($arrcode["maxw"] * $xres);	// Barcode width = Should always be 31.35mm * $size

			$fbw = $bcw + $llm + $rlm;	// Full barcode width incl. light margins
			$ow = $fbw + $paddingL + $paddingR;	// Full overall width incl. user-defined padding

			$fbwi = $fbw - 2;	// Full barcode width incl. light margins - 2mm - for isbn string

			// cf. http://www.gs1uk.org/downloads/bar_code/Bar coding getting it right.pdf
			$num_height = 3 * $size;					// Height of numerals
			$fbh = $arrcode['nom-H'] * $size * $height;		// Full barcode height incl. numerals
			$bch = $fbh - (1.5 * $size);					// Barcode height of bars	 (3mm for numerals)

			if (($btype=='EAN13' && $showtext) || $btype == 'ISSN' || $btype == 'ISBN') { // Add height for ISBN string + margin from top of bars
				$tisbnm = 1.5 * $size;	// Top margin between isbn (if shown) & bars
				$codestr_fontsize = 2.1 * $size;
				$paddingT += $codestr_fontsize + $tisbnm  ; 
			}
			$oh = $fbh + $paddingT + $paddingB;		// Full overall height incl. user-defined padding

			// PRINT border background color
			$xpos = $x;
			$ypos = $y;
			if ($col) {
				$this->SetDColor($col);
				$this->SetTColor($col);	
			}
			else {
				$this->SetDColor($this->ConvertColor(0));
				$this->SetTColor($this->ConvertColor(0));
			}
			if ($bgcol) {
				$this->SetFColor($bgcol);
			}
			else { $this->SetFColor($this->ConvertColor(255)); }
			if (!$bgcol && !$col) {	// fn. called directly - not via HTML
				if ($border) { $fillb = 'DF'; } else { $fillb = 'F'; }
				$this->Rect($xpos, $ypos, $ow, $oh, $fillb);
			}


			// PRINT BARS
			$xpos = $x + $paddingL + $llm ;
			$ypos = $y + $paddingT;
			if ($col) { $this->SetFColor($col); }
			else { $this->SetFColor($this->ConvertColor(0)); }
			if ($arrcode !== false) {
				foreach ($arrcode["bcode"] AS $v) {
					$bw = ($v["w"] * $xres);
					if ($v["t"]) {
						// draw a vertical bar
						$this->Rect($xpos, $ypos, $bw, $bch, 'F');
					}
					$xpos += $bw;
				}
			}


			// print text
			$prevFontFamily = $this->FontFamily;
			$prevFontStyle = $this->FontStyle;
			$prevFontSizePt = $this->FontSizePt;

			// ISBN string
			if (($btype=='EAN13' && $showtext) || $btype=='ISBN' || $btype=='ISSN') {
			   if ($this->onlyCoreFonts) {
				$this->SetFont('chelvetica');
			   }
			   else {
			   	$this->SetFont('sans');
			   }
			   
			   if ($bgcol) { $this->SetFColor($bgcol); }
			   else { $this->SetFColor($this->ConvertColor(255)); }
			   $this->x = $x + $paddingL + 1;	// 1mm left margin (cf. $fbwi above)
			   // max width is $fbwi 
			   $loop = 0;
			   while ( $loop == 0 ) {
				$this->SetFontSize($codestr_fontsize*1.4*_MPDFK, false);	// don't write
				$sz = $this->GetStringWidth( $codestr );
				if ($sz > $fbwi)
					$codestr_fontsize -= 0.1;
				else
					$loop ++;
			   }
			   $this->SetFont('','',$codestr_fontsize*1.4*_MPDFK, true, true);	// * 1.4 because font height is only 7/10 of given mm
 			   // WORD SPACING
			   if ($fbwi > $sz) {
				$xtra =  $fbwi - $sz;
				$charspacing = $xtra / (strlen($codestr)-1);
				if ($charspacing) { $this->_out(sprintf('BT %.3F Tc ET',$charspacing*_MPDFK)); }
			   }
			   $this->y = $y + $paddingT - ($codestr_fontsize ) - $tisbnm ; 
			   $this->Cell($fbw , $codestr_fontsize, $codestr);
			   if ($charspacing) { $this->_out('BT 0 Tc ET'); }
			}


			// Bottom NUMERALS
			// mPDF 5.7.4
			if ($this->onlyCoreFonts) {
				$this->SetFont('ccourier'); 
				$fh = 1.3; 
			}
			else {
				$this->SetFont('ocrb');
				$fh = 1.06; 
			}
			$charRO = '';
			if ($btype=='EAN13' || $btype=='ISBN' || $btype=='ISSN') {
				$outerfontsize = 3;	// Inner fontsize = 3
				$outerp = $xres * 4;
				$innerp = $xres * 2.5;
				$textw = ($bcw*0.5) - $outerp - $innerp;
				$chars = 6; // number of numerals in each half
				$charLO = substr($code,0,1); // Left Outer
				$charLI = substr($code,1,6); // Left Inner
				$charRI = substr($code,7,6); // Right Inner
				if (!$supplement) $charRO = '>'; // Right Outer
			}
			else if ($btype=='UPCA') {
				$outerfontsize = 2.3;	// Inner fontsize = 3
				$outerp = $xres * 10;
				$innerp = $xres * 2.5;
				$textw = ($bcw*0.5) - $outerp - $innerp;
				$chars = 5; 
				$charLO = substr($code,0,1); // Left Outer
				$charLI = substr($code,1,5); // Left Inner
				$charRI = substr($code,6,5); // Right Inner
				$charRO = substr($code,11,1); // Right Outer
			}
			else if ($btype=='UPCE') {
				$outerfontsize = 2.3;	// Inner fontsize = 3
				$outerp = $xres * 4;
				$innerp = 0;
				$textw = ($bcw*0.5) - $outerp - $innerp;
				$chars = 3; 
				$upce_code = $arrcode['code'];
				$charLO = substr($code,0,1); // Left Outer
				$charLI = substr($upce_code,0,3); // Left Inner
				$charRI = substr($upce_code,3,3); // Right Inner
				$charRO = substr($code,11,1); // Right Outer
			}
			else if ($btype=='EAN8') {
				$outerfontsize = 3;	// Inner fontsize = 3
				$outerp = $xres * 4;
				$innerp = $xres * 2.5;
				$textw = ($bcw*0.5) - $outerp - $innerp;
				$chars = 4; 
				$charLO = '<'; // Left Outer
				$charLI = substr($code,0,4); // Left Inner
				$charRI = substr($code,4,4); // Right Inner
				if (!$supplement) $charRO = '>'; // Right Outer
			}

			$this->SetFontSize(($outerfontsize/3)*3*$fh*$size*_MPDFK);	// 3mm numerals (FontSize is larger to account for space above/below characters)

			if (!$this->usingCoreFont) { $cw = $this->_getCharWidth($this->CurrentFont['cw'],32)*3*$fh*$size/1000; }	// character width at 3mm
			else { $cw = 600*3*$fh*$size/1000; }	// mPDF 5.7.4

			// Outer left character
			$y_text = $y + $paddingT + $bch - ($num_height/2); 
			$y_text_outer = $y + $paddingT + $bch - ($num_height*($outerfontsize/3)/2); 

			$this->x = $x + $paddingL - ($cw*($outerfontsize/3)*0.1); // 0.1 is correction as char does not fill full width;
			$this->y = $y_text_outer; 
			$this->Cell($cw, $num_height, $charLO );

 			// WORD SPACING for inner chars
			$xtra =  $textw - ($cw*$chars);
			$charspacing = $xtra / ($chars-1);
			if ($charspacing) { $this->_out(sprintf('BT %.3F Tc ET',$charspacing*_MPDFK)); }

			if ($bgcol) { $this->SetFColor($bgcol); }	
			else { $this->SetFColor($this->ConvertColor(255)); }

			$this->SetFontSize(3*$fh*$size*_MPDFK);	// 3mm numerals (FontSize is larger to account for space above/below characters)

			// Inner left half characters
			$this->x = $x + $paddingL + $llm + $outerp;
			$this->y = $y_text; 
			$this->Cell($textw, $num_height, $charLI , 0, 0, '', 1);

			// Inner right half characters
			$this->x = $x + $paddingL + $llm + ($bcw*0.5) + $innerp;
			$this->y = $y_text; 
			$this->Cell($textw, $num_height, $charRI , 0, 0, '', 1);

			if ($charspacing) { $this->_out('BT 0 Tc ET'); }

			// Outer Right character
			$this->SetFontSize(($outerfontsize/3)*3*$fh*$size*_MPDFK);	// 3mm numerals (FontSize is larger to account for space above/below characters)

			$this->x = $x + $paddingL + $llm + $bcw + $rlm - ($cw*($outerfontsize/3)*0.9); // 0.9 is correction as char does not fill full width
			$this->y = $y_text_outer; 
			$this->Cell($cw*($outerfontsize/3), $num_height, $charRO , 0, 0, 'R');

			if ($supplement) { // EAN-2 or -5 Supplement
				// PRINT BARS
				$supparrcode = $this->barcode->getBarcodeArray($supplement_code, 'EAN'.$supplement);
				if ($supparrcode === false) { $this->Error('Error in barcode string (supplement): '.$codestr.' '.$supplement_code); }
				if(strlen($supplement_code) != $supplement) {
					$this->Error('Barcode supplement incorrect: '.$supplement_code);
				}
				$llm = $fbw - (($arrcode['lightmR'] - $supparrcode['sepM'])  * $arrcode['nom-X'] * $size);	// Left Light margin
				$rlm = $arrcode['lightmR'] * $arrcode['nom-X'] * $size;	// Right Light margin

				$bcw = ($supparrcode["maxw"] * $xres);	// Barcode width = Should always be 31.35mm * $size

				$fbw = $bcw + $llm + $rlm;	// Full barcode width incl. light margins
				$ow = $fbw + $paddingL + $paddingR;	// Full overall width incl. user-defined padding
				$bch = $fbh - (1.5 * $size) - ($num_height + 0.5);		// Barcode height of bars	 (3mm for numerals)

				$xpos = $x + $paddingL + $llm ;
				$ypos = $y + $paddingT + $num_height + 0.5;
				if ($col) { $this->SetFColor($col); }
				else { $this->SetFColor($this->ConvertColor(0)); }
				if ($supparrcode !== false) {
					foreach ($supparrcode["bcode"] AS $v) {
						$bw = ($v["w"] * $xres);
						if ($v["t"]) {
							// draw a vertical bar
							$this->Rect($xpos, $ypos, $bw, $bch, 'F');
						}
						$xpos += $bw;
					}
				}

				// Characters
				if ($bgcol) { $this->SetFColor($bgcol); }
				else { $this->SetFColor($this->ConvertColor(255)); }
				$this->SetFontSize(3*$fh*$size*_MPDFK);	// 3mm numerals (FontSize is larger to account for space above/below characters)
				$this->x = $x + $paddingL + $llm;
				$this->y = $y + $paddingT; 
				$this->Cell($bcw, $num_height, $supplement_code, 0, 0, 'C');

				// Outer Right character (light margin)
				$this->SetFontSize(($outerfontsize/3)*3*$fh*$size*_MPDFK);	// 3mm numerals (FontSize is larger to account for space above/below characters)
				$this->x = $x + $paddingL + $llm + $bcw + $rlm - ($cw*0.9); // 0.9 is correction as char does not fill full width
				$this->y = $y + $paddingT; 
				$this->Cell($cw*($outerfontsize/3), $num_height, '>', 0, 0, 'R');
			}



			// Restore **************
			$this->SetFont($prevFontFamily, $prevFontStyle, $prevFontSizePt);
			$this->DrawColor = $prevDrawColor;
			$this->TextColor = $prevTextColor;
			$this->FillColor = $prevFillColor;
			$this->SetLineWidth($lw);
			$this->SetY($y);
}



// ====================================================
// POSTAL and OTHER barcodes
function WriteBarcode2($code, $x='', $y='', $size=1, $height=1, $bgcol=false, $col=false, $btype='IMB', $print_ratio='', $k=1) {
			if (empty($code)) { return; }
			if (!class_exists('PDFBarcode', false)) { 
				include(_MPDF_PATH.'classes/barcode.php'); 
			}
			$this->barcode = new PDFBarcode();
			$arrcode = $this->barcode->getBarcodeArray($code, $btype, $print_ratio); 

			if ($arrcode === false) { $this->Error('Error in barcode string: '.$code); }
			if (empty($x)) { $x = $this->x; }
			if (empty($y)) { $y = $this->y; }
			$prevDrawColor = $this->DrawColor;
			$prevTextColor = $this->TextColor;
			$prevFillColor = $this->FillColor;
			$lw = $this->LineWidth;
			$this->SetLineWidth(0.01);
			$size /= $k;	// in case resized in a table
			$xres = $arrcode['nom-X'] * $size;

			if ($btype == 'IMB' || $btype == 'RM4SCC' || $btype == 'KIX' || $btype == 'POSTNET' || $btype == 'PLANET') {
				$llm = $arrcode['quietL'] / $k;	// Left Quiet margin
				$rlm = $arrcode['quietR'] / $k;	// Right Quiet margin
				$tlm = $blm = $arrcode['quietTB'] / $k;
				$height=1;		// Overrides
			}
			else if (in_array($btype, array('C128A','C128B','C128C','EAN128A','EAN128B','EAN128C','C39','C39+','C39E','C39E+','S25','S25+','I25','I25+','I25B','I25B+','C93','MSI','MSI+','CODABAR','CODE11'))) {
				$llm = $arrcode['lightmL'] * $xres;	// Left Quiet margin
				$rlm = $arrcode['lightmR'] * $xres;	// Right Quiet margin
				$tlm = $blm = $arrcode['lightTB'] * $xres * $height;
			}


			$bcw = ($arrcode["maxw"] * $xres);
			$fbw = $bcw + $llm + $rlm;		// Full barcode width incl. light margins

			$bch = ($arrcode["nom-H"] * $size * $height);
			$fbh = $bch + $tlm + $blm;		// Full barcode height

			// PRINT border background color
			$xpos = $x;
			$ypos = $y;
			if ($col) {
				$this->SetDColor($col);	
				$this->SetTColor($col);	
			}
			else {
				$this->SetDColor($this->ConvertColor(0));	
				$this->SetTColor($this->ConvertColor(0));	
			}
			if ($bgcol) {
				$this->SetFColor($bgcol);
			}
			else { $this->SetFColor($this->ConvertColor(255)); }	

			// PRINT BARS
			if ($col) { $this->SetFColor($col); }
			else { $this->SetFColor($this->ConvertColor(0)); }
			$xpos = $x + $llm ;

			if ($arrcode !== false) {
				foreach ($arrcode["bcode"] AS $v) {
					$bw = ($v["w"] * $xres);
					if ($v["t"]) {
						$ypos = $y + $tlm + ($bch * $v['p'] / $arrcode['maxh']);
						$this->Rect($xpos, $ypos, $bw, ($v['h'] * $bch / $arrcode['maxh']), 'F');
					}
					$xpos += $bw;
				}
			}

			// PRINT BEARER BARS
			if ($btype == 'I25B' || $btype == 'I25B+') {
				$this->Rect($x, $y, $fbw, ($arrcode['lightTB'] * $xres * $height), 'F');
				$this->Rect($x, $y+$tlm+$bch, $fbw, ($arrcode['lightTB'] * $xres * $height), 'F');
			} 

			// Restore **************
			$this->DrawColor = $prevDrawColor;
			$this->TextColor = $prevTextColor;
			$this->FillColor = $prevFillColor;
			$this->SetLineWidth($lw);
			$this->SetY($y);
}

/*-- END BARCODES --*/

// ====================================================
// ====================================================

function StartTransform($returnstring=false) {
	  if ($returnstring) { return('q'); }
	  else { $this->_out('q'); }
}
function StopTransform($returnstring=false) {
	  if ($returnstring) { return('Q'); }
	  else { $this->_out('Q'); }
}
function transformScale($s_x, $s_y, $x='', $y='', $returnstring=false) {
	if ($x === '') {
		$x=$this->x;
	}
	if ($y === '') {
		$y=$this->y;
	}
	if (($s_x == 0) OR ($s_y == 0)) {
		$this->Error('Please do not use values equal to zero for scaling');
	}
	$y = ($this->h - $y) * _MPDFK;
	$x *= _MPDFK;
	//calculate elements of transformation matrix
	$s_x /= 100;
	$s_y /= 100;
	$tm = array();
	$tm[0] = $s_x;
	$tm[1] = 0;
	$tm[2] = 0;
	$tm[3] = $s_y;
	$tm[4] = $x * (1 - $s_x);
	$tm[5] = $y * (1 - $s_y);
	//scale the coordinate system
	if ($returnstring) { return($this->_transform($tm, true)); }
	else { $this->_transform($tm); }
}
function transformTranslate($t_x, $t_y, $returnstring=false) {
	//calculate elements of transformation matrix
	$tm = array();
	$tm[0] = 1;
	$tm[1] = 0;
	$tm[2] = 0;
	$tm[3] = 1;
	$tm[4] = $t_x * _MPDFK;
	$tm[5] = -$t_y * _MPDFK;
	//translate the coordinate system
	if ($returnstring) { return($this->_transform($tm, true)); }
	else { $this->_transform($tm); }
}
function transformRotate($angle, $x='', $y='', $returnstring=false) {
	if ($x === '') {
		$x=$this->x;
	}
	if ($y === '') {
		$y=$this->y;
	}
	$angle = -$angle;
	$y = ($this->h - $y) * _MPDFK;
	$x *= _MPDFK;
	//calculate elements of transformation matrix
	$tm = array();
	$tm[0] = cos(deg2rad($angle));
	$tm[1] = sin(deg2rad($angle));
	$tm[2] = -$tm[1];
	$tm[3] = $tm[0];
	$tm[4] = $x + $tm[1] * $y - $tm[0] * $x;
	$tm[5] = $y - $tm[0] * $y - $tm[1] * $x;
	//rotate the coordinate system around ($x,$y)
	if ($returnstring) { return($this->_transform($tm, true)); }
	else { $this->_transform($tm); }
}
// mPDF 5.7.3 TRANSFORMS
function transformSkew($angle_x, $angle_y, $x='', $y='', $returnstring=false) {
	if ($x === '') {
		$x = $this->x;
	}
	if ($y === '') {
		$y = $this->y;
	}
	$angle_x = -$angle_x;
	$angle_y = -$angle_y;
	$x *= _MPDFK;
	$y = ($this->h - $y) * _MPDFK;
	//calculate elements of transformation matrix
	$tm = array();
	$tm[0] = 1;
	$tm[1] = tan(deg2rad($angle_y));
	$tm[2] = tan(deg2rad($angle_x));
	$tm[3] = 1;
	$tm[4] = -$tm[2] * $y;
	$tm[5] = -$tm[1] * $x;
	//skew the coordinate system
	if ($returnstring) { return($this->_transform($tm, true)); }
	else { $this->_transform($tm); }
}

function _transform($tm, $returnstring=false) {
	if ($returnstring) { return(sprintf('%.4F %.4F %.4F %.4F %.4F %.4F cm', $tm[0], $tm[1], $tm[2], $tm[3], $tm[4], $tm[5])); }
	else { $this->_out(sprintf('%.4F %.4F %.4F %.4F %.4F %.4F cm', $tm[0], $tm[1], $tm[2], $tm[3], $tm[4], $tm[5])); }
}




// AUTOFONT =========================
function markScriptToLang($html) {
	if ($this->onlyCoreFonts) { return $html; }

	// sets $this->script2lang
	if (empty($this->script2lang)) {
		include(_MPDF_PATH.'config_script2lang.php');
	}

	$n = '';
	$a=preg_split('/<(.*?)>/ms',$html,-1,PREG_SPLIT_DELIM_CAPTURE);
	foreach($a as $i => $e) {
	   if($i%2==0) {
		//ignore if in Textarea
		if ($i > 0 && strtolower(substr($a[$i-1],1,8)) == 'textarea') { $a[$i] = $e; continue; }
		$e = strcode2utf($e);
		$e = $this->lesser_entity_decode($e);

		$earr = $this->UTF8StringToArray($e, false);

		$scriptblock = 0;
		$scriptblocks = array();
		$scriptblocks[0] = 0;
		$chardata = array();
		$subchunk = 0;
		$charctr = 0;
		foreach($earr as $char) {
			$ucd_record = UCDN::get_ucd_record($char);
			$sbl = $ucd_record[6];

			if ($sbl && $sbl != 40 && $sbl != 102) {
				if ($scriptblock == 0) { $scriptblock = $sbl; $scriptblocks[$subchunk] = $scriptblock; }
				else if ($scriptblock > 0 && $scriptblock != $sbl) {
					// NEW (non-common) Script encountered in this chunk.
					// Start a new subchunk
					$subchunk++;
					$scriptblock = $sbl;
					$charctr = 0;
					$scriptblocks[$subchunk] = $scriptblock;
				}
			}

			$chardata[$subchunk][$charctr]['script'] = $sbl;
			$chardata[$subchunk][$charctr]['uni'] =  $char;
			$charctr++;
		}

		// If scriptblock[x] = common & non-baseScript
		// and scriptblock[x+1] = baseScript
		// Move common script from end of x to start of x+1
		for($sch=0;$sch<$subchunk;$sch++) {
			if ($scriptblocks[$sch] > 0 && $scriptblocks[$sch] != $this->baseScript && $scriptblocks[$sch+1] == $this->baseScript) {
				$end = count($chardata[$sch])-1;
				while($chardata[$sch][$end]['script'] == 0 && $end > 1) {	// common script
					$tmp = array_pop($chardata[$sch]);
					array_unshift($chardata[$sch+1],$tmp);
					$end--;
				}
			}
		}

		$o = '';
		for($sch=0;$sch<=$subchunk;$sch++) {
		   if (isset($chardata[$sch])) { 
			$s = '';
			for ($j=0;$j<count($chardata[$sch]);$j++) {
				$s.=code2utf($chardata[$sch][$j]['uni']);
			}
			// ZZZ99 Undo lesser_entity_decode as above - but only for <>&
 			$s = str_replace("&","&amp;",$s);
 			$s = str_replace("<","&lt;",$s);
 			$s = str_replace(">","&gt;",$s);

			// Check Vietnamese if Latin script - even if Basescript
			if ($scriptblocks[$sch] == UCDN::SCRIPT_LATIN && $this->autoVietnamese && preg_match("/([".$this->viet."])/u", $s)) {
				$o .= '<span lang="vi" class="lang_vi">'.$s.'</span>';
			}
			// Check Arabic for different languages if Arabic script - even if Basescript
			else if ($scriptblocks[$sch] == UCDN::SCRIPT_ARABIC && $this->autoArabic) {
				if (preg_match("/[".$this->sindhi ."]/u", $s) ) {
					$o .= '<span lang="sd" class="lang_sd">'.$s.'</span>';
				}
				else if (preg_match("/[".$this->urdu ."]/u", $s) ) {
					$o .= '<span lang="ur" class="lang_ur">'.$s.'</span>';
				}
				else if (preg_match("/[".$this->pashto ."]/u", $s) ) {
					$o .= '<span lang="ps" class="lang_ps">'.$s.'</span>';
				}
				else if (preg_match("/[".$this->persian ."]/u", $s) ) {
					$o .= '<span lang="fa" class="lang_fa">'.$s.'</span>';
				}
				else if ($this->baseScript != UCDN::SCRIPT_ARABIC  && isset($this->script2lang[$scriptblocks[$sch]])) {
					$o .= '<span lang="'.$this->script2lang[$scriptblocks[$sch]].'" class="lang_'.$this->script2lang[$scriptblocks[$sch]].'">'.$s.'</span>';
				}
				else {
					// Just output chars
					$o .= $s;
				}
			}
			// Identify Script block if not Basescript, and mark up as language
			else if ($scriptblocks[$sch] > 0 && $scriptblocks[$sch] != $this->baseScript && isset($this->script2lang[$scriptblocks[$sch]])) {
				// Encase in <span>
				$o .= '<span lang="'.$this->script2lang[$scriptblocks[$sch]].'" class="lang_'.$this->script2lang[$scriptblocks[$sch]].'">';
				$o .= $s;
				$o .= '</span>';
			}
			else {
				// Just output chars
				$o .= $s;
			}
		   }
		}

		$a[$i] = $o;
	   }
	   else {
		$a[$i] = '<'.$e.'>'; 
	   }
	}
	$n = implode('',$a);

	return $n;
}



//===========================
// Functions 

// Call-back function Used for usort in fn _tableWrite

function _cmpdom($a, $b) {
    return ($a["dom"] < $b["dom"]) ? -1 : 1;
}
function mb_strrev($str, $enc = 'utf-8'){
	$ch = array();
	$ch = preg_split('//u',$str);
	$revch = array_reverse($ch);
	return implode('',$revch);
}

/*-- COLUMNS --*/
// Callback function from function printcolumnbuffer in mpdf
function columnAdjustAdd($type,$k,$xadj,$yadj,$a,$b,$c=0,$d=0,$e=0,$f=0) {
   if ($type == 'Td') { 	// xpos,ypos
	$a += ($xadj * $k);
	$b -= ($yadj * $k);
	return 'BT '.sprintf('%.3F %.3F',$a,$b).' Td'; 
   }
   else if ($type == 're') { 	// xpos,ypos,width,height
	$a += ($xadj * $k);
	$b -= ($yadj * $k);
	return sprintf('%.3F %.3F %.3F %.3F',$a,$b,$c,$d).' re'; 
   }
   else if ($type == 'l') { 	// xpos,ypos,x2pos,y2pos
	$a += ($xadj * $k);
	$b -= ($yadj * $k);
	return sprintf('%.3F %.3F l',$a,$b); 
   }
   else if ($type == 'img') { 	// width,height,xpos,ypos
	$c += ($xadj * $k);
	$d -= ($yadj * $k);
	return sprintf('q %.3F 0 0 %.3F %.3F %.3F',$a,$b,$c,$d).' cm /'.$e;  
   }
   else if ($type == 'draw') { 	// xpos,ypos
	$a += ($xadj * $k);
	$b -= ($yadj * $k);
	return sprintf('%.3F %.3F m',$a,$b); 
   }
   else if ($type == 'bezier') { 	// xpos,ypos,x2pos,y2pos,x3pos,y3pos
	$a += ($xadj * $k);
	$b -= ($yadj * $k);
	$c += ($xadj * $k);
	$d -= ($yadj * $k);
	$e += ($xadj * $k);
	$f -= ($yadj * $k);
	return sprintf('%.3F %.3F %.3F %.3F %.3F %.3F',$a,$b,$c,$d,$e,$f).' c'; 
   }
}
/*-- END COLUMNS --*/



function ConvertColor($color="#000000"){
	$color = trim(strtolower($color));
	$c = false;
	$cstr = '';
	if ($color=='transparent') { return false; }
	else if ($color=='inherit') { return false; }
	else if (isset($this->SVGcolors[$color])) $color = $this->SVGcolors[$color];

	if (preg_match('/^[\d]+$/',$color)) { $c = (array(1,$color)); }	// i.e. integer only
	else if ($color[0] == '#') { //case of #nnnnnn or #nnn
		$cor = preg_replace('/\s+.*/','',$color);	// in case of Background: #CCC url() x-repeat etc.
  		if (strlen($cor) == 4) { // Turn #RGB into #RRGGBB
		 	  $cor = "#" . $cor[1] . $cor[1] . $cor[2] . $cor[2] . $cor[3] . $cor[3];
		}  
		$r = hexdec(substr($cor, 1, 2));
		$g = hexdec(substr($cor, 3, 2));
		$b = hexdec(substr($cor, 5, 2));
		$c = array(3,$r,$g,$b);
	}
	else if (preg_match('/(rgba|rgb|device-cmyka|cmyka|device-cmyk|cmyk|hsla|hsl|spot)\((.*?)\)/',$color,$m)) {
		$type= $m[1];
		$cores = explode(",", $m[2]);
		$ncores = count($cores);
		if (stristr($cores[0],'%') ) { 
			$cores[0] += 0; 
			if ($type=='rgb' || $type=='rgba') { $cores[0] = intval($cores[0]*255/100); }
		}
		if ($ncores>1 && stristr($cores[1],'%') ) { 
			$cores[1] += 0; 
			if ($type=='rgb' || $type=='rgba') { $cores[1] = intval($cores[1]*255/100); }
			if ($type=='hsl' || $type=='hsla') { $cores[1] = $cores[1]/100; }
		}
		if ($ncores>2 && stristr($cores[2],'%') ) { 
			$cores[2] += 0; 
			if ($type=='rgb' || $type=='rgba') { $cores[2] = intval($cores[2]*255/100); }
			if ($type=='hsl' || $type=='hsla') { $cores[2] = $cores[2]/100; }
		}
		if ($ncores>3 && stristr($cores[3],'%') ) { 
			$cores[3] += 0; 
		}

		if ($type=='rgb') { $c = array(3,$cores[0],$cores[1],$cores[2]); }
		else if ($type=='rgba') { $c = array(5,$cores[0],$cores[1],$cores[2],$cores[3]*100); }
		else if ($type=='cmyk' || $type=='device-cmyk') { $c = array(4,$cores[0],$cores[1],$cores[2],$cores[3]); }
		else if ($type=='cmyka' || $type=='device-cmyka') { $c = array(6,$cores[0],$cores[1],$cores[2],$cores[3],$cores[4]*100); }
		else if ($type=='hsl' || $type=='hsla') { 
			$conv = $this->hsl2rgb($cores[0]/360,$cores[1],$cores[2]);
			if ($type=='hsl') { $c = array(3,$conv[0],$conv[1],$conv[2]); }
			else if ($type=='hsla') { $c = array(5,$conv[0],$conv[1],$conv[2],$cores[3]*100); }
		}
		else if ($type=='spot') { 
			$name = strtoupper(trim($cores[0]));
			if(!isset($this->spotColors[$name])) {
				if (isset($cores[5])) { $this->AddSpotColor($cores[0],$cores[2],$cores[3],$cores[4],$cores[5]); }
				else { $this->Error('Undefined spot color: '.$name); }
			}
			$c = array(2,$this->spotColors[$name]['i'],$cores[1]); 
		}
	}


	// $this->restrictColorSpace
	// 1 - allow GRAYSCALE only [convert CMYK/RGB->gray]
	// 2 - allow RGB / SPOT COLOR / Grayscale [convert CMYK->RGB]
	// 3 - allow CMYK / SPOT COLOR / Grayscale [convert RGB->CMYK]
	if ($this->PDFA || $this->PDFX || $this->restrictColorSpace) {
		if ($c[0]==1) {	// GRAYSCALE
		}
		else if ($c[0]==2) {	// SPOT COLOR
			if (!isset($this->spotColorIDs[$c[1]])) { die('Error: Spot colour has not been defined - '.$this->spotColorIDs[$c[1]]); }
			if ($this->PDFA) { 
				if ($this->PDFA && !$this->PDFAauto) { $this->PDFAXwarnings[] = "Spot color specified '".$this->spotColorIDs[$c[1]]."' (converted to process color)"; }
				if ($this->restrictColorSpace!=3) { 
					$sp = $this->spotColors[$this->spotColorIDs[$c[1]]]; 
					$c = $this->cmyk2rgb(array(4,$sp['c'],$sp['m'],$sp['y'],$sp['k'])); 
				}
			}
			else if ($this->restrictColorSpace==1) { 
				$sp = $this->spotColors[$this->spotColorIDs[$c[1]]]; 
				$c = $this->cmyk2gray(array(4,$sp['c'],$sp['m'],$sp['y'],$sp['k'])); 
			}
		}
		else if ($c[0]==3) {	// RGB
			if ($this->PDFX || ($this->PDFA && $this->restrictColorSpace==3)) { 
				if (($this->PDFA && !$this->PDFAauto) || ($this->PDFX && !$this->PDFXauto)) { $this->PDFAXwarnings[] = "RGB color specified '".$color."' (converted to CMYK)"; }
				$c = $this->rgb2cmyk($c); 
			}
			else if ($this->restrictColorSpace==1) { $c = $this->rgb2gray($c); }
			else if ($this->restrictColorSpace==3) { $c = $this->rgb2cmyk($c); }
		}
		else if ($c[0]==4) {	// CMYK
			if ($this->PDFA && $this->restrictColorSpace!=3) { 
				if ($this->PDFA && !$this->PDFAauto) { $this->PDFAXwarnings[] = "CMYK color specified '".$color."' (converted to RGB)"; }
				$c = $this->cmyk2rgb($c); 
			}
			else if ($this->restrictColorSpace==1) { $c = $this->cmyk2gray($c); }
			else if ($this->restrictColorSpace==2) { $c = $this->cmyk2rgb($c); }
		}
		else if ($c[0]==5) {	// RGBa
			if ($this->PDFX || ($this->PDFA && $this->restrictColorSpace==3)) { 
				if (($this->PDFA && !$this->PDFAauto) || ($this->PDFX && !$this->PDFXauto)) { $this->PDFAXwarnings[] = "RGB color with transparency specified '".$color."' (converted to CMYK without transparency)"; }
				$c = $this->rgb2cmyk($c); 
				$c = array(4, $c[1], $c[2], $c[3], $c[4]);
			}
			else if ($this->PDFA && $this->restrictColorSpace!=3) { 
				if (!$this->PDFAauto) { $this->PDFAXwarnings[] = "RGB color with transparency specified '".$color."' (converted to RGB without transparency)"; }
				$c = $this->rgb2cmyk($c); 
				$c = array(4, $c[1], $c[2], $c[3], $c[4]);
			}
			else if ($this->restrictColorSpace==1) { $c = $this->rgb2gray($c); }
			else if ($this->restrictColorSpace==3) { $c = $this->rgb2cmyk($c); }
		}
		else if ($c[0]==6) {	// CMYKa
			if ($this->PDFA && $this->restrictColorSpace!=3) { 
				if (($this->PDFA && !$this->PDFAauto) || ($this->PDFX && !$this->PDFXauto)) { $this->PDFAXwarnings[] = "CMYK color with transparency specified '".$color."' (converted to RGB without transparency)"; }
				$c = $this->cmyk2rgb($c); 
				$c = array(3, $c[1], $c[2], $c[3]);
			}
			else if ($this->PDFX || ($this->PDFA && $this->restrictColorSpace==3)) { 
				if (($this->PDFA && !$this->PDFAauto) || ($this->PDFX && !$this->PDFXauto)) { $this->PDFAXwarnings[] = "CMYK color with transparency specified '".$color."' (converted to CMYK without transparency)"; }
				$c = $this->cmyk2rgb($c); 
				$c = array(3, $c[1], $c[2], $c[3]);
			}
			else if ($this->restrictColorSpace==1) { $c = $this->cmyk2gray($c); }
			else if ($this->restrictColorSpace==2) { $c = $this->cmyk2rgb($c); }
		}
	}
	if (is_array($c)) {
		$c = array_pad($c, 6, 0);
		$cstr = pack("a1ccccc", $c[0], ($c[1] & 0xFF), ($c[2] & 0xFF), ($c[3] & 0xFF), ($c[4] & 0xFF), ($c[5] & 0xFF) ); 
	}
	return $cstr;
}

function rgb2gray($c) {
	if (isset($c[4])) { return array(1,(($c[1] * .21) + ($c[2] * .71) + ($c[3] * .07)), ord(1), $c[4]); }
	else { return array(1,(($c[1] * .21) + ($c[2] * .71) + ($c[3] * .07))); }
}

function cmyk2gray($c) {
	$rgb = $this->cmyk2rgb($c);
	return $this->rgb2gray($rgb);
}

function rgb2cmyk($c) {
	$cyan = 1 - ($c[1] / 255);
	$magenta = 1 - ($c[2] / 255);
	$yellow = 1 - ($c[3] / 255);
	$min = min($cyan, $magenta, $yellow);

	if ($min == 1) {
		if ($c[0]==5) { return array (6,100,100,100,100, $c[4]); }
		else { return array (4,100,100,100,100); }
		// For K-Black
		//if ($c[0]==5) { return array (6,0,0,0,100, $c[4]); }
		//else { return array (4,0,0,0,100); }
	}
	$K = $min;
	$black = 1 - $K;
	if ($c[0]==5) { return array (6,($cyan-$K)*100/$black, ($magenta-$K)*100/$black, ($yellow-$K)*100/$black, $K*100, $c[4]); }
	else { return array (4,($cyan-$K)*100/$black, ($magenta-$K)*100/$black, ($yellow-$K)*100/$black, $K*100); }
}


function cmyk2rgb($c) {
	$rgb = array();
	$colors = 255 - ($c[4]*2.55);
	$rgb[0] = intval($colors * (255 - ($c[1]*2.55))/255);
	$rgb[1] = intval($colors * (255 - ($c[2]*2.55))/255);
	$rgb[2] = intval($colors * (255 - ($c[3]*2.55))/255);
	if ($c[0]==6) { return array (5,$rgb[0],$rgb[1],$rgb[2], $c[5]); }
	else { return array (3,$rgb[0],$rgb[1],$rgb[2]); }
}

function rgb2hsl($var_r, $var_g, $var_b) {
    $var_min = min($var_r,$var_g,$var_b);
    $var_max = max($var_r,$var_g,$var_b);
    $del_max = $var_max - $var_min;
    $l = ($var_max + $var_min) / 2;
    if ($del_max == 0) {
            $h = 0;
            $s = 0;
    }
    else {
            if ($l < 0.5) { $s = $del_max / ($var_max + $var_min); }
            else { $s = $del_max / (2 - $var_max - $var_min); }
            $del_r = ((($var_max - $var_r) / 6) + ($del_max / 2)) / $del_max;
            $del_g = ((($var_max - $var_g) / 6) + ($del_max / 2)) / $del_max;
            $del_b = ((($var_max - $var_b) / 6) + ($del_max / 2)) / $del_max;
            if ($var_r == $var_max) { $h = $del_b - $del_g; }
            elseif ($var_g == $var_max)  { $h = (1 / 3) + $del_r - $del_b; }
            elseif ($var_b == $var_max)  { $h = (2 / 3) + $del_g - $del_r; };
            if ($h < 0) { $h += 1; }
            if ($h > 1) { $h -= 1; }
    }
    return array($h,$s,$l);
}


function hsl2rgb($h2,$s2,$l2) {
	// Input is HSL value of complementary colour, held in $h2, $s, $l as fractions of 1
	// Output is RGB in normal 255 255 255 format, held in $r, $g, $b
	// Hue is converted using function hue_2_rgb, shown at the end of this code
	if ($s2 == 0) {
		$r = $l2 * 255;
		$g = $l2 * 255;
		$b = $l2 * 255;
	}
	else {
		if ($l2 < 0.5) { $var_2 = $l2 * (1 + $s2); }
		else { $var_2 = ($l2 + $s2) - ($s2 * $l2); }
		$var_1 = 2 * $l2 - $var_2;
		$r = round(255 * $this->hue_2_rgb($var_1,$var_2,$h2 + (1 / 3)));
		$g = round(255 * $this->hue_2_rgb($var_1,$var_2,$h2));
		$b = round(255 * $this->hue_2_rgb($var_1,$var_2,$h2 - (1 / 3)));
	}
	return array($r,$g,$b);
}

function hue_2_rgb($v1,$v2,$vh) {
	// Function to convert hue to RGB, called from above
	if ($vh < 0) { $vh += 1; };
	if ($vh > 1) { $vh -= 1; };
	if ((6 * $vh) < 1) { return ($v1 + ($v2 - $v1) * 6 * $vh); };
	if ((2 * $vh) < 1) { return ($v2); };
	if ((3 * $vh) < 2) { return ($v1 + ($v2 - $v1) * ((2 / 3 - $vh) * 6)); };
	return ($v1);
}

function _invertColor($cor) {
	if ($cor[0]==3 || $cor[0]==5) {	// RGB
		return array(3, (255-$cor[1]), (255-$cor[2]), (255-$cor[3]));
	}
	else if ($cor[0]==4 || $cor[0]==6) {	// CMYK
		return array(4, (100-$cor[1]), (100-$cor[2]), (100-$cor[3]), (100-$cor[4]));
	}
	else if ($cor[0]==1) {	// Grayscale
		return array(1, (255-$cor[1]));
	}	
	// Cannot cope with non-RGB colors at present
	die('Error in _invertColor - trying to invert non-RGB color');
}

function _colAtoString($cor) {
	$s = '';
	if ($cor{0}==1) $s = 'rgb('.ord($cor{1}).','.ord($cor{1}).','.ord($cor{1}).')';
	else if ($cor{0}==2) $s = 'spot('.ord($cor{1}).','.ord($cor{2}).')';		// SPOT COLOR
	else if ($cor{0}==3) $s = 'rgb('.ord($cor{1}).','.ord($cor{2}).','.ord($cor{3}).')';
	else if ($cor{0}==4) $s = 'cmyk('.ord($cor{1}).','.ord($cor{2}).','.ord($cor{3}).','.ord($cor{4}).')';
	else if ($cor{0}==5) $s = 'rgba('.ord($cor{1}).','.ord($cor{2}).','.ord($cor{3}).','.sprintf('%0.2F',ord($cor{4})/100).')';
	else if ($cor{0}==6) $s = 'cmyka('.ord($cor{1}).','.ord($cor{2}).','.ord($cor{3}).','.ord($cor{4}).','.sprintf('%0.2F',ord($cor{5})/100).')';
	return $s;
}

function ConvertSize($size=5,$maxsize=0,$fontsize=false,$usefontsize=true){
// usefontsize - set false for e.g. margins - will ignore fontsize for % values
// Depends of maxsize value to make % work properly. Usually maxsize == pagewidth
// For text $maxsize = Fontsize
// Setting e.g. margin % will use maxsize (pagewidth) and em will use fontsize
// Returns values using 'mm' units
	$size = trim(strtolower($size));

  if ( $size == 'thin' ) $size = 1*(25.4/$this->dpi); //1 pixel width for table borders
  elseif ( stristr($size,'px') ) $size *= (25.4/$this->dpi); //pixels
  elseif ( stristr($size,'cm') ) $size *= 10; //centimeters
  elseif ( stristr($size,'mm') ) $size += 0; //millimeters
  elseif ( stristr($size,'pt') ) $size *= 25.4/72; //72 pts/inch
  elseif ( stristr($size,'rem') ) {
  	$size += 0; //make "0.83rem" become simply "0.83" 
	$size *= ($this->default_font_size / _MPDFK);
  }
  elseif ( stristr($size,'em') ) {
  	$size += 0; //make "0.83em" become simply "0.83" 
	if ($fontsize) { $size *= $fontsize; }
	else { $size *= $maxsize; }
  }
  elseif ( stristr($size,'%') ) {
  	$size += 0; //make "90%" become simply "90" 
	if ($fontsize && $usefontsize) { $size *= $fontsize/100; }
	else { $size *= $maxsize/100; }
  }
  elseif ( stristr($size,'in') ) $size *= 25.4; //inches 
  elseif ( stristr($size,'pc') ) $size *= 38.1/9; //PostScript picas 
  elseif ( stristr($size,'ex') ) {	// Approximates "ex" as half of font height
  	$size += 0; //make "3.5ex" become simply "3.5" 
	if ($fontsize) { $size *= $fontsize/2; }
	else { $size *= $maxsize/2; }
  }
  elseif ( $size == 'medium' ) $size = 3*(25.4/$this->dpi); //3 pixel width for table borders
  elseif ( $size == 'thick' ) $size = 5*(25.4/$this->dpi); //5 pixel width for table borders
  elseif ($size == 'xx-small') {
	if ($fontsize) { $size *= $fontsize*0.7; }
	else { $size *= $maxsize*0.7; }
  }
  elseif ($size == 'x-small') {
	if ($fontsize) { $size *= $fontsize*0.77; }
	else { $size *= $maxsize*0.77; }
  }
  elseif ($size == 'small') {
	if ($fontsize) { $size *= $fontsize*0.86; }
	else { $size *= $maxsize*0.86; }
  }
  elseif ($size == 'medium') {
	if ($fontsize) { $size *= $fontsize; }
	else { $size *= $maxsize; }
  }
  elseif ($size == 'large') {
	if ($fontsize) { $size *= $fontsize*1.2; }
	else { $size *= $maxsize*1.2; }
  }
  elseif ($size == 'x-large') {
	if ($fontsize) { $size *= $fontsize*1.5; }
	else { $size *= $maxsize*1.5; }
  }
  elseif ($size == 'xx-large') {
	if ($fontsize) { $size *= $fontsize*2; }
	else { $size *= $maxsize*2; }
  }
  else $size *= (25.4/$this->dpi); //nothing == px
  
  return $size;
}

// mPDF 5.7.3 TRANSFORMS
function ConvertAngle($s, $makepositive=true) {
	if (preg_match('/([\-]*[0-9\.]+)(deg|grad|rad)/i',$s,$m)) {
		$angle = $m[1] + 0;
		if (strtolower($m[2])=='deg') { $angle = $angle; }
		else if (strtolower($m[2])=='grad') { $angle *= (360/400); }
		else if (strtolower($m[2])=='rad') { $angle = rad2deg($angle); }
		while($angle >= 360) { $angle -= 360; }
		while($angle <= -360) { $angle += 360; }
		if ($makepositive) {	// always returns an angle between 0 and 360deg
			if ($angle < 0) { $angle += 360; }
		}
	}
	else { $angle = $s + 0; }
	return $angle;
}

function lesser_entity_decode($html) {
  //supports the most used entity codes (only does ascii safe characters)
 	$html = str_replace("&lt;","<",$html);
 	$html = str_replace("&gt;",">",$html);

 	$html = str_replace("&apos;","'",$html);
 	$html = str_replace("&quot;",'"',$html);
 	$html = str_replace("&amp;","&",$html);
	return $html;
}

function AdjustHTML($html, $tabSpaces=8) {
	//Try to make the html text more manageable (turning it into XHTML)
	if (PHP_VERSION_ID < 50307) {
		if (strlen($html) > 100000) {
			if (PHP_VERSION_ID < 50200) $this->Error("The HTML code is more than 100,000 characters. You should use WriteHTML() with smaller string lengths.");
			else ini_set("pcre.backtrack_limit","1000000");
		}
	}

/*-- ANNOTATIONS --*/
	preg_match_all("/(<annotation.*?>)/si", $html, $m);
	if (count($m[1])) { 
		for($i=0;$i<count($m[1]);$i++) {
			$sub = preg_replace("/\n/si", "\xbb\xa4\xac", $m[1][$i]);
			$html = preg_replace('/'.preg_quote($m[1][$i], '/').'/si', $sub, $html); 
		}
	}
/*-- END ANNOTATIONS --*/

	preg_match_all("/(<svg.*?<\/svg>)/si", $html, $svgi);
	if (count($svgi[0])) { 
		for($i=0;$i<count($svgi[0]);$i++) {
			$file = _MPDF_TEMP_PATH.'_tempSVG'.uniqid(rand(1,100000),true).'_'.$i.'.svg';
			//Save to local file
			file_put_contents($file, $svgi[0][$i]);
			$html = str_replace($svgi[0][$i], '<img src="'.$file.'" />', $html); 
		}
	}

	//Remove javascript code from HTML (should not appear in the PDF file)
	$html = preg_replace('/<script.*?<\/script>/is','',$html);

	//Remove special comments
	$html = preg_replace('/<!--mpdf/i','',$html);
	$html = preg_replace('/mpdf-->/i','',$html);

	//Remove comments from HTML (should not appear in the PDF file)
	$html = preg_replace('/<!--.*?-->/s','',$html);

	$html = preg_replace('/\f/','',$html); //replace formfeed by nothing
	$html = preg_replace('/\r/','',$html); //replace carriage return by nothing

	// Well formed XHTML end tags
	$html = preg_replace('/<(br|hr)>/i',"<\\1 />",$html);	// mPDF 6
	$html = preg_replace('/<(br|hr)\/>/i',"<\\1 />",$html);
	// Get rid of empty <thead></thead> etc
	$html = preg_replace('/<tr>\s*<\/tr>/i','',$html);
	$html = preg_replace('/<thead>\s*<\/thead>/i','',$html);
	$html = preg_replace('/<tfoot>\s*<\/tfoot>/i','',$html);
	$html = preg_replace('/<table[^>]*>\s*<\/table>/i','',$html);

	// Remove spaces at end of table cells
	$html = preg_replace("/[ \n\r]+<\/t(d|h)/",'</t\\1',$html);	

	$html = preg_replace("/[ ]*<dottab\s*[\/]*>[ ]*/",'<dottab />',$html);

	// Concatenates any Substitute characters from symbols/dingbats
	$html = str_replace('</tts><tts>','|',$html);
	$html = str_replace('</ttz><ttz>','|',$html);
	$html = str_replace('</tta><tta>','|',$html);

	$html = preg_replace('/<br \/>\s*/is',"<br />",$html);

	$html = preg_replace('/<wbr[ \/]*>\s*/is',"&#173;",$html);

	// Preserve '\n's in content between the tags <pre> and </pre>
	if (preg_match('/<pre/',$html)) {
		$html_a = preg_split('/(\<\/?pre[^\>]*\>)/', $html, -1, 2);
		$h = array();
		$c=0;
		foreach($html_a AS $s) {
			if ($c>1 && preg_match('/^<\/pre/i',$s)) { $c--; $s=preg_replace('/<\/pre/i','</innerpre',$s); }
			else if ($c>0 && preg_match('/^<pre/i',$s)) { $c++; $s=preg_replace('/<pre/i','<innerpre',$s); }
			else if (preg_match('/^<pre/i',$s)) { $c++; }
			else if (preg_match('/^<\/pre/i',$s)) { $c--; }
			array_push($h, $s);
		}
		$html = implode("", $h);
	}
	$thereispre = preg_match_all('#<pre(.*?)>(.*?)</pre>#si',$html,$temp);
	// Preserve '\n's in content between the tags <textarea> and </textarea>
	$thereistextarea = preg_match_all('#<textarea(.*?)>(.*?)</textarea>#si',$html,$temp2);
	$html = preg_replace('/[\n]/',' ',$html); //replace linefeed by spaces
	$html = preg_replace('/[\t]/',' ',$html); //replace tabs by spaces

	// Converts < to &lt; when not a tag
	$html = preg_replace('/<([^!\/a-zA-Z_:])/i','&lt;\\1',$html);	// mPDF 5.7.3
	$html = preg_replace("/[ ]+/",' ',$html);

	$html = preg_replace('/\/li>\s+<\/(u|o)l/i','/li></\\1l',$html);
	$html = preg_replace('/\/(u|o)l>\s+<\/li/i','/\\1l></li',$html);
	$html = preg_replace('/\/li>\s+<\/(u|o)l/i','/li></\\1l',$html);
	$html = preg_replace('/\/li>\s+<li/i','/li><li',$html);
	$html = preg_replace('/<(u|o)l([^>]*)>[ ]+/i','<\\1l\\2>',$html);
	$html = preg_replace('/[ ]+<(u|o)l/i','<\\1l',$html);

	// Make self closing tabs valid XHTML
	// Tags which are self-closing: 1) Replaceable and 2) Non-replaced items
	$selftabs = 'input|hr|img|br|jpgraph|barcode|dottab';
	$selftabs2 = 'indexentry|indexinsert|bookmark|watermarktext|watermarkimage|column_break|columnbreak|newcolumn|newpage|page_break|pagebreak|formfeed|columns|toc|tocpagebreak|setpageheader|setpagefooter|sethtmlpageheader|sethtmlpagefooter|annotation';
	$html = preg_replace('/(<('.$selftabs.'|'.$selftabs2.')[^>\/]*)>/i','\\1 />',$html);

	$iterator = 0;
	while($thereispre) //Recover <pre attributes>content</pre>
	{
		$temp[2][$iterator] = preg_replace('/<([^!\/a-zA-Z_:])/','&lt;\\1',$temp[2][$iterator]);	// mPDF 5.7.2	// mPDF 5.7.3

		$temp[2][$iterator] = preg_replace_callback("/^([^\n\t]*?)\t/m", array($this, 'tabs2spaces_callback'), $temp[2][$iterator]);	// mPDF 5.7+
		$temp[2][$iterator] = preg_replace('/\t/',str_repeat(" ",$tabSpaces),$temp[2][$iterator]);

		$temp[2][$iterator] = preg_replace('/\n/',"<br />",$temp[2][$iterator]);
		$temp[2][$iterator] = str_replace('\\',"\\\\",$temp[2][$iterator]);
		//$html = preg_replace('#<pre(.*?)>(.*?)</pre>#si','<erp'.$temp[1][$iterator].'>'.$temp[2][$iterator].'</erp>',$html,1);
		$html = preg_replace('#<pre(.*?)>(.*?)</pre>#si','<erp'.$temp[1][$iterator].'>'.str_replace('$','\$',$temp[2][$iterator]).'</erp>',$html,1);	// mPDF 5.7+
		$thereispre--;
		$iterator++;
	}
	$iterator = 0;
	while($thereistextarea) //Recover <textarea attributes>content</textarea>
	{
		$temp2[2][$iterator] = preg_replace('/\t/',str_repeat(" ",$tabSpaces),$temp2[2][$iterator]);
		$temp2[2][$iterator] = str_replace('\\',"\\\\",$temp2[2][$iterator]);
		$html = preg_replace('#<textarea(.*?)>(.*?)</textarea>#si','<aeratxet'.$temp2[1][$iterator].'>'.trim($temp2[2][$iterator]) .'</aeratxet>',$html,1);
		$thereistextarea--;
		$iterator++;
	}
	//Restore original tag names
	$html = str_replace("<erp","<pre",$html);
	$html = str_replace("</erp>","</pre>",$html);
	$html = str_replace("<aeratxet","<textarea",$html);
	$html = str_replace("</aeratxet>","</textarea>",$html);
	$html = str_replace("</innerpre","</pre",$html); 
	$html = str_replace("<innerpre","<pre",$html); 

	$html = preg_replace('/<textarea([^>]*)><\/textarea>/si','<textarea\\1> </textarea>',$html);
	$html = preg_replace('/(<table[^>]*>)\s*(<caption)(.*?<\/caption>)(.*?<\/table>)/si','\\2 position="top"\\3\\1\\4\\2 position="bottom"\\3',$html);	// *TABLES*
	$html = preg_replace('/<(h[1-6])([^>]*)(>(?:(?!h[1-6]).)*?<\/\\1>\s*<table)/si','<\\1\\2 keep-with-table="1"\\3',$html);	// *TABLES*
	$html = preg_replace("/\xbb\xa4\xac/", "\n", $html);

	// Fixes <p>&#8377</p> which browser copes with even though it is wrong!
	$html = preg_replace("/(&#[x]{0,1}[0-9a-f]{1,5})</i", "\\1;<", $html);
	return $html;
}
// mPDF 5.7+
function tabs2spaces_callback($matches) {
	return (stripslashes($matches[1]) . str_repeat(' ', $this->tabSpaces - (mb_strlen(stripslashes($matches[1])) % $this->tabSpaces)));
}
// mPDF 5.7+
function date_callback($matches) {
	return date($matches[1]);
}


function dec2other($num, $cp, $check=true) {
	// From printlistbuffer: font is set, so check if character is available
	// From docPageNum: font is not set, so no check
	$nstr = (string) $num;
	$rnum = '';
	for ($i=0;$i<strlen($nstr);$i++) { 
		if (!$check || $this->_charDefined($this->CurrentFont['cw'],$cp+intval($nstr[$i]))) {
			$rnum .= code2utf($cp+intval($nstr[$i]));
		}
		else { $rnum .= $nstr[$i]; }
	}
	return $rnum;
}

function dec2cjk($num) {
	$nstr = (string) $num;
	$rnum = '';
	$glyphs = array(0x3007, 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03, 0x516B, 0x4E5D);
	for ($i=0;$i<strlen($nstr);$i++) { 
		$rnum .= code2utf($glyphs[intval($nstr[$i])]);
	}
	return $rnum;
}

function dec2alpha($valor,$toupper="true"){
// returns a string from A-Z to AA-ZZ to AAA-ZZZ
// OBS: A = 65 ASCII TABLE VALUE
  if (($valor < 1)  || ($valor > 18278)) return "?"; //supports 'only' up to 18278
  $c1 = $c2 = $c3 = '';
  if ($valor > 702) // 3 letters (up to 18278)
    {
      $c1 = 65 + floor(($valor-703)/676);
      $c2 = 65 + floor((($valor-703)%676)/26);
      $c3 = 65 + floor((($valor-703)%676)%26);
    }
  elseif ($valor > 26) // 2 letters (up to 702)
  {
      $c1 = (64 + (int)(($valor-1) / 26));
      $c2 = (64 + (int)($valor % 26));
      if ($c2 == 64) $c2 += 26;
  }
  else // 1 letter (up to 26)
  {
      $c1 = (64 + $valor);
  }
  $alpha = chr($c1);
  if ($c2 != '') $alpha .= chr($c2);
  if ($c3 != '') $alpha .= chr($c3);
  if (!$toupper) $alpha = strtolower($alpha);
  return $alpha;
}

// mPDF 6
function dec2hebrew($in, $reverse = false) {
	// reverse is used when called from Lists, as these do not pass through bidi-algorithm
	$i = intval( $in );	// I initially be the counter value
	$s = '';	// S initially be the empty string
	//and glyph list initially be the list of additive tuples.
	$additive_nums = array(400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);
	$additive_glyphs = array(0x05EA, 0x05E9, 0x05E8, 0x05E7, 0x05E6, 0x05E4, 0x05E2, 0x05E1, 0x05E0, 0x05DE, 0x05DC, 0x05DB, 
		array(0x05D9,0x05D8), array(0x05D9,0x05D7), array(0x05D9,0x05D6), array(0x05D8,0x05D6), array(0x05D8,0x05D5), 0x05D9, 
		0x05D8, 0x05D7, 0x05D6, 0x05D5, 0x05D4, 0x05D3, 0x05D2, 0x05D1, 0x05D0);
	/* NB This system manually specifies the values for 19-15 to force the correct display of 15 and 16, which are commonly
	rewritten to avoid a close resemblance to the Tetragrammaton. */
	// This function only works up to 1,000
	if ($i>999) { return $in; } // return as initial numeric string

	// If I is initially 0, and there is an additive tuple with a weight of 0, append that tuple's counter glyph to S and return S.
	if ($i==0) { return '0'; }

	// Otherwise, while I is greater than 0 and there are elements left in the glyph list:
	for ($t=0; $t<count($additive_nums); $t++) {

		// Pop the first additive tuple from the glyph list. This is the current tuple.
		$ct = $additive_nums[$t];
		// Append the current tuple's counter glyph to S x floor( I / current tuple's weight ) times (this may be 0). 
		$n = floor($i / $ct);
		for($j=0;$j<$n;$j++) { 
			if (is_array($additive_glyphs[$t])) {
				foreach ($additive_glyphs[$t] AS $ag) { 
					if ($reverse) { $s = code2utf($ag) . $s; }
					else { $s .= code2utf($ag);  }
				}
			}
			else { 
				if ($reverse) { $s = code2utf($additive_glyphs[$t]) . $s; }
				else { $s .= code2utf($additive_glyphs[$t]); }
			}
			$i -= ($ct * $n);
		}
		if ($i==0) { return $s; }
	}
	return $in; // return as initial string
}


function dec2roman($valor,$toupper=true){
 //returns a string as a roman numeral
  $r1=$r2=$r3=$r4='';
  if (($valor >= 5000) || ($valor < 1)) return "?"; //supports 'only' up to 4999
  $aux = (int)($valor/1000);
  if ($aux!==0)
  {
    $valor %= 1000;
    while($aux!==0)
    {
    	$r1 .= "M";
    	$aux--;
    }
  }
  $aux = (int)($valor/100);
  if ($aux!==0)
  {
    $valor %= 100;
    switch($aux){
	case 3: $r2="C";
	case 2: $r2.="C";
	case 1: $r2.="C"; break;
	case 9: $r2="CM"; break;
	case 8: $r2="C";
	case 7: $r2.="C";
	case 6: $r2.="C";
	case 5: $r2="D".$r2; break;
	case 4: $r2="CD"; break;
	default: break;
    }
  }
  $aux = (int)($valor/10);
  if ($aux!==0)
  {
    $valor %= 10;
    switch($aux){
	case 3: $r3="X";
	case 2: $r3.="X";
	case 1: $r3.="X"; break;
	case 9: $r3="XC"; break;
	case 8: $r3="X";
	case 7: $r3.="X";
	case 6: $r3.="X";
	case 5: $r3="L".$r3; break;
	case 4: $r3="XL"; break;
	default: break;
    }
  }
  switch($valor){
	case 3: $r4="I";
	case 2: $r4.="I";
	case 1: $r4.="I"; break;
	case 9: $r4="IX"; break;
	case 8: $r4="I";
	case 7: $r4.="I";
	case 6: $r4.="I";
	case 5: $r4="V".$r4; break;
	case 4: $r4="IV"; break;
	default: break;
  }
  $roman = $r1.$r2.$r3.$r4;
  if (!$toupper) $roman = strtolower($roman);
  return $roman;
}

//===========================
/*-- IMPORTS --*/
function SetImportUse() {
	$this->enableImports = true;
	ini_set('auto_detect_line_endings',1);
	require_once(_MPDF_PATH."mpdfi/pdf_context.php");
	require_once(_MPDF_PATH."mpdfi/pdf_parser.php");
	require_once(_MPDF_PATH."mpdfi/fpdi_pdf_parser.php");
}

// from mPDFI
function hex2str($hex) {
	return pack("H*", str_replace(array("\r","\n"," "),"", $hex));
}
    
function str2hex($str) {
	return current(unpack("H*",$str));
}

    
function pdf_write_value(&$value) {
	switch ($value[0]) {
		case PDF_TYPE_NUMERIC :
		case PDF_TYPE_TOKEN :
			// A numeric value or a token.
			// Simply output them
			$this->_out($value[1]." ", false);
			break;

		case PDF_TYPE_ARRAY :
			// An array. Output the proper
			// structure and move on.
			$this->_out("[",false);
			for ($i = 0; $i < count($value[1]); $i++) {
				$this->pdf_write_value($value[1][$i]);
			}
			$this->_out("]");
			break;

		case PDF_TYPE_DICTIONARY :
			// A dictionary.
			$this->_out("<<",false);
			reset ($value[1]);
			while (list($k, $v) = each($value[1])) {
				$this->_out($k . " ",false);
				$this->pdf_write_value($v);
			}
			$this->_out(">>");
			break;

		case PDF_TYPE_OBJREF :
			// An indirect object reference
			// Fill the object stack if needed
			$cpfn =& $this->current_parser->filename;
			if (!isset($this->_don_obj_stack[$cpfn][$value[1]])) {
					$this->_newobj(false,true);
					$this->_obj_stack[$cpfn][$value[1]] = array($this->n, $value);
					$this->_don_obj_stack[$cpfn][$value[1]] = array($this->n, $value);
			}
			$objid = $this->_don_obj_stack[$cpfn][$value[1]][0];
			$this->_out("{$objid} 0 R"); //{$value[2]}
			break;

		case PDF_TYPE_STRING :
			if ($this->encrypted) {
				$value[1] = $this->_RC4($this->_objectkey($this->_current_obj_id), $value[1]);
				$value[1] = $this->_escape($value[1]);
			} 
			// A string.
			$this->_out('('.$value[1].')');
			break;

		case PDF_TYPE_STREAM :
			// A stream. First, output the
			// stream dictionary, then the
			// stream data itself.
			$this->pdf_write_value($value[1]);
			if ($this->encrypted) {
				$value[2][1] = $this->_RC4($this->_objectkey($this->_current_obj_id), $value[2][1]);
			}
			$this->_out("stream");
			$this->_out($value[2][1]);
			$this->_out("endstream");
			break;

		case PDF_TYPE_HEX :
			if ($this->encrypted) {
				$value[1] = $this->hex2str($value[1]);
				$value[1] = $this->_RC4($this->_objectkey($this->_current_obj_id), $value[1]);
				// remake hexstring of encrypted string
				$value[1] = $this->str2hex($value[1]);
			}
			$this->_out("<".$value[1].">");
			break;

		case PDF_TYPE_NULL :
			// The null object.
			$this->_out("null");
			break;
	}
}

// ========== OVERWRITE SEARCH STRING IN A PDF FILE ================
function OverWrite($file_in, $search, $replacement, $dest="D", $file_out="mpdf" ) {
	$pdf = file_get_contents($file_in);

	if (!is_array($search)) {
		$x = $search;
		$search = array($x);
	}
	if (!is_array($replacement)) {
		$x = $replacement;
		$replacement = array($x);	// mPDF 5.7.4
	}

	if (!$this->onlyCoreFonts && !$this->usingCoreFont) {	
	  foreach($search AS $k=>$val) {
		$search[$k] = $this->UTF8ToUTF16BE($search[$k] , false);
		$search[$k] = $this->_escape($search[$k]); 
		$replacement[$k] = $this->UTF8ToUTF16BE($replacement[$k], false);
		$replacement[$k] = $this->_escape($replacement[$k]); 
	  }
	}
	else {
	  foreach($replacement AS $k=>$val) {
		$replacement[$k] = mb_convert_encoding($replacement[$k],$this->mb_enc,'utf-8'); 
		$replacement[$k] = $this->_escape($replacement[$k]); 
	  }
	}

	// Get xref into array
	$xref = array();
	preg_match("/xref\n0 (\d+)\n(.*?)\ntrailer/s",$pdf,$m);
	$xref_objid = $m[1];
	preg_match_all('/(\d{10}) (\d{5}) (f|n)/',$m[2],$x);
	for($i=0; $i<count($x[0]); $i++) {
		$xref[] = array(intval($x[1][$i]), $x[2][$i], $x[3][$i]);
	}

	$changes = array();
	preg_match("/<<\s*\/Type\s*\/Pages\s*\/Kids\s*\[(.*?)\]\s*\/Count/s",$pdf,$m);
	preg_match_all("/(\d+) 0 R /s",$m[1],$o);
	$objlist = $o[1];
	foreach($objlist AS $obj) {
	  if ($this->compress) {
	  	preg_match("/".($obj+1)." 0 obj\n<<\s*\/Filter\s*\/FlateDecode\s*\/Length (\d+)>>\nstream\n(.*?)\nendstream\n/s",$pdf,$m);
	  }
	  else {
	  	preg_match("/".($obj+1)." 0 obj\n<<\s*\/Length (\d+)>>\nstream\n(.*?)\nendstream\n/s",$pdf,$m);
	  }
	  $s = $m[2];
	  if (!$s) { continue; }
	  $oldlen = $m[1];
	  if ($this->encrypted) {
		$s = $this->_RC4($this->_objectkey($obj+1), $s);
	  }
	  if ($this->compress) {
	  	$s = gzuncompress($s);
	  }
  	  foreach($search AS $k=>$val) {
		$s = str_replace($search[$k],$replacement[$k],$s);
	  }
	  if ($this->compress) {
		$s = gzcompress($s);
	  }
	  if ($this->encrypted) {
		$s = $this->_RC4($this->_objectkey($obj+1), $s);
	  }
	  $newlen = strlen($s);
	  $changes[($xref[$obj+1][0])] = ($newlen - $oldlen) + (strlen($newlen) - strlen($oldlen ));
	  if ($this->compress) {
	  	$newstr = ($obj+1) . " 0 obj\n<</Filter /FlateDecode /Length ".$newlen.">>\nstream\n".$s."\nendstream\n";
	  }
	  else {
	  	$newstr = ($obj+1) . " 0 obj\n<</Length ".$newlen.">>\nstream\n".$s."\nendstream\n";
	  }
	  $pdf = str_replace($m[0],$newstr,$pdf);
	}

	// Update xref in PDF
	krsort($changes);
	$newxref = "xref\n0 ".$xref_objid."\n";
	foreach($xref AS $v) { 
		foreach($changes AS $ck => $cv) {
			if ($v[0] > $ck) { $v[0] += $cv; }
		}
		$newxref .= sprintf('%010d',$v[0]) . ' ' . $v[1] . ' ' .$v[2] . " \n";
	}
	$newxref .= "trailer";
	$pdf = preg_replace("/xref\n0 \d+\n.*?\ntrailer/s",$newxref,$pdf);

	// Update startxref in PDF
	preg_match("/startxref\n(\d+)\n%%EOF/s", $pdf, $m);
	$startxref = $m[1];
	$startxref += array_sum($changes);
	$pdf = preg_replace("/startxref\n(\d+)\n%%EOF/s","startxref\n".$startxref."\n%%EOF",$pdf);

	// OUTPUT
	switch($dest) {
		case 'I':
			//Send to standard output
			if(isset($_SERVER['SERVER_NAME']))
			{
				//We send to a browser
				Header('Content-Type: application/pdf');
				Header('Content-Length: '.strlen($pdf));
				Header('Content-disposition: inline; filename='.$file_out);
			}
			echo $pdf;
			break;
		case 'F':
			//Save to local file
			if (!$file_out) { $file_out = 'mpdf.pdf'; }
			$f=fopen($file_out,'wb');
			if(!$f) die('Unable to create output file: '.$file_out);
			fwrite($f,$pdf,strlen($pdf));
			fclose($f);
			break;
		case 'S':
			//Return as a string
			return $pdf;
		case 'D':
		default:
			//Download file
			if(isset($_SERVER['HTTP_USER_AGENT']) and strpos($_SERVER['HTTP_USER_AGENT'],'MSIE'))
				Header('Content-Type: application/force-download');
			else
				Header('Content-Type: application/octet-stream');
			Header('Content-Length: '.strlen($pdf));
			Header('Content-disposition: attachment; filename='.$file_out);
 			echo $pdf;
			break;
	}
}


function GetTemplateSize($tplidx, $_w=0, $_h=0) {
	if (!$this->tpls[$tplidx])
		return false;
	$w = $this->tpls[$tplidx]['box']['w'];
	$h = $this->tpls[$tplidx]['box']['h'];
	if ($_w == 0 and $_h == 0) {
		$_w = $w;
		$_h = $h;
	}
	if($_w==0)
		$_w=$_h*$w/$h;
	if($_h==0)
		$_h=$_w*$h/$w;
	return array("w" => $_w, "h" => $_h);
}

// Thumbnails
function Thumbnail($file, $npr=3, $spacing=10) {	//$npr = number per row
	$w = (($this->pgwidth + $spacing)/$npr) - $spacing;
	$oldlinewidth = $this->LineWidth;
	$this->SetLineWidth(0.02); 
	$this->SetDColor($this->ConvertColor(0));	
	$h = 0;
	$maxh = 0;
	$x = $_x = $this->lMargin;
	$_y = $this->tMargin;
	if ($this->y==0) { $y = $_y; } else { $y = $this->y; }
	$pagecount = $this->SetSourceFile($file);
	for ($n = 1; $n <= $pagecount; $n++) {
		$tplidx = $this->ImportPage($n);
		$size = $this->useTemplate($tplidx, $x, $y, $w);
		$this->Rect($x, $y, $size['w'], $size['h']);
		$h = max($h, $size['h']);
		$maxh = max($h, $maxh);
		if ($n % $npr == 0) {
		   if (($y + $h + $spacing + $maxh)>$this->PageBreakTrigger && $n != $pagecount) {
			$this->AddPage();  
			$x = $_x;
			$y = $_y;        
		   }
		   else {
			$y += $h+$spacing ;
			$x = $_x;
			$h = 0;
		   }
		}
		else {
			$x += $w+$spacing ;
		}
	}
	$this->SetLineWidth($oldlinewidth);
}

function SetSourceFile($filename) {
	$this->current_filename = $filename;
	$fn =& $this->current_filename;
	if (!isset($this->parsers[$fn]))
		// $this->parsers[$fn] =& new fpdi_pdf_parser($fn,$this);
		$this->parsers[$fn] = new fpdi_pdf_parser($fn,$this);
	if (!$this->parsers[$fn]->success) {
		$this->Error($this->parsers[$fn]->errormsg);	// Delete this line to return false on fail
		return false;
	}
	$this->current_parser =& $this->parsers[$fn];
	return $this->parsers[$fn]->getPageCount();
}
function ImportPage($pageno=1, $crop_x=null, $crop_y=null, $crop_w=0, $crop_h=0, $boxName='/CropBox') {
	$fn =& $this->current_filename;
	$parser =& $this->parsers[$fn];
	$parser->setPageno($pageno);

	$this->tpl++;
	$this->tpls[$this->tpl] = array();
	$tpl =& $this->tpls[$this->tpl];
	$tpl['parser'] =& $parser;
	$tpl['resources'] = $parser->getPageResources();
	$tpl['buffer'] = $parser->getContent();
	if (!in_array($boxName, $parser->availableBoxes))
		return $this->Error(sprintf("Unknown box: %s", $boxName));
	$pageboxes = $parser->getPageBoxes($pageno);
	/**
	 * MediaBox
	 * CropBox: Default -> MediaBox
	 * BleedBox: Default -> CropBox
	 * TrimBox: Default -> CropBox
	 * ArtBox: Default -> CropBox
	 */
	if (!isset($pageboxes[$boxName]) && ($boxName == "/BleedBox" || $boxName == "/TrimBox" || $boxName == "/ArtBox"))
		$boxName = "/CropBox";
	if (!isset($pageboxes[$boxName]) && $boxName == "/CropBox")
		$boxName = "/MediaBox";
	if (!isset($pageboxes[$boxName]))
		return false;
	$box = $pageboxes[$boxName];

	$tpl['box'] = $box;
	// To build an array that can be used by useTemplate()
	$this->tpls[$this->tpl] = array_merge($this->tpls[$this->tpl],$box);
	// An imported page will start at 0,0 everytime. Translation will be set in _putformxobjects()
	$tpl['x'] = 0;
	$tpl['y'] = 0;
	$tpl['w'] = $tpl['box']['w'] ;
	$tpl['h'] = $tpl['box']['h'] ;
	if ($crop_w) { $tpl['box']['w'] = $crop_w; }
	if ($crop_h) { $tpl['box']['h'] = $crop_h; }
	if (isset($crop_x)) { $tpl['box']['x'] = $crop_x; }
	if (isset($crop_y)) {$tpl['box']['y'] = $tpl['h'] - $crop_y  - $crop_h ; }

	$page =& $parser->pages[$parser->pageno];
	// fix for rotated pages
	$rotation = $parser->getPageRotation($pageno);

	if (isset($rotation[1]) && ($angle = $rotation[1] % 360) != 0 && $tpl['box']['w'] == $tpl['w']) {
		$steps = $angle / 90;

		$_w = $tpl['w'];
		$_h = $tpl['h'];
		$tpl['w'] = $steps % 2 == 0 ? $_w : $_h;
		$tpl['h'] = $steps % 2 == 0 ? $_h : $_w;
		if ($steps % 2 != 0) {
			$x = $y = ($steps == 1 || $steps == -3) ? $tpl['h'] : $tpl['w'];
		} else {
			$x = $tpl['w'];
			$y = $tpl['h'];
		}
		$cx=($x/2+$tpl['box']['x'])*_MPDFK;
		$cy=($y/2+$tpl['box']['y'])*_MPDFK;
		$angle*=-1; 
		$angle*=M_PI/180;
		$c=cos($angle);
		$s=sin($angle);
		$tpl['box']['w'] = $tpl['w'] ;
		$tpl['box']['h'] = $tpl['h'] ;
		$tpl['buffer'] = sprintf('q %.5F %.5F %.5F %.5F %.2F %.2F cm 1 0 0 1 %.2F %.2F cm %s Q',$c,$s,-$s,$c,$cx,$cy,-$cx,-$cy, $tpl['buffer']);
	}
	return $this->tpl;
}
function UseTemplate($tplidx, $_x=null, $_y=null, $_w=0, $_h=0) {
	if (!isset($this->tpls[$tplidx]))
		$this->Error("Template does not exist!");
	if($this->state==0) { $this->AddPage(); }
	$out = 'q 0 J 1 w 0 j 0 G'."\n"; // reset standard values
	$x = $this->tpls[$tplidx]['x'];
	$y = $this->tpls[$tplidx]['y'];
	$w = $this->tpls[$tplidx]['w'];
	$h = $this->tpls[$tplidx]['h'];
	if ($_x == null) { $_x = $x; }
	if ($_y == null) { $_y = $y; }
	if ($_x === -1) { $_x = $this->x; }
	if ($_y === -1) { $_y = $this->y; }

	$wh = $this->getTemplateSize($tplidx,$_w,$_h);
	$_w = $wh['w'];
	$_h = $wh['h'];
	$out .= sprintf("q %.4F 0 0 %.4F %.2F %.2F cm", ($_w/$this->tpls[$tplidx]['box']['w']), ($_h/$this->tpls[$tplidx]['box']['h']), $_x*_MPDFK, ($this->h-($_y+$_h))*_MPDFK)."\n"; 
	$out .= $this->tplprefix.$tplidx." Do Q\n";

	$s = array("w" => $_w, "h" => $_h);
	$out .= "Q\n";
	$this->pages[$this->page] = $out . $this->pages[$this->page];
	return $s;
}
function SetPageTemplate($tplidx='') {
	if (!isset($this->tpls[$tplidx])) {
		$this->pageTemplate = '';
		return false;
	}
	$this->pageTemplate = $tplidx;
}
function SetDocTemplate($file='', $continue=0) {
	$this->docTemplate = $file;
	$this->docTemplateContinue = $continue;
}
/*-- END IMPORTS --*/


/* ---------------------------------------------- */
/* ---------------------------------------------- */
/* ---------------------------------------------- */
/* ---------------------------------------------- */
/* ---------------------------------------------- */

// JAVASCRIPT
function _set_object_javascript ($string) {
	$this->_newobj();
	$this->_out('<<');
	$this->_out('/S /JavaScript ');
	$this->_out('/JS '.$this->_textstring($string));
	$this->_out('>>');
	$this->_out('endobj');
}

function SetJS($script) {
	$this->js = $script;
}




}//end of Class




?>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <?php

define("_OTL_OLD_SPEC_COMPAT_1", true);

define("_DICT_NODE_TYPE_SPLIT", 0x01);
define("_DICT_NODE_TYPE_LINEAR", 0x02);
define("_DICT_INTERMEDIATE_MATCH", 0x03);
define("_DICT_FINAL_MATCH", 0x04);



class otl {

var $mpdf;
var $arabLeftJoining;
var $arabRightJoining;
var $arabTransparentJoin;
var $arabTransparent;
var $GSUBdata;
var $GPOSdata;
var $GSUBfont;
var $fontkey;
var $ttfOTLdata;
var $glyphIDtoUni;
var $_pos;
var $GSUB_offset;
var $GPOS_offset;
var $MarkAttachmentType;
var $MarkGlyphSets;
var $GlyphClassMarks; 
var $GlyphClassLigatures; 
var $GlyphClassBases; 
var $GlyphClassComponents; 
var $Ignores;
var $LuCoverage;
var $OTLdata;
var $assocLigs;
var $assocMarks;
var $shaper;
var $restrictToSyllable;
var $lbdicts;	// Line-breaking dictionaries
var $LuDataCache;

var $debugOTL = false;

function otl(&$mpdf) {
	$this->mpdf = $mpdf;

	$this->arabic_initialise();
	$this->current_fh = '';

	$this->lbdicts = array();
	$this->LuDataCache = array();
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//////////       APPLY OTL          ////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

function applyOTL($str, $useOTL) {
	$this->OTLdata = array();
	if (trim($str)=='') { return $str; }
	if (!$useOTL) { return $str; }

	// 1. Load GDEF data
	//==============================
	$this->fontkey = $this->mpdf->CurrentFont['fontkey'];
	$this->glyphIDtoUni = $this->mpdf->CurrentFont['glyphIDtoUni'];
	if (!isset($this->GDEFdata[$this->fontkey])) {
		include(_MPDF_TTFONTDATAPATH.$this->fontkey.'.GDEFdata.php'); 
		$this->GSUB_offset = $this->GDEFdata[$this->fontkey]['GSUB_offset'] = $GSUB_offset;
		$this->GPOS_offset = $this->GDEFdata[$this->fontkey]['GPOS_offset'] = $GPOS_offset;
		$this->GSUB_length = $this->GDEFdata[$this->fontkey]['GSUB_length'] = $GSUB_length;
		$this->MarkAttachmentType = $this->GDEFdata[$this->fontkey]['MarkAttachmentType'] = $MarkAttachmentType;
		$this->MarkGlyphSets = $this->GDEFdata[$this->fontkey]['MarkGlyphSets'] = $MarkGlyphSets;
		$this->GlyphClassMarks = $this->GDEFdata[$this->fontkey]['GlyphClassMarks'] = $GlyphClassMarks; 
		$this->GlyphClassLigatures = $this->GDEFdata[$this->fontkey]['GlyphClassLigatures'] = $GlyphClassLigatures; 
		$this->GlyphClassComponents = $this->GDEFdata[$this->fontkey]['GlyphClassComponents'] = $GlyphClassComponents; 
		$this->GlyphClassBases = $this->GDEFdata[$this->fontkey]['GlyphClassBases'] = $GlyphClassBases;
	}
	else {
		$this->GSUB_offset = $this->GDEFdata[$this->fontkey]['GSUB_offset'];
		$this->GPOS_offset = $this->GDEFdata[$this->fontkey]['GPOS_offset'];
		$this->GSUB_length = $this->GDEFdata[$this->fontkey]['GSUB_length'];
		$this->MarkAttachmentType = $this->GDEFdata[$this->fontkey]['MarkAttachmentType'];
		$this->MarkGlyphSets = $this->GDEFdata[$this->fontkey]['MarkGlyphSets'];
		$this->GlyphClassMarks = $this->GDEFdata[$this->fontkey]['GlyphClassMarks']; 
		$this->GlyphClassLigatures = $this->GDEFdata[$this->fontkey]['GlyphClassLigatures']; 
		$this->GlyphClassComponents = $this->GDEFdata[$this->fontkey]['GlyphClassComponents']; 
		$this->GlyphClassBases = $this->GDEFdata[$this->fontkey]['GlyphClassBases'];
	}

	// 2. Prepare string as HEX string and Analyse character properties
	//=================================================================
	$earr = $this->mpdf->UTF8StringToArray($str, false);

	$scriptblock = 0;
	$scriptblocks = array();
	$scriptblocks[0] = 0;
	$vstr = '';
	$OTLdata = array();
	$subchunk = 0;
	$charctr = 0;
	foreach($earr as $char) {
		$ucd_record = UCDN::get_ucd_record($char);
		$sbl = $ucd_record[6];

		// Special case - Arabic End of Ayah
		if ($char==1757) { $sbl = UCDN::SCRIPT_ARABIC; }

		if ($sbl && $sbl != 40 && $sbl != 102) {
			if ($scriptblock == 0) { $scriptblock = $sbl; $scriptblocks[$subchunk] = $scriptblock; }
			else if ($scriptblock > 0 && $scriptblock != $sbl) {
				// *************************************************
				// NEW (non-common) Script encountered in this chunk. Start a new subchunk
				$subchunk++;
				$scriptblock = $sbl;
				$charctr = 0;
				$scriptblocks[$subchunk] = $scriptblock;
			}
		}

		$OTLdata[$subchunk][$charctr]['general_category'] = $ucd_record[0];
		$OTLdata[$subchunk][$charctr]['bidi_type'] = $ucd_record[2];

		//$OTLdata[$subchunk][$charctr]['combining_class'] = $ucd_record[1];
		//$OTLdata[$subchunk][$charctr]['bidi_type'] = $ucd_record[2];
		//$OTLdata[$subchunk][$charctr]['mirrored'] = $ucd_record[3];
		//$OTLdata[$subchunk][$charctr]['east_asian_width'] = $ucd_record[4];
		//$OTLdata[$subchunk][$charctr]['normalization_check'] = $ucd_record[5];
		//$OTLdata[$subchunk][$charctr]['script'] = $ucd_record[6];

		$charasstr = $this->unicode_hex($char); 

		if (strpos($this->GlyphClassMarks, $charasstr)!==false) { $OTLdata[$subchunk][$charctr]['group'] =  'M'; }
		else if ($char == 32 || $char == 12288) { $OTLdata[$subchunk][$charctr]['group'] =  'S'; }	// 12288 = 0x3000 = CJK space
		else { $OTLdata[$subchunk][$charctr]['group'] =  'C'; }

		$OTLdata[$subchunk][$charctr]['uni'] =  $char;
		$OTLdata[$subchunk][$charctr]['hex'] =  $charasstr;
		$charctr++;
	}

	/* PROCESS EACH SUBCHUNK WITH DIFFERENT SCRIPTS */
for($sch=0;$sch<=$subchunk;$sch++) {
	$this->OTLdata = $OTLdata[$sch];
	$scriptblock = $scriptblocks[$sch];

	// 3. Get Appropriate Scripts, and Shaper engine from analysing text and list of available scripts/langsys in font
	//==============================
	// Based on actual script block of text, select shaper (and line-breaking dictionaries)
	if (UCDN::SCRIPT_DEVANAGARI <= $scriptblock && $scriptblock <= UCDN::SCRIPT_MALAYALAM) { $this->shaper = "I"; }	// INDIC shaper
	else if ($scriptblock == UCDN::SCRIPT_ARABIC || $scriptblock == UCDN::SCRIPT_SYRIAC) { $this->shaper = "A"; }	// ARABIC shaper
	else if ($scriptblock == UCDN::SCRIPT_NKO || $scriptblock == UCDN::SCRIPT_MANDAIC) { $this->shaper = "A"; }	// ARABIC shaper
	else if ($scriptblock == UCDN::SCRIPT_KHMER) { $this->shaper = "K"; }	// KHMER shaper
	else if ($scriptblock == UCDN::SCRIPT_THAI) { $this->shaper = "T"; }	// THAI shaper
	else if ($scriptblock == UCDN::SCRIPT_LAO) { $this->shaper = "L"; }	// LAO shaper
	else if ($scriptblock == UCDN::SCRIPT_SINHALA) { $this->shaper = "S"; }	// SINHALA shaper
	else if ($scriptblock == UCDN::SCRIPT_MYANMAR) { $this->shaper = "M"; }	// MYANMAR shaper
	else if ($scriptblock == UCDN::SCRIPT_NEW_TAI_LUE) { $this->shaper = "E"; }	// SEA South East Asian shaper
	else if ($scriptblock == UCDN::SCRIPT_CHAM) { $this->shaper = "E"; }		// SEA South East Asian shaper
	else if ($scriptblock == UCDN::SCRIPT_TAI_THAM) { $this->shaper = "E"; }	// SEA South East Asian shaper
	else $this->shaper = "";
	// Get scripttag based on actual text script
	$scripttag = UCDN::$uni_scriptblock[$scriptblock];

	$GSUBscriptTag = '';
	$GSUBlangsys = '';
	$GPOSscriptTag = '';
	$GPOSlangsys = '';
	$is_old_spec = false;

	$ScriptLang = $this->mpdf->CurrentFont['GSUBScriptLang'];
	if (count($ScriptLang)) { 
		list($GSUBscriptTag,$is_old_spec) = $this->_getOTLscriptTag($ScriptLang, $scripttag, $scriptblock, $this->shaper, $useOTL, 'GSUB');
		if ($this->mpdf->fontLanguageOverride && strpos($ScriptLang[$GSUBscriptTag], $this->mpdf->fontLanguageOverride)!==false) {
			$GSUBlangsys = str_pad($this->mpdf->fontLanguageOverride,4);
		}
		else if ($GSUBscriptTag && isset($ScriptLang[$GSUBscriptTag]) && $ScriptLang[$GSUBscriptTag]!='') { 
			$GSUBlangsys = $this->_getOTLLangTag($this->mpdf->currentLang, $ScriptLang[$GSUBscriptTag]);
		}
	}
	$ScriptLang = $this->mpdf->CurrentFont['GPOSScriptLang'];

	// NB If after GSUB, the same script/lang exist for GPOS, just use these...
	if ($GSUBscriptTag && $GSUBlangsys && isset($ScriptLang[$GSUBscriptTag]) && strpos($ScriptLang[$GSUBscriptTag], $GSUBlangsys)!==false) {
		$GPOSlangsys = $GSUBlangsys;
		$GPOSscriptTag = $GSUBscriptTag;
	}

	// else repeat for GPOS
	// [Font XBRiyaz has GSUB tables for latn, but not GPOS for latn]
	else if (count($ScriptLang)) {
		list($GPOSscriptTag,$dummy) = $this->_getOTLscriptTag($ScriptLang, $scripttag, $scriptblock, $this->shaper, $useOTL, 'GPOS');
		if ($GPOSscriptTag && $this->mpdf->fontLanguageOverride && strpos($ScriptLang[$GPOSscriptTag], $this->mpdf->fontLanguageOverride)!==false) {
			$GPOSlangsys = str_pad($this->mpdf->fontLanguageOverride,4);
		}
		else if ($GPOSscriptTag && isset($ScriptLang[$GPOSscriptTag]) && $ScriptLang[$GPOSscriptTag]!='') { 
			$GPOSlangsys = $this->_getOTLLangTag($this->mpdf->currentLang, $ScriptLang[$GPOSscriptTag]);
		}
	}

	////////////////////////////////////////////////////////////////
	// This is just for the font_dump_OTL utility to set script and langsys override
	if (isset($this->mpdf->overrideOTLsettings) && isset($this->mpdf->overrideOTLsettings[$this->fontkey])) {
		$GSUBscriptTag = $GPOSscriptTag = $this->mpdf->overrideOTLsettings[$this->fontkey]['script'];
		$GSUBlangsys = $GPOSlangsys = $this->mpdf->overrideOTLsettings[$this->fontkey]['lang'];
	}
	////////////////////////////////////////////////////////////////

	if (!$GSUBscriptTag && !$GSUBlangsys && !$GPOSscriptTag && !$GPOSlangsys) {
		// Remove ZWJ and ZWNJ
		for ($i=0;$i<count($this->OTLdata);$i++) {
			if ($this->OTLdata[$i]['uni']==8204 || $this->OTLdata[$i]['uni']==8205) {
				array_splice($this->OTLdata, $i, 1);
			}
		}
		$this->schOTLdata[$sch] = $this->OTLdata;
		$this->OTLdata = array();
		continue; 
	}

	// Don't use MYANMAR shaper unless using v2 scripttag
	if ($this->shaper == 'M' && $GSUBscriptTag != 'mym2') { $this->shaper = ''; }

	$GSUBFeatures = (isset($this->mpdf->CurrentFont['GSUBFeatures'][$GSUBscriptTag][$GSUBlangsys]) ? $this->mpdf->CurrentFont['GSUBFeatures'][$GSUBscriptTag][$GSUBlangsys] : false);
	$GPOSFeatures = (isset($this->mpdf->CurrentFont['GPOSFeatures'][$GPOSscriptTag][$GPOSlangsys]) ? $this->mpdf->CurrentFont['GPOSFeatures'][$GPOSscriptTag][$GPOSlangsys] : false);

	$this->assocLigs = array();	// Ligatures[$posarr lpos] => nc
	$this->assocMarks = array(); 	// assocMarks[$posarr mpos] => array(compID, ligPos)

	if (!isset($this->GDEFdata[$this->fontkey]['GSUBGPOStables'])) {
		$this->ttfOTLdata = $this->GDEFdata[$this->fontkey]['GSUBGPOStables'] = file_get_contents(_MPDF_TTFONTDATAPATH.$this->fontkey.'.GSUBGPOStables.dat','rb') or die('Can\'t open file ' . _MPDF_TTFONTDATAPATH.$this->fontkey.'.GSUBGPOStables.dat');
	}
	else {
		$this->ttfOTLdata = $this->GDEFdata[$this->fontkey]['GSUBGPOStables'];
	}


	if ($this->debugOTL) { $this->_dumpproc('BEGIN', '-', '-', '-', '-', -1, '-', 0); }


////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
/////////  LINE BREAKING FOR KHMER, THAI + LAO /////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
	// Insert U+200B at word boundaries using dictionaries
	if ($this->mpdf->useDictionaryLBR && ($this->shaper == "K" || $this->shaper == "T" || $this->shaper == "L")) {
		// Sets $this->OTLdata[$i]['wordend']=true at possible end of word boundaries
		$this->SEAlineBreaking();
	}
	// Insert U+200B at word boundaries for Tibetan
	else if ($this->mpdf->useTibetanLBR && $scriptblock == UCDN::SCRIPT_TIBETAN ) {
		// Sets $this->OTLdata[$i]['wordend']=true at possible end of word boundaries
		$this->TibetanlineBreaking();
	}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//////////       GSUB          /////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
  if (($useOTL & 0xFF) && $GSUBscriptTag && $GSUBlangsys && $GSUBFeatures) {

	// 4. Load GSUB data, Coverage & Lookups
	//=================================================================

	$this->GSUBfont = $this->fontkey.'.GSUB.'.$GSUBscriptTag.'.'.$GSUBlangsys;

	if (!isset($this->GSUBdata[$this->GSUBfont])) {
		if (file_exists(_MPDF_TTFONTDATAPATH.$this->mpdf->CurrentFont['fontkey'].'.GSUB.'.$GSUBscriptTag.'.'.$GSUBlangsys.'.php')) {
			include_once(_MPDF_TTFONTDATAPATH.$this->mpdf->CurrentFont['fontkey'].'.GSUB.'.$GSUBscriptTag.'.'.$GSUBlangsys.'.php'); 
			$this->GSUBdata[$this->GSUBfont]['rtlSUB'] = $rtlSUB;
			$this->GSUBdata[$this->GSUBfont]['finals'] = $finals;
			if ($this->shaper=='I') {
				$this->GSUBdata[$this->GSUBfont]['rphf'] = $rphf;
				$this->GSUBdata[$this->GSUBfont]['half'] = $half;
				$this->GSUBdata[$this->GSUBfont]['pref'] = $pref;
				$this->GSUBdata[$this->GSUBfont]['blwf'] = $blwf;
				$this->GSUBdata[$this->GSUBfont]['pstf'] = $pstf;
			}
		}
		else { $this->GSUBdata[$this->GSUBfont] = array('rtlSUB'=>array(), 'rphf'=>array(), 'rphf'=>array(), 
			'pref'=>array(), 'blwf'=>array(), 'pstf'=>array(), 'finals'=>''
			);
		}
	}

	if (!isset($this->GSUBdata[$this->fontkey])) {
		include(_MPDF_TTFONTDATAPATH.$this->fontkey.'.GSUBdata.php'); 
		$this->GSLuCoverage = $this->GSUBdata[$this->fontkey]['GSLuCoverage'] = $GSLuCoverage;
	}
	else {
		$this->GSLuCoverage = $this->GSUBdata[$this->fontkey]['GSLuCoverage'];
	}

	$this->GSUBLookups = $this->mpdf->CurrentFont['GSUBLookups'];


	// 5(A). GSUB - Shaper - ARABIC
	//==============================
	if ($this->shaper == 'A') {
		//-----------------------------------------------------------------------------------
		// a. Apply initial GSUB Lookups (in order specified in lookup list but only selecting from certain tags)
		//-----------------------------------------------------------------------------------
		$tags = 'locl ccmp';
		$omittags = '';
		$usetags = $tags;
		if(!empty($this->mpdf->OTLtags)) { 
			$usetags = $this->_applyTagSettings($tags, $GSUBFeatures, $omittags, true) ;
		}
		$this->_applyGSUBrules($usetags, $GSUBscriptTag, $GSUBlangsys);

		//-----------------------------------------------------------------------------------
		// b. Apply context-specific forms GSUB Lookups (initial, isolated, medial, final)
		//-----------------------------------------------------------------------------------
		// Arab and Syriac are the only scripts requiring the special joining - which takes the place of
		// isol fina medi init rules in GSUB (+ fin2 fin3 med2 in Syriac syrc)
		$tags = 'isol fina fin2 fin3 medi med2 init';
		$omittags = '';
		$usetags = $tags;
		if(!empty($this->mpdf->OTLtags)) { 
			$usetags = $this->_applyTagSettings($tags, $GSUBFeatures, $omittags, true) ;
		}

		$this->arabGlyphs = $this->GSUBdata[$this->GSUBfont]['rtlSUB'];

		$gcms = explode("| ",$this->GlyphClassMarks);
		$gcm = array();
		foreach($gcms AS $g) { $gcm[hexdec($g)] = 1; }
		$this->arabTransparentJoin = $this->arabTransparent + $gcm;
		$this->arabic_shaper($usetags, $GSUBscriptTag);

		//-----------------------------------------------------------------------------------
		// c. Set Kashida points (after joining occurred - medi, fina, init) but before other substitutions
		//-----------------------------------------------------------------------------------
		//if ($scriptblock == UCDN::SCRIPT_ARABIC ) {
		for ($i=0;$i<count($this->OTLdata);$i++) {
			// Put the kashida marker on the character BEFORE which is inserted the kashida
			// Kashida marker is inverse of priority i.e. Priority 1 => 7, Priority 7 => 1.

			// Priority 1	User-inserted Kashida 0640 = Tatweel
			// The user entered a Kashida in a position
			// Position: Before the user-inserted kashida
			if ($this->OTLdata[$i]['uni']==0x0640) {
				$this->OTLdata[$i]['GPOSinfo']['kashida'] = 8; // Put before the next character
			}

			// Priority 2	Seen (0633)  FEB3, FEB4; Sad (0635)  FEBB, FEBC
			// Initial or medial form
			// Connecting to the next character
			// Position: After the character
			else if ($this->OTLdata[$i]['uni']==0xFEB3 || $this->OTLdata[$i]['uni']==0xFEB4 || $this->OTLdata[$i]['uni']==0xFEBB || $this->OTLdata[$i]['uni']==0xFEBC) {
				$checkpos = $i+1;
				while (isset($this->OTLdata[$checkpos]) && strpos($this->GlyphClassMarks, $this->OTLdata[$checkpos]['hex'])!==false) {
					$checkpos++; 
				}
				if (isset($this->OTLdata[$checkpos])) {
					$this->OTLdata[$checkpos]['GPOSinfo']['kashida'] = 7; // Put after marks on next character
				}
			}

			// Priority 3	Taa Marbutah (0629) FE94; Haa (062D) FEA2; Dal (062F) FEAA
			// Final form
			// Connecting to previous character
			// Position: Before the character
			else if ($this->OTLdata[$i]['uni']==0xFE94 || $this->OTLdata[$i]['uni']==0xFEA2 || $this->OTLdata[$i]['uni']==0xFEAA) {
				$this->OTLdata[$i]['GPOSinfo']['kashida'] = 6;
			}

			// Priority 4	Alef (0627) FE8E; Tah (0637) FEC2; Lam (0644) FEDE; Kaf (0643)  FEDA; Gaf (06AF) FB93
			// Final form
			// Connecting to previous character
			// Position: Before the character
			else if ($this->OTLdata[$i]['uni']==0xFE8E || $this->OTLdata[$i]['uni']==0xFEC2 || $this->OTLdata[$i]['uni']==0xFEDE || $this->OTLdata[$i]['uni']==0xFEDA || $this->OTLdata[$i]['uni']==0xFB93) {
				$this->OTLdata[$i]['GPOSinfo']['kashida'] = 5;
			}

			// Priority 5	RA (0631) FEAE; Ya (064A)  FEF2 FEF4; Alef Maqsurah (0649) FEF0 FBE9
			// Final or Medial form
			// Connected to preceding medial BAA (0628) = FE92
			// Position: Before preceding medial Baa
			// Although not mentioned in spec, added Farsi Yeh (06CC) FBFD FBFF; equivalent to 064A or 0649
			else if ($this->OTLdata[$i]['uni']==0xFEAE || $this->OTLdata[$i]['uni']==0xFEF2 || $this->OTLdata[$i]['uni']==0xFEF0
				|| $this->OTLdata[$i]['uni']==0xFEF4 || $this->OTLdata[$i]['uni']==0xFBE9
				|| $this->OTLdata[$i]['uni']==0xFBFD || $this->OTLdata[$i]['uni']==0xFBFF
				) {
				$checkpos = $i-1;
				while (isset($this->OTLdata[$checkpos]) && strpos($this->GlyphClassMarks, $this->OTLdata[$checkpos]['hex'])!==false) {
					$checkpos--; 
				}
				if (isset($this->OTLdata[$checkpos]) && $this->OTLdata[$checkpos]['uni']==0xFE92) {
					$this->OTLdata[$checkpos]['GPOSinfo']['kashida'] = 4;	// ******* Before preceding BAA
				}
			}

			// Priority 6	WAW (0648) FEEE; Ain (0639) FECA; Qaf (0642) FED6; Fa (0641) FED2
			// Final form
			// Connecting to previous character
			// Position: Before the character
			else if ($this->OTLdata[$i]['uni']==0xFEEE || $this->OTLdata[$i]['uni']==0xFECA || $this->OTLdata[$i]['uni']==0xFED6 || $this->OTLdata[$i]['uni']==0xFED2) {
				$this->OTLdata[$i]['GPOSinfo']['kashida'] = 3;
			}

			// Priority 7	Other connecting characters
			// Final form
			// Connecting to previous character
			// Position: Before the character
			/* This isn't in the spec, but using MS WORD as a basis, give a lower priority to the 3 characters already checked 
			   in (5) above. Test case: 
			   &#x62e;&#x652;&#x631;&#x64e;&#x649;&#x670;
			   &#x641;&#x64e;&#x62a;&#x64f;&#x630;&#x64e;&#x643;&#x651;&#x650;&#x631;
			*/

			if (!isset($this->OTLdata[$i]['GPOSinfo']['kashida'])) {
				if (strpos($this->GSUBdata[$this->GSUBfont]['finals'], $this->OTLdata[$i]['hex'])!==false) {	// ANY OTHER FINAL FORM
					$this->OTLdata[$i]['GPOSinfo']['kashida'] = 2;
				}
				else if (strpos('0FEAE 0FEF0 0FEF2',$this->OTLdata[$i]['hex'])!==false) {	// not already included in 5 above
					$this->OTLdata[$i]['GPOSinfo']['kashida'] = 1;
				}
			}
		}

		//-----------------------------------------------------------------------------------
		// d. Apply Presentation Forms GSUB Lookups (+ any discretionary) - Apply one at a time in Feature order
		//-----------------------------------------------------------------------------------
		$tags = 'rlig calt liga clig mset';

		$omittags = 'locl ccmp nukt akhn rphf rkrf pref blwf abvf half pstf cfar vatu cjct init medi fina isol med2 fin2 fin3 ljmo vjmo tjmo';
		$usetags = $tags;
		if(!empty($this->mpdf->OTLtags)) { 
			$usetags = $this->_applyTagSettings($tags, $GSUBFeatures, $omittags, false) ;
		}

		$ts = explode(' ',$usetags);
		foreach($ts AS $ut) {	//  - Apply one at a time in Feature order
			$this->_applyGSUBrules($ut, $GSUBscriptTag, $GSUBlangsys);
		}
		//-----------------------------------------------------------------------------------
		// e. NOT IN SPEC
		// If space precedes a mark -> substitute a &nbsp; before the Mark, to prevent line breaking Test: 
		//-----------------------------------------------------------------------------------
		for($ptr=1; $ptr<count($this->OTLdata); $ptr++) {
			if ($this->OTLdata[$ptr]['general_category'] == UCDN::UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK && $this->OTLdata[$ptr-1]['uni'] == 32) {
				$this->OTLdata[$ptr-1]['uni'] =  0xa0;
				$this->OTLdata[$ptr-1]['hex'] =  '000A0';
			}
		}
	}

	// 5(I). GSUB - Shaper - INDIC and SINHALA and KHMER
	//===================================
	else if ($this->shaper == 'I' || $this->shaper == 'K' || $this->shaper == 'S') {
		$this->restrictToSyllable = true;
		//-----------------------------------------------------------------------------------
		// a. First decompose/compose split mattras
		// (normalize) ??????? Nukta/Halant order etc ??????????????????????????????????????????????????????????????????????????
		//-----------------------------------------------------------------------------------
		for($ptr=0; $ptr<count($this->OTLdata); $ptr++) {
			$char = $this->OTLdata[$ptr]['uni'];
			$sub = INDIC::decompose_indic($char);
			if ($sub) {
				$newinfo = array();
				for($i=0;$i<count($sub);$i++) {
					$newinfo[$i] = array();
					$ucd_record = UCDN::get_ucd_record($sub[$i]);
					$newinfo[$i]['general_category'] = $ucd_record[0];
					$newinfo[$i]['bidi_type'] = $ucd_record[2];
					$charasstr = $this->unicode_hex($sub[$i]); 
					if (strpos($this->GlyphClassMarks, $charasstr)!==false) { $newinfo[$i]['group'] =  'M'; }
					else { $newinfo[$i]['group'] =  'C'; }
					$newinfo[$i]['uni'] =  $sub[$i];
					$newinfo[$i]['hex'] =  $charasstr;
				}
				array_splice($this->OTLdata, $ptr, 1, $newinfo);
				$ptr += count($sub)-1;
			}
			/* Only Composition-exclusion exceptions that we want to recompose. */
			if ($this->shaper == 'I') {
			  if ($char == 0x09AF && isset($this->OTLdata[$ptr + 1]) && $this->OTLdata[$ptr + 1]['uni'] == 0x09BC) { 
				$sub = 0x09DF; 
				$newinfo = array();
				$newinfo[0] = array();
				$ucd_record = UCDN::get_ucd_record($sub);
				$newinfo[0]['general_category'] = $ucd_record[0];
				$newinfo[0]['bidi_type'] = $ucd_record[2];
				$newinfo[0]['group'] =  'C';
				$newinfo[0]['uni'] =  $sub;
				$newinfo[0]['hex'] =  $this->unicode_hex($sub);
				array_splice($this->OTLdata, $ptr, 2, $newinfo);
			  }
			}
		}
		//-----------------------------------------------------------------------------------
		// b. Analyse characters - group as syllables/clusters (Indic); invalid diacritics; add dotted circle
		//-----------------------------------------------------------------------------------
		$indic_category_string = '';
		foreach($this->OTLdata AS $eid=>$c) {
			INDIC::set_indic_properties($this->OTLdata[$eid], $scriptblock );	// sets ['indic_category'] and ['indic_position']
			//$c['general_category']
			//$c['combining_class']
			//$c['uni'] =  $char;

			$indic_category_string .= INDIC::$indic_category_char[$this->OTLdata[$eid]['indic_category']];
		}

		$broken_syllables = false;
		if ($this->shaper == 'I') {
			INDIC::set_syllables($this->OTLdata, $indic_category_string, $broken_syllables);
		}
		else if ($this->shaper == 'S') {
			INDIC::set_syllables_sinhala($this->OTLdata, $indic_category_string, $broken_syllables);
		}
		else if ($this->shaper == 'K') {
			INDIC::set_syllables_khmer($this->OTLdata, $indic_category_string, $broken_syllables);
		}
		$indic_category_string = '';

		//-----------------------------------------------------------------------------------
		// c. Initial Re-ordering (Indic / Khmer / Sinhala)
		//-----------------------------------------------------------------------------------
		// Find base consonant
		// Decompose/compose and reorder Matras
		// Reorder marks to canonical order

		$indic_config = INDIC::$indic_configs[$scriptblock];
		$dottedcircle = false; 
		if ($broken_syllables) { 
			if ($this->mpdf->_charDefined($this->mpdf->fonts[$this->fontkey]['cw'],0x25CC) ) { 
				$dottedcircle = array();
				$ucd_record = UCDN::get_ucd_record(0x25CC);
				$dottedcircle[0]['general_category'] = $ucd_record[0];
				$dottedcircle[0]['bidi_type'] = $ucd_record[2];
				$dottedcircle[0]['group'] =  'C';
				$dottedcircle[0]['uni'] =  0x25CC;
				$dottedcircle[0]['indic_category'] = INDIC::OT_DOTTEDCIRCLE;
				$dottedcircle[0]['indic_position'] = INDIC::POS_BASE_C;

				$dottedcircle[0]['hex'] =  '025CC';		// TEMPORARY *****
			}
		}
		INDIC::initial_reordering($this->OTLdata, $this->GSUBdata[$this->GSUBfont], $broken_syllables, $indic_config, $scriptblock, $is_old_spec, $dottedcircle);

		//-----------------------------------------------------------------------------------
		// d. Apply initial and basic shaping forms GSUB Lookups (one at a time)
		//-----------------------------------------------------------------------------------
		if ($this->shaper == 'I' || $this->shaper == 'S') {
			$tags = 'locl ccmp nukt akhn rphf rkrf pref blwf half pstf vatu cjct';
		}
		else if ($this->shaper == 'K') {
			$tags = 'locl ccmp pref blwf abvf pstf cfar';
		}
		$this->_applyGSUBrulesIndic($tags, $GSUBscriptTag, $GSUBlangsys, $is_old_spec);

		//-----------------------------------------------------------------------------------
		// e. Final Re-ordering (Indic / Khmer / Sinhala)
		//-----------------------------------------------------------------------------------
		// Reorder matras
		// Reorder reph
		// Reorder pre-base reordering consonants: 

		INDIC::final_reordering($this->OTLdata, $this->GSUBdata[$this->GSUBfont], $indic_config, $scriptblock, $is_old_spec);

		//-----------------------------------------------------------------------------------
		// f. Apply 'init' feature to first syllable in word (indicated by ['mask']) INDIC::FLAG(INDIC::INIT);
		//-----------------------------------------------------------------------------------
		if ($this->shaper == 'I' || $this->shaper == 'S') {
			$tags = 'init';
			$this->_applyGSUBrulesIndic($tags, $GSUBscriptTag, $GSUBlangsys, $is_old_spec);
		}

		//-----------------------------------------------------------------------------------
		// g. Apply Presentation Forms GSUB Lookups (+ any discretionary)
		//-----------------------------------------------------------------------------------
		$tags = 'pres abvs blws psts haln rlig calt liga clig mset';

		$omittags = 'locl ccmp nukt akhn rphf rkrf pref blwf abvf half pstf cfar vatu cjct init medi fina isol med2 fin2 fin3 ljmo vjmo tjmo';
		$usetags = $tags;
		if(!empty($this->mpdf->OTLtags)) { 
			$usetags = $this->_applyTagSettings($tags, $GSUBFeatures, $omittags, false) ;
		}
		if ($this->shaper == 'K') { 	// Features are applied one at a time, working through each codepoint
			$this->_applyGSUBrulesSingly($usetags, $GSUBscriptTag, $GSUBlangsys);
		}
		else {
			$this->_applyGSUBrules($usetags, $GSUBscriptTag, $GSUBlangsys);
		}
		$this->restrictToSyllable = false;
	}


	// 5(M). GSUB - Shaper - MYANMAR (ONLY mym2)
	//==============================
	// NB Old style 'mymr' is left to go through the default shaper
	else if ($this->shaper == 'M') {
		$this->restrictToSyllable = true;
		//-----------------------------------------------------------------------------------
		// a. Analyse characters - group as syllables/clusters (Myanmar); invalid diacritics; add dotted circle
		//-----------------------------------------------------------------------------------
		$myanmar_category_string = '';
		foreach($this->OTLdata AS $eid=>$c) {
			MYANMAR::set_myanmar_properties($this->OTLdata[$eid]);	// sets ['myanmar_category'] and ['myanmar_position']
			$myanmar_category_string .= MYANMAR::$myanmar_category_char[$this->OTLdata[$eid]['myanmar_category']];
		}
		$broken_syllables = false;
		MYANMAR::set_syllables($this->OTLdata, $myanmar_category_string, $broken_syllables);
		$myanmar_category_string = '';

		//-----------------------------------------------------------------------------------
		// b. Re-ordering (Myanmar mym2)
		//-----------------------------------------------------------------------------------
		$dottedcircle = false; 
		if ($broken_syllables) { 
			if ($this->mpdf->_charDefined($this->mpdf->fonts[$this->fontkey]['cw'],0x25CC) ) { 
				$dottedcircle = array();
				$ucd_record = UCDN::get_ucd_record(0x25CC);
				$dottedcircle[0]['general_category'] = $ucd_record[0];
				$dottedcircle[0]['bidi_type'] = $ucd_record[2];
				$dottedcircle[0]['group'] =  'C';
				$dottedcircle[0]['uni'] =  0x25CC;
				$dottedcircle[0]['myanmar_category'] = MYANMAR::OT_DOTTEDCIRCLE;
				$dottedcircle[0]['myanmar_position'] = MYANMAR::POS_BASE_C;
				$dottedcircle[0]['hex'] =  '025CC';
			}
		}
		MYANMAR::reordering($this->OTLdata, $this->GSUBdata[$this->GSUBfont], $broken_syllables, $dottedcircle);

		//-----------------------------------------------------------------------------------
		// c. Apply initial and basic shaping forms GSUB Lookups (one at a time)
		//-----------------------------------------------------------------------------------

		$tags = 'locl ccmp rphf pref blwf pstf';
		$this->_applyGSUBrulesMyanmar($tags, $GSUBscriptTag, $GSUBlangsys);

		//-----------------------------------------------------------------------------------
		// d. Apply Presentation Forms GSUB Lookups (+ any discretionary)
		//-----------------------------------------------------------------------------------
		$tags = 'pres abvs blws psts haln rlig calt liga clig mset';
		$omittags = 'locl ccmp nukt akhn rphf rkrf pref blwf abvf half pstf cfar vatu cjct init medi fina isol med2 fin2 fin3 ljmo vjmo tjmo';
		$usetags = $tags;
		if(!empty($this->mpdf->OTLtags)) { 
			$usetags = $this->_applyTagSettings($tags, $GSUBFeatures, $omittags, false) ;
		}
		$this->_applyGSUBrules($usetags, $GSUBscriptTag, $GSUBlangsys);
		$this->restrictToSyllable = false;
	}


	// 5(E). GSUB - Shaper - SEA South East Asian (New Tai Lue, Cham, Tai Tam)
	//==============================
	else if ($this->shaper == 'E') {
      /* HarfBuzz says: If the designer designed the font for the 'DFLT' script,
       * use the default shaper.  Otherwise, use the SEA shaper.
       * Note that for some simple scripts, there may not be *any*
       * GSUB/GPOS needed, so there may be no scripts found! */

		$this->restrictToSyllable = true;
		//-----------------------------------------------------------------------------------
		// a. Analyse characters - group as syllables/clusters (Indic); invalid diacritics; add dotted circle
		//-----------------------------------------------------------------------------------
		$sea_category_string = '';
		foreach($this->OTLdata AS $eid=>$c) {
			SEA::set_sea_properties($this->OTLdata[$eid], $scriptblock );	// sets ['sea_category'] and ['sea_position']
			//$c['general_category']
			//$c['combining_class']
			//$c['uni'] =  $char;

			$sea_category_string .= SEA::$sea_category_char[$this->OTLdata[$eid]['sea_category']];
		}

		$broken_syllables = false;
		SEA::set_syllables($this->OTLdata, $sea_category_string, $broken_syllables);
		$sea_category_string = '';

		//-----------------------------------------------------------------------------------
		// b. Apply locl and ccmp shaping forms - before initial re-ordering; GSUB Lookups (one at a time)
		//-----------------------------------------------------------------------------------
		$tags = 'locl ccmp';
		$this->_applyGSUBrulesSingly($tags, $GSUBscriptTag, $GSUBlangsys);

		//-----------------------------------------------------------------------------------
		// c. Initial Re-ordering
		//-----------------------------------------------------------------------------------
		// Find base consonant
		// Decompose/compose and reorder Matras
		// Reorder marks to canonical order

		$dottedcircle = false; 
		if ($broken_syllables) { 
			if ($this->mpdf->_charDefined($this->mpdf->fonts[$this->fontkey]['cw'],0x25CC) ) { 
				$dottedcircle = array();
				$ucd_record = UCDN::get_ucd_record(0x25CC);
				$dottedcircle[0]['general_category'] = $ucd_record[0];
				$dottedcircle[0]['bidi_type'] = $ucd_record[2];
				$dottedcircle[0]['group'] =  'C';
				$dottedcircle[0]['uni'] =  0x25CC;
				$dottedcircle[0]['sea_category'] = SEA::OT_GB;
				$dottedcircle[0]['sea_position'] = SEA::POS_BASE_C;

				$dottedcircle[0]['hex'] =  '025CC';		// TEMPORARY *****
			}
		}
		SEA::initial_reordering($this->OTLdata, $this->GSUBdata[$this->GSUBfont], $broken_syllables, $scriptblock, $dottedcircle);

		//-----------------------------------------------------------------------------------
		// d. Apply basic shaping forms GSUB Lookups (one at a time)
		//-----------------------------------------------------------------------------------
		$tags = 'pref abvf blwf pstf';
		$this->_applyGSUBrulesSingly($tags, $GSUBscriptTag, $GSUBlangsys);

		//-----------------------------------------------------------------------------------
		// e. Final Re-ordering
		//-----------------------------------------------------------------------------------

		SEA::final_reordering($this->OTLdata, $this->GSUBdata[$this->GSUBfont], $scriptblock);

		//-----------------------------------------------------------------------------------
		// f. Apply Presentation Forms GSUB Lookups (+ any discretionary)
		//-----------------------------------------------------------------------------------
		$tags = 'pres abvs blws psts';

		$omittags = 'locl ccmp nukt akhn rphf rkrf pref blwf abvf half pstf cfar vatu cjct init medi fina isol med2 fin2 fin3 ljmo vjmo tjmo';
		$usetags = $tags;
		if(!empty($this->mpdf->OTLtags)) { 
			$usetags = $this->_applyTagSettings($tags, $GSUBFeatures, $omittags, false) ;
		}
		$this->_applyGSUBrules($usetags, $GSUBscriptTag, $GSUBlangsys);
		$this->restrictToSyllable = false;
	}


	// 5(D). GSUB - Shaper - DEFAULT (including THAI and LAO and MYANMAR v1 [mymr] and TIBETAN)
	//==============================
	else {	// DEFAULT
		//-----------------------------------------------------------------------------------
		// a. First decompose/compose in Thai / Lao - Tibetan
		//-----------------------------------------------------------------------------------
		// Decomposition for THAI or LAO
		/* This function implements the shaping logic documented here:
		 *
		 *   http://linux.thai.net/~thep/th-otf/shaping.html
		 *
		 * The first shaping rule listed there is needed even if the font has Thai
		 * OpenType tables. 
		 *
		 *
		 * The following is NOT specified in the MS OT Thai spec, however, it seems
		 * to be what Uniscribe and other engines implement.  According to Eric Muller:
		 *
		 * When you have a SARA AM, decompose it in NIKHAHIT + SARA AA, *and* move the
		 * NIKHAHIT backwards over any tone mark (0E48-0E4B).
		 *
		 * <0E14, 0E4B, 0E33> -> <0E14, 0E4D, 0E4B, 0E32>
		 *
		 * This reordering is legit only when the NIKHAHIT comes from a SARA AM, not
		 * when it's there to start with. The string <0E14, 0E4B, 0E4D> is probably
		 * not what a user wanted, but the rendering is nevertheless nikhahit above
		 * chattawa.
		 *
		 * Same for Lao.
		 *
		 *			Thai		Lao
		 * SARA AM:		U+0E33	U+0EB3
		 * SARA AA:		U+0E32	U+0EB2
		 * Nikhahit:	U+0E4D	U+0ECD
		 *
		 * Testing shows that Uniscribe reorder the following marks:
		 * Thai:	<0E31,0E34..0E37,0E47..0E4E>
		 * Lao:	<0EB1,0EB4..0EB7,0EC7..0ECE>
		 *
		 * Lao versions are the same as Thai + 0x80.
		 */
		if ($this->shaper == 'T' || $this->shaper == 'L') {
			for($ptr=0; $ptr<count($this->OTLdata); $ptr++) {
				$char = $this->OTLdata[$ptr]['uni'];
    				if (($char & ~0x0080) == 0x0E33) {	// if SARA_AM (U+0E33 or U+0EB3)

					$NIKHAHIT = $char + 0x1A;
					$SARA_AA = $char - 1;
					$sub = array($SARA_AA, $NIKHAHIT);

					$newinfo = array();
					$ucd_record = UCDN::get_ucd_record($sub[0]);
					$newinfo[0]['general_category'] = $ucd_record[0];
					$newinfo[0]['bidi_type'] = $ucd_record[2];
					$charasstr = $this->unicode_hex($sub[0]); 
					if (strpos($this->GlyphClassMarks, $charasstr)!==false) { $newinfo[0]['group'] =  'M'; }
					else { $newinfo[0]['group'] =  'C'; }
					$newinfo[0]['uni'] =  $sub[0];
					$newinfo[0]['hex'] =  $charasstr;
					$this->OTLdata[$ptr] = $newinfo[0];	// Substitute SARA_AM => SARA_AA

					$ntones = 0;	// number of (preceding) tone marks
					// IS_TONE_MARK ((x) & ~0x0080, 0x0E34 - 0x0E37, 0x0E47 - 0x0E4E, 0x0E31)
					while (isset($this->OTLdata[$ptr - 1 - $ntones]) 
						&& (
							($this->OTLdata[$ptr - 1 - $ntones]['uni'] & ~0x0080) == 0x0E31 ||

							(($this->OTLdata[$ptr - 1 - $ntones]['uni'] & ~0x0080) >= 0x0E34 &&
							($this->OTLdata[$ptr - 1 - $ntones]['uni'] & ~0x0080) <= 0x0E37) ||

							(($this->OTLdata[$ptr - 1 - $ntones]['uni'] & ~0x0080) >= 0x0E47 &&
							($this->OTLdata[$ptr - 1 - $ntones]['uni'] & ~0x0080) <= 0x0E4E)
						)
					)  { $ntones++; }

					$newinfo = array();
					$ucd_record = UCDN::get_ucd_record($sub[1]);
					$newinfo[0]['general_category'] = $ucd_record[0];
					$newinfo[0]['bidi_type'] = $ucd_record[2];
					$charasstr = $this->unicode_hex($sub[1]); 
					if (strpos($this->GlyphClassMarks, $charasstr)!==false) { $newinfo[0]['group'] =  'M'; }
					else { $newinfo[0]['group'] =  'C'; }
					$newinfo[0]['uni'] =  $sub[1];
					$newinfo[0]['hex'] =  $charasstr;
					// Insert NIKAHIT
					array_splice($this->OTLdata, $ptr - $ntones, 0, $newinfo);

					$ptr++;
				}
			}
		}

		if ($scriptblock == UCDN::SCRIPT_TIBETAN) {
			// =========================
			// Reordering TIBETAN
			// =========================
			// Tibetan does not need to need a shaper generally, as long as characters are presented in the correct order
			// so we will do one minor change here:
           		// From ICU: If the present character is a number, and the next character is a pre-number combining mark
           		 // then the two characters are reordered
			// From MS OTL spec the following are Digit modifiers (Md): 0F180F19, 0F3E0F3F
			// Digits: 0F200F33
			// On testing only 0x0F3F (pre-based mark) seems to need re-ordering
			for($ptr=0; $ptr<count($this->OTLdata)-1; $ptr++) {
    				if (INDIC::in_range($this->OTLdata[$ptr]['uni'], 0x0F20, 0x0F33) && $this->OTLdata[$ptr+1]['uni'] == 0x0F3F ) {
					$tmp = $this->OTLdata[$ptr+1];
					$this->OTLdata[$ptr+1] = $this->OTLdata[$ptr];
					$this->OTLdata[$ptr] = $tmp;
				}
			}


			// =========================
			// Decomposition for TIBETAN
			// =========================
/* Recommended, but does not seem to change anything...
			for($ptr=0; $ptr<count($this->OTLdata); $ptr++) {
				$char = $this->OTLdata[$ptr]['uni'];
				$sub = INDIC::decompose_indic($char);
				if ($sub) {
					$newinfo = array();
					for($i=0;$i<count($sub);$i++) {
						$newinfo[$i] = array();
						$ucd_record = UCDN::get_ucd_record($sub[$i]);
						$newinfo[$i]['general_category'] = $ucd_record[0];
						$newinfo[$i]['bidi_type'] = $ucd_record[2];
						$charasstr = $this->unicode_hex($sub[$i]); 
						if (strpos($this->GlyphClassMarks, $charasstr)!==false) { $newinfo[$i]['group'] =  'M'; }
						else { $newinfo[$i]['group'] =  'C'; }
						$newinfo[$i]['uni'] =  $sub[$i];
						$newinfo[$i]['hex'] =  $charasstr;
					}
					array_splice($this->OTLdata, $ptr, 1, $newinfo);
					$ptr += count($sub)-1;
				}
			}
*/

		}


		//-----------------------------------------------------------------------------------
		// b. Apply all GSUB Lookups (in order specified in lookup list)
		//-----------------------------------------------------------------------------------
		$tags = 'locl ccmp pref blwf abvf pstf pres abvs blws psts haln rlig calt liga clig mset  RQD';
		// pref blwf abvf pstf required for Tibetan
		// " RQD" is a non-standard tag in Garuda font - presumably intended to be used by default ? "ReQuireD"
		// Being a 3 letter tag is non-standard, and does not allow it to be set by font-feature-settings


		/* ?Add these until shapers witten?
		Hangul: 	ljmo vjmo tjmo
		*/

		$omittags = '';
		$useGSUBtags = $tags;
		if(!empty($this->mpdf->OTLtags)) { 
			$useGSUBtags = $this->_applyTagSettings($tags, $GSUBFeatures, $omittags, false) ;
		}
		// APPLY GSUB rules (as long as not Latin + SmallCaps - but not OTL smcp)
		if (!(($this->mpdf->textvar & FC_SMALLCAPS) && $scriptblock == UCDN::SCRIPT_LATIN && strpos($useGSUBtags, 'smcp')===false)) {
			$this->_applyGSUBrules($useGSUBtags, $GSUBscriptTag, $GSUBlangsys);
		}
	}


  }

	// Shapers - KHMER & THAI & LAO - Replace Word boundary marker with U+200B
	// Also TIBETAN (no shaper)
	//=======================================================
	if (($this->shaper == "K" || $this->shaper == "T" || $this->shaper == "L") || $scriptblock == UCDN::SCRIPT_TIBETAN ) {
		// Set up properties to insert a U+200B character
		$newinfo = array();
		//$newinfo[0] = array('general_category' => 1, 'bidi_type' => 14, 'group' => 'S', 'uni' => 0x200B, 'hex' => '0200B');
		$newinfo[0] = array(
			'general_category' => UCDN::UNICODE_GENERAL_CATEGORY_FORMAT, 
			'bidi_type' => UCDN::BIDI_CLASS_BN, 
			'group' => 'S', 'uni' => 0x200B, 'hex' => '0200B');
		// Then insert U+200B at (after) all word end boundaries
		for ($i=count($this->OTLdata)-1;$i>0;$i--) {
			// Make sure after GSUB that wordend has not been moved - check next char is not in the same syllable
			if (isset($this->OTLdata[$i]['wordend']) && $this->OTLdata[$i]['wordend'] &&
					isset($this->OTLdata[$i+1]['uni']) && (!isset($this->OTLdata[$i+1]['syllable']) || !isset($this->OTLdata[$i+1]['syllable']) || $this->OTLdata[$i+1]['syllable']!=$this->OTLdata[$i]['syllable'])) { 
				array_splice($this->OTLdata, $i+1, 0, $newinfo);
				$this->_updateLigatureMarks($i, 1);
			}
			else if ($this->OTLdata[$i]['uni']==0x2e) {	// Word end if Full-stop.
				array_splice($this->OTLdata, $i+1, 0, $newinfo);
				$this->_updateLigatureMarks($i, 1);
			}
		}
	}


	// Shapers - INDIC & ARABIC & KHMER & SINHALA  & MYANMAR - Remove ZWJ and ZWNJ
	//=======================================================
	if ($this->shaper == 'I' || $this->shaper == 'S' || $this->shaper == 'A' || $this->shaper == 'K' || $this->shaper == 'M') {
		// Remove ZWJ and ZWNJ
		for ($i=0;$i<count($this->OTLdata);$i++) {
			if ($this->OTLdata[$i]['uni']==8204 || $this->OTLdata[$i]['uni']==8205) {
				array_splice($this->OTLdata, $i, 1);
				$this->_updateLigatureMarks($i, -1);
			}
		}
	}

//print_r($this->OTLdata); echo '<br />';
//print_r($this->assocMarks);  echo '<br />';
//print_r($this->assocLigs); exit;

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//////////       GPOS          /////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

  if (($useOTL & 0xFF) && $GPOSscriptTag && $GPOSlangsys && $GPOSFeatures) {
	$this->Entry = array();
	$this->Exit = array();

	// 6. Load GPOS data, Coverage & Lookups
	//=================================================================
	if (!isset($this->GPOSdata[$this->fontkey])) {
		include(_MPDF_TTFONTDATAPATH.$this->mpdf->CurrentFont['fontkey'].'.GPOSdata.php'); 
		$this->LuCoverage = $this->GPOSdata[$this->fontkey]['LuCoverage'] = $LuCoverage;
	}
	else {
		$this->LuCoverage = $this->GPOSdata[$this->fontkey]['LuCoverage'];
	}

	$this->GPOSLookups = $this->mpdf->CurrentFont['GPOSLookups'];


	// 7. Select Feature tags to use (incl optional)
	//==============================
	$tags = 'abvm blwm mark mkmk curs cpsp dist requ';	// Default set
	/* 'requ' is not listed in the Microsoft registry of Feature tags
		Found in Arial Unicode MS, it repositions the baseline for punctuation in Kannada script */

	// ZZZ96
	// Set kern to be included by default in non-Latin script (? just when shapers used)
	// Kern is used in some fonts to reposition marks etc. and is essential for correct display
	//if ($this->shaper) {$tags .= ' kern'; }
	if ($scriptblock != UCDN::SCRIPT_LATIN) { $tags .= ' kern'; }

	$omittags = '';
	$usetags = $tags;
	if(!empty($this->mpdf->OTLtags)) { 
		$usetags = $this->_applyTagSettings($tags, $GPOSFeatures, $omittags, false) ;
	}



	// 8. Get GPOS LookupList from Feature tags
	//==============================
	$LookupList = array();
	foreach($GPOSFeatures AS $tag=>$arr) {
		if (strpos($usetags, $tag)!==false) {
			foreach($arr AS $lu) { $LookupList[$lu] = $tag; }
		}
	}
	ksort($LookupList);


	// 9. Apply GPOS Lookups (in order specified in lookup list but selecting from specified tags)
	//==============================

	// APPLY THE GPOS RULES (as long as not Latin + SmallCaps - but not OTL smcp)
	if (!(($this->mpdf->textvar & FC_SMALLCAPS) && $scriptblock == UCDN::SCRIPT_LATIN && strpos($useGSUBtags, 'smcp')===false)) {
		$this->_applyGPOSrules($LookupList, $is_old_spec);
		// (sets: $this->OTLdata[n]['GPOSinfo'] XPlacement YPlacement XAdvance Entry Exit )
	}

	// 10. Process cursive text
	//==============================
	if (count($this->Entry) || count($this->Exit)) {
		// RTL
		$incurs = false;
		for ($i=(count($this->OTLdata)-1);$i>=0;$i--) {
			if (isset($this->Entry[$i]) && isset($this->Entry[$i]['Y']) && $this->Entry[$i]['dir']=='RTL') {
				$nextbase = $i-1;	// Set as next base ignoring marks (next base reading RTL in logical oder
				while(isset($this->OTLdata[$nextbase]['hex']) && strpos($this->GlyphClassMarks, $this->OTLdata[$nextbase]['hex'])!==false) { $nextbase--; }
				if (isset($this->Exit[$nextbase]) && isset($this->Exit[$nextbase]['Y']) ) {
					$diff = $this->Entry[$i]['Y'] - $this->Exit[$nextbase]['Y'];
					if ($incurs===false) { $incurs = $diff; }
					else { $incurs += $diff; }
					for ($j=($i-1);$j>=$nextbase;$j--) {
						if (isset($this->OTLdata[$j]['GPOSinfo']['YPlacement'])) { $this->OTLdata[$j]['GPOSinfo']['YPlacement'] += $incurs; }
						else { $this->OTLdata[$j]['GPOSinfo']['YPlacement'] = $incurs; }
					}
					if (isset($this->Exit[$i]['X']) && isset($this->Entry[$nextbase]['X']) ) {
						$adj = -($this->Entry[$i]['X'] - $this->Exit[$nextbase]['X']);
						// If XAdvance is aplied - in order for PDF to position the Advance correctly need to place it on:
						// in RTL - the current glyph or the last of any associated marks
						if (isset($this->OTLdata[$nextbase+1]['GPOSinfo']['XAdvance'])) { $this->OTLdata[$nextbase+1]['GPOSinfo']['XAdvance'] += $adj; }
						else { $this->OTLdata[$nextbase+1]['GPOSinfo']['XAdvance'] = $adj; }
					}
				}
				else { $incurs = false; }
			}
			else if (strpos($this->GlyphClassMarks, $this->OTLdata[$i]['hex'])!==false) { continue; } // ignore Marks
			else { $incurs = false; }
		}
		// LTR
		$incurs = false;
		for ($i=0;$i<count($this->OTLdata);$i++) {
			if (isset($this->Exit[$i]) && isset($this->Exit[$i]['Y']) && $this->Exit[$i]['dir']=='LTR') {
				$nextbase = $i+1;	// Set as next base ignoring marks
				while(strpos($this->GlyphClassMarks, $this->OTLdata[$nextbase]['hex'])!==false) { $nextbase++; }
				if (isset($this->Entry[$nextbase]) && isset($this->Entry[$nextbase]['Y']) ) {

					$diff = $this->Exit[$i]['Y'] - $this->Entry[$nextbase]['Y'];
					if ($incurs===false) { $incurs = $diff; }
					else { $incurs += $diff; }
					for ($j=($i+1);$j<=$nextbase;$j++) {
						if (isset($this->OTLdata[$j]['GPOSinfo']['YPlacement'])) { $this->OTLdata[$j]['GPOSinfo']['YPlacement'] += $incurs; }
						else { $this->OTLdata[$j]['GPOSinfo']['YPlacement'] = $incurs; }
					}
					if (isset($this->Exit[$i]['X']) && isset($this->Entry[$nextbase]['X']) ) {
						$adj = -($this->Exit[$i]['X'] - $this->Entry[$nextbase]['X']);
						// If XAdvance is aplied - in order for PDF to position the Advance correctly need to place it on:
						// in LTR - the next glyph, ignoring marks
						if (isset($this->OTLdata[$nextbase]['GPOSinfo']['XAdvance'])) { $this->OTLdata[$nextbase]['GPOSinfo']['XAdvance'] += $adj; }
						else { $this->OTLdata[$nextbase]['GPOSinfo']['XAdvance'] = $adj; }
					}
				}
				else { $incurs = false; }
			}
			else if (strpos($this->GlyphClassMarks, $this->OTLdata[$i]['hex'])!==false) { continue; } // ignore Marks
			else { $incurs = false; }
		}
	}




  }	// end GPOS

	if ($this->debugOTL) { $this->_dumpproc('END', '-', '-', '-', '-', 0, '-', 0); exit; }

	$this->schOTLdata[$sch] = $this->OTLdata;
	$this->OTLdata = array();
}	// END foreach subchunk


	// 11. Re-assemble and return text string
	//==============================
	$newGPOSinfo = array();
	$newOTLdata = array();
	$newchar_data = array();
	$newgroup = '';
	$e = '';
	$ectr = 0;

	for($sch=0;$sch<=$subchunk;$sch++) {
		for ($i=0;$i<count($this->schOTLdata[$sch]);$i++) {
			if (isset($this->schOTLdata[$sch][$i]['GPOSinfo'])) {
				$newGPOSinfo[$ectr] = $this->schOTLdata[$sch][$i]['GPOSinfo'];
			}
			$newchar_data[$ectr] = array('bidi_class' => $this->schOTLdata[$sch][$i]['bidi_type'], 'uni' => $this->schOTLdata[$sch][$i]['uni']);
			$newgroup .= $this->schOTLdata[$sch][$i]['group'];
			$e.=code2utf($this->schOTLdata[$sch][$i]['uni']);
			if (isset($this->mpdf->CurrentFont['subset'])) {
				$this->mpdf->CurrentFont['subset'][$this->schOTLdata[$sch][$i]['uni']] = $this->schOTLdata[$sch][$i]['uni'];
			}
			$ectr++;
		}

	}
	$this->OTLdata['GPOSinfo'] = $newGPOSinfo;
	$this->OTLdata['char_data'] = $newchar_data ;
	$this->OTLdata['group'] = $newgroup ;


	// This leaves OTLdata::GPOSinfo, ::bidi_type, & ::group

	return $e;

}

function _applyTagSettings($tags, $Features, $omittags='', $onlytags=false) {
		if (empty($this->mpdf->OTLtags['Plus']) && empty($this->mpdf->OTLtags['Minus']) && empty($this->mpdf->OTLtags['FFPlus']) && empty($this->mpdf->OTLtags['FFMinus'])) { return $tags; }

		// Use $tags as starting point
		$usetags = $tags;

		// Only set / unset tags which are in the font
		// Ignore tags which are in $omittags
		// If $onlytags, then just unset tags which are already in the Tag list

		$fp = $fm = $ffp = $ffm = '';

		// Font features to enable - set by font-variant-xx
		if (isset($this->mpdf->OTLtags['Plus'])) $fp = $this->mpdf->OTLtags['Plus'];
		preg_match_all('/([a-zA-Z0-9]{4})/',$fp,$m);
		for($i=0;$i<count($m[0]);$i++) {
			$t = $m[1][$i];
			// Is it a valid tag?
			if(isset($Features[$t]) && strpos($omittags,$t)===false && (!$onlytags || strpos($tags,$t)!==false )) {
				$usetags .= ' '.$t;
			}
		}

		// Font features to disable - set by font-variant-xx
		if (isset($this->mpdf->OTLtags['Minus'])) $fm = $this->mpdf->OTLtags['Minus'];
		preg_match_all('/([a-zA-Z0-9]{4})/',$fm,$m);
		for($i=0;$i<count($m[0]);$i++) {
			$t = $m[1][$i];
			// Is it a valid tag?
			if(isset($Features[$t]) && strpos($omittags,$t)===false && (!$onlytags || strpos($tags,$t)!==false )) {
				$usetags = str_replace($t,'',$usetags);
			}
		}

		// Font features to enable - set by font-feature-settings
		if (isset($this->mpdf->OTLtags['FFPlus'])) $ffp = $this->mpdf->OTLtags['FFPlus'];	// Font Features - may include integer: salt4
		preg_match_all('/([a-zA-Z0-9]{4})([\d+]*)/',$ffp,$m);
		for($i=0;$i<count($m[0]);$i++) {
			$t = $m[1][$i];
			// Is it a valid tag?
			if(isset($Features[$t]) && strpos($omittags,$t)===false && (!$onlytags || strpos($tags,$t)!==false )) {
				$usetags .= ' '.$m[0][$i];		//  - may include integer: salt4
			}
		}

		// Font features to disable - set by font-feature-settings
		if (isset($this->mpdf->OTLtags['FFMinus'])) $ffm = $this->mpdf->OTLtags['FFMinus'];
		preg_match_all('/([a-zA-Z0-9]{4})/',$ffm,$m);
		for($i=0;$i<count($m[0]);$i++) {
			$t = $m[1][$i];
			// Is it a valid tag?
			if(isset($Features[$t]) && strpos($omittags,$t)===false && (!$onlytags || strpos($tags,$t)!==false )) {
				$usetags = str_replace($t,'',$usetags);
			}
		}
		return $usetags; 
}

function _applyGSUBrules($usetags, $scriptTag, $langsys) {
	// Features from all Tags are applied together, in Lookup List order.
	// For Indic - should be applied one syllable at a time	
	// - Implemented in functions checkContextMatch and checkContextMatchMultiple by failing to match if outside scope of current 'syllable'
	// if $this->restrictToSyllable is true

	$GSUBFeatures = $this->mpdf->CurrentFont['GSUBFeatures'][$scriptTag][$langsys];
	$LookupList = array();
	foreach($GSUBFeatures AS $tag=>$arr) {
		if (strpos($usetags, $tag)!==false) {
			foreach($arr AS $lu) { $LookupList[$lu] = $tag; }
		}
	}
	ksort($LookupList);

	foreach($LookupList AS $lu=>$tag) {
		$Type = $this->GSUBLookups[$lu]['Type'];
		$Flag = $this->GSUBLookups[$lu]['Flag'];
		$MarkFilteringSet = $this->GSUBLookups[$lu]['MarkFilteringSet'];
		$tagInt = 1;
		if (preg_match('/'.$tag.'([0-9]{1,2})/', $usetags, $m)) {
			$tagInt = $m[1];
		}
		$ptr = 0;
		// Test each glyph sequentially
		while($ptr < (count($this->OTLdata))) {	// whilst there is another glyph ..0064
			$currGlyph = $this->OTLdata[$ptr]['hex'];
			$currGID = $this->OTLdata[$ptr]['uni'];
			$shift = 1;
			foreach($this->GSUBLookups[$lu]['Subtables'] AS $c=>$subtable_offset) {
				// NB Coverage only looks at glyphs for position 1 (esp. 7.3 and 8.3)
				if (isset($this->GSLuCoverage[$lu][$c][$currGID])) {
					// Get rules from font GSUB subtable
					$shift = $this->_applyGSUBsubtable($lu, $c, $ptr, $currGlyph, $currGID, ($subtable_offset - $this->GSUB_offset), $Type, $Flag, $MarkFilteringSet, $this->GSLuCoverage[$lu][$c], 0, $tag, 0, $tagInt);

					if ($shift) { break; }
				}
			}
			if ($shift == 0) { $shift = 1; }
			$ptr += $shift;

		}
	}
}

function _applyGSUBrulesSingly($usetags, $scriptTag, $langsys) {
	// Features are applied one at a time, working through each codepoint

	$GSUBFeatures = $this->mpdf->CurrentFont['GSUBFeatures'][$scriptTag][$langsys];

	$tags = explode(' ',$usetags);
	foreach($tags AS $usetag) {
		$LookupList = array();
		foreach($GSUBFeatures AS $tag=>$arr) {
			if (strpos($usetags, $tag)!==false) {
				foreach($arr AS $lu) { $LookupList[$lu] = $tag; }
			}
		}
		ksort($LookupList);

		$ptr = 0;
		// Test each glyph sequentially
		while($ptr < (count($this->OTLdata))) {	// whilst there is another glyph ..0064
			$currGlyph = $this->OTLdata[$ptr]['hex'];
			$currGID = $this->OTLdata[$ptr]['uni'];
			$shift = 1;

			foreach($LookupList AS $lu=>$tag) {
				$Type = $this->GSUBLookups[$lu]['Type'];
				$Flag = $this->GSUBLookups[$lu]['Flag'];
				$MarkFilteringSet = $this->GSUBLookups[$lu]['MarkFilteringSet'];
				$tagInt = 1;
				if (preg_match('/'.$tag.'([0-9]{1,2})/', $usetags, $m)) {
					$tagInt = $m[1];
				}

				foreach($this->GSUBLookups[$lu]['Subtables'] AS $c=>$subtable_offset) {
					// NB Coverage only looks at glyphs for position 1 (esp. 7.3 and 8.3)
					if (isset($this->GSLuCoverage[$lu][$c][$currGID])) {
						// Get rules from font GSUB subtable
						$shift = $this->_applyGSUBsubtable($lu, $c, $ptr, $currGlyph, $currGID, ($subtable_offset - $this->GSUB_offset), $Type, $Flag, $MarkFilteringSet, $this->GSLuCoverage[$lu][$c], 0, $tag, 0, $tagInt);

						if ($shift) { break 2; }
					}
				}
			}
			if ($shift == 0) { $shift = 1; }
			$ptr += $shift;

		}
	}
}

function _applyGSUBrulesMyanmar($usetags, $scriptTag, $langsys) {
	// $usetags = locl ccmp rphf pref blwf pstf';
	// applied to all characters

	$GSUBFeatures = $this->mpdf->CurrentFont['GSUBFeatures'][$scriptTag][$langsys];

	// ALL should be applied one syllable at a time	
	// Implemented in functions checkContextMatch and checkContextMatchMultiple by failing to match if outside scope of current 'syllable'
	$tags = explode(' ',$usetags);
	foreach($tags AS $usetag) {

		$LookupList = array();
		foreach($GSUBFeatures AS $tag=>$arr) {
			if ($tag==$usetag) {
				foreach($arr AS $lu) { $LookupList[$lu] = $tag; }
			}
		}
		ksort($LookupList);

		foreach($LookupList AS $lu=>$tag) {

			$Type = $this->GSUBLookups[$lu]['Type'];
			$Flag = $this->GSUBLookups[$lu]['Flag'];
			$MarkFilteringSet = $this->GSUBLookups[$lu]['MarkFilteringSet'];
			$tagInt = 1;
			if (preg_match('/'.$tag.'([0-9]{1,2})/', $usetags, $m)) {
				$tagInt = $m[1];
			}

			$ptr = 0;
			// Test each glyph sequentially
			while($ptr < (count($this->OTLdata))) {	// whilst there is another glyph ..0064
				$currGlyph = $this->OTLdata[$ptr]['hex'];
				$currGID = $this->OTLdata[$ptr]['uni'];
				$shift = 1;
				foreach($this->GSUBLookups[$lu]['Subtables'] AS $c=>$subtable_offset) {
					// NB Coverage only looks at glyphs for position 1 (esp. 7.3 and 8.3)
					if (isset($this->GSLuCoverage[$lu][$c][$currGID])) {
						// Get rules from font GSUB subtable
						$shift = $this->_applyGSUBsubtable($lu, $c, $ptr, $currGlyph, $currGID, ($subtable_offset - $this->GSUB_offset), $Type, $Flag, $MarkFilteringSet, $this->GSLuCoverage[$lu][$c], 0, $usetag, 0, $tagInt);

						if ($shift) { break; }
					}
				}
				if ($shift == 0) { $shift = 1; }
				$ptr += $shift;

			}
		}
	}
}

function _applyGSUBrulesIndic($usetags, $scriptTag, $langsys, $is_old_spec) {
	// $usetags = 'locl ccmp nukt akhn rphf rkrf pref blwf half pstf vatu cjct'; then later - init
	// rphf, pref, blwf, half, abvf, pstf, and init are only applied where ['mask'] indicates:  INDIC::FLAG(INDIC::RPHF);
	// The rest are applied to all characters

	$GSUBFeatures = $this->mpdf->CurrentFont['GSUBFeatures'][$scriptTag][$langsys];

	// ALL should be applied one syllable at a time	
	// Implemented in functions checkContextMatch and checkContextMatchMultiple by failing to match if outside scope of current 'syllable'
	$tags = explode(' ',$usetags);
	foreach($tags AS $usetag) {

		$LookupList = array();
		foreach($GSUBFeatures AS $tag=>$arr) {
			if ($tag==$usetag) {
				foreach($arr AS $lu) { $LookupList[$lu] = $tag; }
			}
		}
		ksort($LookupList);

		foreach($LookupList AS $lu=>$tag) {

			$Type = $this->GSUBLookups[$lu]['Type'];
			$Flag = $this->GSUBLookups[$lu]['Flag'];
			$MarkFilteringSet = $this->GSUBLookups[$lu]['MarkFilteringSet'];
			$tagInt = 1;
			if (preg_match('/'.$tag.'([0-9]{1,2})/', $usetags, $m)) {
				$tagInt = $m[1];
			}

			$ptr = 0;
			// Test each glyph sequentially
			while($ptr < (count($this->OTLdata))) {	// whilst there is another glyph ..0064
				$currGlyph = $this->OTLdata[$ptr]['hex'];
				$currGID = $this->OTLdata[$ptr]['uni'];
				$shift = 1;
				foreach($this->GSUBLookups[$lu]['Subtables'] AS $c=>$subtable_offset) {
					// NB Coverage only looks at glyphs for position 1 (esp. 7.3 and 8.3)
					if (isset($this->GSLuCoverage[$lu][$c][$currGID])) {
						if (strpos('rphf pref blwf half pstf cfar init' , $usetag)!==false) { // only apply when mask indicates
							$mask = 0;
							switch ($usetag) {
								case 'rphf': $mask = (1<<(INDIC::RPHF)); break;
								case 'pref': $mask = (1<<(INDIC::PREF)); break;
								case 'blwf': $mask = (1<<(INDIC::BLWF)); break;
								case 'half': $mask = (1<<(INDIC::HALF)); break;
								case 'pstf': $mask = (1<<(INDIC::PSTF)); break;
								case 'cfar': $mask = (1<<(INDIC::CFAR)); break;
								case 'init': $mask = (1<<(INDIC::INIT)); break;
							}
							if (!($this->OTLdata[$ptr]['mask'] & $mask)) { continue; }
						}
						// Get rules from font GSUB subtable
						$shift = $this->_applyGSUBsubtable($lu, $c, $ptr, $currGlyph, $currGID, ($subtable_offset - $this->GSUB_offset), $Type, $Flag, $MarkFilteringSet, $this->GSLuCoverage[$lu][$c], 0, $usetag, $is_old_spec, $tagInt);

						if ($shift) { break; }
					}

					// Special case for Indic  ZZZ99S
					// Check to substitute Halant-Consonant in PREF, BLWF or PSTF
					// i.e. new spec but GSUB tables have Consonant-Halant in Lookups e.g. FreeSerif, which
					// incorrectly just moved old spec tables to new spec. Uniscribe seems to cope with this
					// See also ttffontsuni.php
					// First check if current glyph is a Halant/Virama
					else if (_OTL_OLD_SPEC_COMPAT_1 && $Type==4 && !$is_old_spec && strpos('0094D 009CD 00A4D 00ACD 00B4D 00BCD 00C4D 00CCD 00D4D',$currGlyph)!== false) {
						 // only apply when 'pref blwf pstf' tags, and when mask indicates
						if (strpos('pref blwf pstf' , $usetag)!==false) {
							$mask = 0;
							switch ($usetag) {
								case 'pref': $mask = (1<<(INDIC::PREF)); break;
								case 'blwf': $mask = (1<<(INDIC::BLWF)); break;
								case 'pstf': $mask = (1<<(INDIC::PSTF)); break;
							}
							if (!($this->OTLdata[$ptr]['mask'] & $mask)) { continue; }

							$nextGlyph = $this->OTLdata[$ptr+1]['hex'];
							$nextGID = $this->OTLdata[$ptr+1]['uni'];
							if (isset($this->GSLuCoverage[$lu][$c][$nextGID])) {

								// Get rules from font GSUB subtable
								$shift = $this->_applyGSUBsubtableSpecial($lu, $c, $ptr, $currGlyph, $currGID, $nextGlyph, $nextGID, ($subtable_offset - $this->GSUB_offset), $Type, $this->GSLuCoverage[$lu][$c]);

								if ($shift) { break; }
							}
						}
					}


				}
				if ($shift == 0) { $shift = 1; }
				$ptr += $shift;

			}
		}
	}
}


function _applyGSUBsubtableSpecial($lookupID, $subtable, $ptr, $currGlyph, $currGID, $nextGlyph, $nextGID, $subtable_offset, $Type, $LuCoverage) {

	// Special case for Indic
	// Check to substitute Halant-Consonant in PREF, BLWF or PSTF
	// i.e. new spec but GSUB tables have Consonant-Halant in Lookups e.g. FreeSerif, which
	// incorrectly just moved old spec tables to new spec. Uniscribe seems to cope with this
	// See also ttffontsuni.php

	$this->seek($subtable_offset);
	$SubstFormat= $this->read_ushort();

	// Subtable contains Consonant - Halant
	// Text string contains Halant ($CurrGlyph) - Consonant ($nextGlyph)
	// Halant has already been matched, and already checked that $nextGID is in Coverage table

	////////////////////////////////////////////////////////////////////////////////
	// Only does: LookupType 4: Ligature Substitution Subtable : n to 1
	////////////////////////////////////////////////////////////////////////////////
	$Coverage = $subtable_offset + $this->read_ushort();
	$NextGlyphPos = $LuCoverage[$nextGID];
	$LigSetCount = $this->read_short();

	$this->skip($NextGlyphPos * 2);
	$LigSet = $subtable_offset + $this->read_short();

	$this->seek($LigSet);
	$LigCount = $this->read_short();
	// LigatureSet i.e. all starting with the same Glyph $nextGlyph [Consonant]
	$LigatureOffset = array();
	for ($g=0;$g<$LigCount;$g++) { 
		$LigatureOffset[$g] = $LigSet + $this->read_ushort();
	}
	for ($g=0;$g<$LigCount;$g++) { 
		// Ligature tables
		$this->seek($LigatureOffset[$g]);
		$LigGlyph = $this->read_ushort();
		$substitute = $this->glyphToChar($LigGlyph);
		$CompCount = $this->read_ushort();

		if ($CompCount != 2) { return 0; }	// Only expecting to work with 2:1 (and no ignore characters in between)


		$gid = $this->read_ushort();
		$checkGlyph = $this->glyphToChar($gid); // Other component/input Glyphs starting at position 2 (arrayindex 1)

		if ($currGID == $checkGlyph) { $match = true; }
		else { $match = false; break; }

		$GlyphPos = array();
		$GlyphPos[] = $ptr;
		$GlyphPos[] = $ptr+1;


		if ($match) {
			$shift = $this->GSUBsubstitute($ptr, $substitute, 4, $GlyphPos );	// GlyphPos contains positions to set null
			if ($shift) return 1;
		}

	}
	return 0;
}

function _applyGSUBsubtable($lookupID, $subtable, $ptr, $currGlyph, $currGID, $subtable_offset, $Type, $Flag, $MarkFilteringSet, $LuCoverage, $level=0, $currentTag, $is_old_spec, $tagInt) {
	$ignore = $this->_getGCOMignoreString($Flag, $MarkFilteringSet);

	// Lets start
	$this->seek($subtable_offset);
	$SubstFormat= $this->read_ushort();

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 1: Single Substitution Subtable : 1 to 1
	////////////////////////////////////////////////////////////////////////////////
	if ($Type == 1) {
		// Flag = Ignore
		if ($this->_checkGCOMignore($Flag, $currGlyph, $MarkFilteringSet)) { return 0; }
		$CoverageOffset = $subtable_offset + $this->read_ushort();
		$GlyphPos = $LuCoverage[$currGID];
		//===========
		// Format 1: 
		//===========
		if ($SubstFormat==1) {	// Calculated output glyph indices
			$DeltaGlyphID = $this->read_short();
			$this->seek($CoverageOffset);
			$glyphs = $this->_getCoverageGID();
			$GlyphID = $glyphs[$GlyphPos] + $DeltaGlyphID;
		}
		//===========
		// Format 2: 
		//===========
		else if ($SubstFormat==2) {	// Specified output glyph indices
			$GlyphCount = $this->read_ushort();
			$this->skip($GlyphPos * 2 );
			$GlyphID = $this->read_ushort();
		}

		$substitute = $this->glyphToChar($GlyphID);
		$shift = $this->GSUBsubstitute($ptr, $substitute, $Type );
		if ($this->debugOTL && $shift) { $this->_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level); }
		if ($shift) return 1;
		return 0;
	}

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 2: Multiple Substitution Subtable : 1 to n
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 2) {
		// Flag = Ignore
		if ($this->_checkGCOMignore($Flag, $currGlyph, $MarkFilteringSet)) { return 0; }
		$Coverage = $subtable_offset + $this->read_ushort();
		$GlyphPos = $LuCoverage[$currGID];
		$this->skip(2);
		$this->skip($GlyphPos * 2);
		$Sequences = $subtable_offset + $this->read_short();

		$this->seek($Sequences);
		$GlyphCount = $this->read_short();
		$SubstituteGlyphs = array();
		for ($g=0;$g<$GlyphCount;$g++) { 
			$sgid = $this->read_ushort();
			$SubstituteGlyphs[] = $this->glyphToChar($sgid);
		}

		$shift = $this->GSUBsubstitute($ptr, $SubstituteGlyphs, $Type  );
		if ($this->debugOTL && $shift) { $this->_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level); }
		if ($shift) return $shift;
		return 0;
	}
	////////////////////////////////////////////////////////////////////////////////
	// LookupType 3: Alternate Forms : 1 to 1(n)
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 3) {
 		// Flag = Ignore
		if ($this->_checkGCOMignore($Flag, $currGlyph, $MarkFilteringSet)) { return 0; }
		$Coverage = $subtable_offset + $this->read_ushort();
		$AlternateSetCount = $this->read_short();
		///////////////////////////////////////////////////////////////////////////////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		// Need to set alternate IF set by CSS3 font-feature for a tag
		// i.e. if this is 'salt' alternate may be set to 2
		// default value will be $alt=1 ( === index of 0 in list of alternates)
		$alt = 1;	// $alt=1 points to Alternative[0]
		if ($tagInt>1) { $alt = $tagInt; }
		///////////////////////////////////////////////////////////////////////////////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		if ($alt == 0) { return 0; }	// If specified alternate not present, cancel [ or could default $alt = 1 ?]

		$GlyphPos = $LuCoverage[$currGID];
		$this->skip($GlyphPos * 2);

		$AlternateSets = $subtable_offset + $this->read_short();
		$this->seek($AlternateSets );

		$AlternateGlyphCount = $this->read_short();
		if ($alt > $AlternateGlyphCount) { return 0; }	// If specified alternate not present, cancel [ or could default $alt = 1 ?]

		$this->skip(($alt-1) * 2);
		$GlyphID = $this->read_ushort();

		$substitute = $this->glyphToChar($GlyphID);
		$shift = $this->GSUBsubstitute($ptr, $substitute, $Type );
		if ($this->debugOTL && $shift) { $this->_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level); }
		if ($shift) return 1;
		return 0;
	}
	////////////////////////////////////////////////////////////////////////////////
	// LookupType 4: Ligature Substitution Subtable : n to 1
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 4) {
		// Flag = Ignore
		if ($this->_checkGCOMignore($Flag, $currGlyph, $MarkFilteringSet)) { return 0; }
		$Coverage = $subtable_offset + $this->read_ushort();
		$FirstGlyphPos = $LuCoverage[$currGID];

		$LigSetCount = $this->read_short();

		$this->skip($FirstGlyphPos * 2);
		$LigSet = $subtable_offset + $this->read_short();

		$this->seek($LigSet);
		$LigCount = $this->read_short();
		// LigatureSet i.e. all starting with the same first Glyph $currGlyph
		$LigatureOffset = array();
		for ($g=0;$g<$LigCount;$g++) { 
			$LigatureOffset[$g] = $LigSet + $this->read_ushort();
		}
		for ($g=0;$g<$LigCount;$g++) { 
			// Ligature tables
			$this->seek($LigatureOffset[$g]);
			$LigGlyph = $this->read_ushort();	// Output Ligature GlyphID
			$substitute = $this->glyphToChar($LigGlyph);
			$CompCount = $this->read_ushort();

			$spos = $ptr;
			$match = true; 
			$GlyphPos = array();
			$GlyphPos[] = $spos;
			for ($l=1;$l<$CompCount;$l++) { 
				$gid = $this->read_ushort();
				$checkGlyph = $this->glyphToChar($gid); // Other component/input Glyphs starting at position 2 (arrayindex 1)

				$spos++;
				//while $this->OTLdata[$spos]['uni'] is an "ignore" =>  spos++
				while (isset($this->OTLdata[$spos]) && strpos($ignore, $this->OTLdata[$spos]['hex'])!==false) { $spos++; }

				if (isset($this->OTLdata[$spos]) && $this->OTLdata[$spos]['uni'] == $checkGlyph) {
					$GlyphPos[] = $spos;
				}
				else { $match = false; break; }

			}


			if ($match) {
				$shift = $this->GSUBsubstitute($ptr, $substitute, $Type, $GlyphPos );	// GlyphPos contains positions to set null
				if ($this->debugOTL && $shift) { $this->_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level); }
				if ($shift) return ($spos-$ptr+1-($CompCount-1));
			}

		}
		return 0;
	}

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 5: Contextual Substitution Subtable
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 5) {
		//===========
		// Format 1: Simple Context Glyph Substitution
		//===========
		if ($SubstFormat==1) {
			$CoverageTableOffset = $subtable_offset + $this->read_ushort();
			$SubRuleSetCount = $this->read_ushort();
			$SubRuleSetOffset = array();
			for ($b=0;$b<$SubRuleSetCount;$b++) {
				$offset = $this->read_ushort();
				if ($offset==0x0000) {
					$SubRuleSetOffset[] = $offset;
				}
				else {
					$SubRuleSetOffset[] = $subtable_offset + $offset;
				}
			}

			// SubRuleSet tables: All contexts beginning with the same glyph
			// Select the SubRuleSet required using the position of the glyph in the coverage table
			$GlyphPos = $LuCoverage[$currGID];
			if ($SubRuleSetOffset[$GlyphPos]>0) {
					$this->seek($SubRuleSetOffset[$GlyphPos]);
					$SubRuleCnt = $this->read_ushort();
					$SubRule = array();
					for($b=0;$b<$SubRuleCnt;$b++) {
						$SubRule[$b] = $SubRuleSetOffset[$GlyphPos]+$this->read_ushort();
					}
					for($b=0;$b<$SubRuleCnt;$b++) {		// EACH RULE
						$this->seek($SubRule[$b]);
						$InputGlyphCount = $this->read_ushort();
						$SubstCount = $this->read_ushort();

						$Backtrack = array();
						$Lookahead = array();
						$Input = array();
						$Input[0] = $this->OTLdata[$ptr]['uni'];
						for ($r=1;$r<$InputGlyphCount;$r++) {
							$gid = $this->read_ushort();
							$Input[$r] = $this->glyphToChar($gid);
						}
						$matched = $this->checkContextMatch($Input, $Backtrack, $Lookahead, $ignore, $ptr);
						if ($matched) {
							if ($this->debugOTL) { $this->_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level); }
							for ($p=0;$p<$SubstCount;$p++) {	// EACH LOOKUP
								$SequenceIndex[$p] = $this->read_ushort();
								$LookupListIndex[$p] = $this->read_ushort();
							}

							for ($p=0;$p<$SubstCount;$p++) {
								// Apply  $LookupListIndex  at   $SequenceIndex
								if ($SequenceIndex[$p] >= $InputGlyphCount) { continue; }
								$lu = $LookupListIndex[$p];
								$luType = $this->GSUBLookups[$lu]['Type'];
								$luFlag = $this->GSUBLookups[$lu]['Flag'];
								$luMarkFilteringSet = $this->GSUBLookups[$lu]['MarkFilteringSet'];

								$luptr = $matched[$SequenceIndex[$p]];
								$lucurrGlyph = $this->OTLdata[$luptr]['hex'];
								$lucurrGID = $this->OTLdata[$luptr]['uni'];

								foreach($this->GSUBLookups[$lu]['Subtables'] AS $luc=>$lusubtable_offset) {
									$shift = $this->_applyGSUBsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this->GSUB_offset) , $luType, $luFlag, $luMarkFilteringSet, $this->GSLuCoverage[$lu][$luc], 1, $currentTag, $is_old_spec, $tagInt);
									if ($shift) { break; }
								}
							}

							if (!defined("OMIT_OTL_FIX_3") || OMIT_OTL_FIX_3 != 1) { return $shift ; }	/* OTL_FIX_3 */
							else return $InputGlyphCount ;	// should be + matched ignores in Input Sequence

						}
					}

			}
			return 0;
		}

		//===========
		// Format 2: 
		//===========
		// Format 2: Class-based Context Glyph Substitution
		else if ($SubstFormat==2) {

			$CoverageTableOffset = $subtable_offset + $this->read_ushort();
			$InputClassDefOffset = $subtable_offset + $this->read_ushort();
			$SubClassSetCnt = $this->read_ushort();
			$SubClassSetOffset = array();
			for ($b=0;$b<$SubClassSetCnt;$b++) {
				$offset = $this->read_ushort();
				if ($offset==0x0000) {
					$SubClassSetOffset[] = $offset;
				}
				else {
					$SubClassSetOffset[] = $subtable_offset + $offset;
				}
			}

			$InputClasses = $this->_getClasses($InputClassDefOffset);

			for ($s=0;$s<$SubClassSetCnt;$s++) {	// $SubClassSet is ordered by input class-may be NULL
				// Select $SubClassSet if currGlyph is in First Input Class
				if ($SubClassSetOffset[$s]>0 && isset($InputClasses[$s][$currGID])) {
					$this->seek($SubClassSetOffset[$s]);
					$SubClassRuleCnt = $this->read_ushort();
					$SubClassRule = array();
					for($b=0;$b<$SubClassRuleCnt;$b++) {
						$SubClassRule[$b] = $SubClassSetOffset[$s]+$this->read_ushort();
					}

					for($b=0;$b<$SubClassRuleCnt;$b++) {		// EACH RULE
						$this->seek($SubClassRule[$b]);
						$InputGlyphCount = $this->read_ushort();
						$SubstCount = $this->read_ushort();
						$Input = array();
						for ($r=1;$r<$InputGlyphCount;$r++) {
							$Input[$r] = $this->read_ushort();
						}

						$inputClass = $s;	

						$inputGlyphs = array();
						$inputGlyphs[0] = $InputClasses[$inputClass];

						if ($InputGlyphCount>1) {
							//  NB starts at 1 
							for ($gcl=1;$gcl<$InputGlyphCount;$gcl++) {
								$classindex = $Input[$gcl];
								if (isset($InputClasses[$classindex])) { $inputGlyphs[$gcl] = $InputClasses[$classindex]; }
								else { $inputGlyphs[$gcl] = ''; }
							}
						}

						// Class 0 contains all the glyphs NOT in the other classes
						$class0excl = array();
						for ($gc=1;$gc<=count($InputClasses);$gc++) {
							if (is_array($InputClasses[$gc])) $class0excl = $class0excl + $InputClasses[$gc];
						}

						$backtrackGlyphs = array();
						$lookaheadGlyphs = array();

						$matched = $this->checkContextMatchMultipleUni($inputGlyphs, $backtrackGlyphs, $lookaheadGlyphs, $ignore, $ptr, $class0excl);
						if ($matched) {
							if ($this->debugOTL) { $this->_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level); }
							for ($p=0;$p<$SubstCount;$p++) {	// EACH LOOKUP
								$SequenceIndex[$p] = $this->read_ushort();
								$LookupListIndex[$p] = $this->read_ushort();
							}

							for ($p=0;$p<$SubstCount;$p++) {
								// Apply  $LookupListIndex  at   $SequenceIndex
								if ($SequenceIndex[$p] >= $InputGlyphCount) { continue; }
								$lu = $LookupListIndex[$p];
								$luType = $this->GSUBLookups[$lu]['Type'];
								$luFlag = $this->GSUBLookups[$lu]['Flag'];
								$luMarkFilteringSet = $this->GSUBLookups[$lu]['MarkFilteringSet'];

								$luptr = $matched[$SequenceIndex[$p]];
								$lucurrGlyph = $this->OTLdata[$luptr]['hex'];
								$lucurrGID = $this->OTLdata[$luptr]['uni'];

								foreach($this->GSUBLookups[$lu]['Subtables'] AS $luc=>$lusubtable_offset) {
									$shift = $this->_applyGSUBsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this->GSUB_offset) , $luType, $luFlag, $luMarkFilteringSet, $this->GSLuCoverage[$lu][$luc], 1, $currentTag, $is_old_spec, $tagInt);
									if ($shift) { break; }
								}
							}

							if (!defined("OMIT_OTL_FIX_3") || OMIT_OTL_FIX_3 != 1) { return $shift ; }	/* OTL_FIX_3 */
							else return $InputGlyphCount ;	// should be + matched ignores in Input Sequence

						}

					}

				}
			}

			return 0;
		}

		//===========
		// Format 3: 
		//===========
		// Format 3: Coverage-based Context Glyph Substitution
		else if ($SubstFormat==3) {
			die("GSUB Lookup Type ".$Type." Format ".$SubstFormat." not TESTED YET."); 
			return 0;
		}

	}

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 6: Chaining Contextual Substitution Subtable
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 6) {

		//===========
		// Format 1: 
		//===========
		// Format 1: Simple Chaining Context Glyph Substitution
		if ($SubstFormat==1) {	
			$Coverage = $subtable_offset + $this->read_ushort();
			$GlyphPos = $LuCoverage[$currGID];
			$ChainSubRuleSetCount = $this->read_ushort();
			// All of the ChainSubRule tables defining contexts that begin with the same first glyph are grouped together and defined in a ChainSubRuleSet table
			$this->skip($GlyphPos * 2);
			$ChainSubRuleSet= $subtable_offset + $this->read_ushort();
			$this->seek($ChainSubRuleSet);
			$ChainSubRuleCount = $this->read_ushort();

			for($s=0;$s<$ChainSubRuleCount;$s++) {
				$ChainSubRule[$s] = $ChainSubRuleSet + $this->read_ushort();
			}

			for($s=0;$s<$ChainSubRuleCount;$s++) {
				$this->seek($ChainSubRule[$s]);

				$BacktrackGlyphCount = $this->read_ushort();
				$Backtrack = array();
				for ($b=0;$b<$BacktrackGlyphCount;$b++) {
					$gid = $this->read_ushort();
					$Backtrack[] = $this->glyphToChar($gid);
				}
				$Input = array();
				$Input[0] = $this->OTLdata[$ptr]['uni'];
				$InputGlyphCount = $this->read_ushort();
				for ($b=1;$b<$InputGlyphCount;$b++) {
					$gid = $this->read_ushort();
					$Input[$b] = $this->glyphToChar($gid);
				}
				$LookaheadGlyphCount = $this->read_ushort();
				$Lookahead = array();
				for ($b=0;$b<$LookaheadGlyphCount;$b++) {
					$gid = $this->read_ushort();
					$Lookahead[] = $this->glyphToChar($gid);
				}

				$matched = $this->checkContextMatch($Input, $Backtrack, $Lookahead, $ignore, $ptr);
				if ($matched) {
					if ($this->debugOTL) { $this->_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level); }
					$SubstCount = $this->read_ushort();
					for ($p=0;$p<$SubstCount;$p++) {
						// SubstLookupRecord
						$SubstLookupRecord[$p]['SequenceIndex'] = $this->read_ushort();
						$SubstLookupRecord[$p]['LookupListIndex'] = $this->read_ushort();
					}
					for ($p=0;$p<$SubstCount;$p++) {
						// Apply  $SubstLookupRecord[$p]['LookupListIndex']  at   $SubstLookupRecord[$p]['SequenceIndex']
						if ($SubstLookupRecord[$p]['SequenceIndex'] >= $InputGlyphCount) { continue; }
						$lu = $SubstLookupRecord[$p]['LookupListIndex'];
						$luType = $this->GSUBLookups[$lu]['Type'];
						$luFlag = $this->GSUBLookups[$lu]['Flag'];
						$luMarkFilteringSet = $this->GSUBLookups[$lu]['MarkFilteringSet'];

						$luptr = $matched[$SubstLookupRecord[$p]['SequenceIndex']];
						$lucurrGlyph = $this->OTLdata[$luptr]['hex'];
						$lucurrGID = $this->OTLdata[$luptr]['uni'];

						foreach($this->GSUBLookups[$lu]['Subtables'] AS $luc=>$lusubtable_offset) {
							$shift = $this->_applyGSUBsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this->GSUB_offset), $luType, $luFlag, $luMarkFilteringSet, $this->GSLuCoverage[$lu][$luc], 1, $currentTag, $is_old_spec, $tagInt);
							if ($shift) { break; }
						}
					}
					if (!defined("OMIT_OTL_FIX_3") || OMIT_OTL_FIX_3 != 1) { return $shift ; }	/* OTL_FIX_3 */
					else return $InputGlyphCount ;	// should be + matched ignores in Input Sequence
				}




			}
			return 0;
		}

		//===========
		// Format 2: 
		//===========
		// Format 2: Class-based Chaining Context Glyph Substitution  p257
		else if ($SubstFormat==2) {	

			// NB Format 2 specifies fixed class assignments (identical for each position in the backtrack, input, or lookahead sequence) and exclusive classes (a glyph cannot be in more than one class at a time)

			$CoverageTableOffset = $subtable_offset + $this->read_ushort();
			$BacktrackClassDefOffset = $subtable_offset + $this->read_ushort();
			$InputClassDefOffset = $subtable_offset + $this->read_ushort();
			$LookaheadClassDefOffset = $subtable_offset + $this->read_ushort();
			$ChainSubClassSetCnt = $this->read_ushort();
			$ChainSubClassSetOffset = array();
			for ($b=0;$b<$ChainSubClassSetCnt;$b++) {
				$offset = $this->read_ushort();
				if ($offset==0x0000) {
					$ChainSubClassSetOffset[] = $offset;
				}
				else {
					$ChainSubClassSetOffset[] = $subtable_offset + $offset;
				}
			}

			$BacktrackClasses = $this->_getClasses($BacktrackClassDefOffset);
			$InputClasses = $this->_getClasses($InputClassDefOffset);
			$LookaheadClasses = $this->_getClasses($LookaheadClassDefOffset);

			for ($s=0;$s<$ChainSubClassSetCnt;$s++) {	// $ChainSubClassSet is ordered by input class-may be NULL
				// Select $ChainSubClassSet if currGlyph is in First Input Class
				if ($ChainSubClassSetOffset[$s]>0 && isset($InputClasses[$s][$currGID])) {
					$this->seek($ChainSubClassSetOffset[$s]);
					$ChainSubClassRuleCnt = $this->read_ushort();
					$ChainSubClassRule = array();
					for($b=0;$b<$ChainSubClassRuleCnt;$b++) {
						$ChainSubClassRule[$b] = $ChainSubClassSetOffset[$s]+$this->read_ushort();
					}

					for($b=0;$b<$ChainSubClassRuleCnt;$b++) {		// EACH RULE
						$this->seek($ChainSubClassRule[$b]);
						$BacktrackGlyphCount = $this->read_ushort();
						for ($r=0;$r<$BacktrackGlyphCount;$r++) {
							$Backtrack[$r] = $this->read_ushort();
						}
						$InputGlyphCount = $this->read_ushort();
						for ($r=1;$r<$InputGlyphCount;$r++) {
							$Input[$r] = $this->read_ushort();
						}
						$LookaheadGlyphCount = $this->read_ushort();
						for ($r=0;$r<$LookaheadGlyphCount;$r++) {
							$Lookahead[$r] = $this->read_ushort();
						}


						// These contain classes of glyphs as arrays
						// $InputClasses[(class)] e.g. 0x02E6,0x02E7,0x02E8
						// $LookaheadClasses[(class)]
						// $BacktrackClasses[(class)]

						// These contain arrays of classIndexes
						// [Backtrack] [Lookahead] and [Input] (Input is from the second position only)


						$inputClass = $s;	//???

						$inputGlyphs = array();
						$inputGlyphs[0] = $InputClasses[$inputClass];

						if ($InputGlyphCount>1) {
							//  NB starts at 1 
							for ($gcl=1;$gcl<$InputGlyphCount;$gcl++) {
								$classindex = $Input[$gcl];
								if (isset($InputClasses[$classindex])) { $inputGlyphs[$gcl] = $InputClasses[$classindex]; }
								else { $inputGlyphs[$gcl] = ''; }
							}
						}

						// Class 0 contains all the glyphs NOT in the other classes
						$class0excl = array();
						for ($gc=1;$gc<=count($InputClasses);$gc++) {
							if (isset($InputClasses[$gc])) $class0excl = $class0excl + $InputClasses[$gc];
						}

						if ($BacktrackGlyphCount) {
							for ($gcl=0;$gcl<$BacktrackGlyphCount;$gcl++) {
								$classindex = $Backtrack[$gcl];
								if (isset($BacktrackClasses[$classindex])) { $backtrackGlyphs[$gcl] = $BacktrackClasses[$classindex]; }
								else { $backtrackGlyphs[$gcl] = ''; }
							}
						}
						else { $backtrackGlyphs = array(); }

						// Class 0 contains all the glyphs NOT in the other classes
						$bclass0excl = array();
						for ($gc=1;$gc<=count($BacktrackClasses);$gc++) {
							if (isset($BacktrackClasses[$gc])) $bclass0excl = $bclass0excl + $BacktrackClasses[$gc];
						}


						if ($LookaheadGlyphCount) {
							for ($gcl=0;$gcl<$LookaheadGlyphCount;$gcl++) {
								$classindex = $Lookahead[$gcl];
								if (isset($LookaheadClasses[$classindex])) { $lookaheadGlyphs[$gcl] = $LookaheadClasses[$classindex]; }
								else { $lookaheadGlyphs[$gcl] = ''; }
							}
						}
						else { $lookaheadGlyphs = array(); }

 						// Class 0 contains all the glyphs NOT in the other classes
						$lclass0excl = array();
						for ($gc=1;$gc<=count($LookaheadClasses);$gc++) {
							if (isset($LookaheadClasses[$gc])) $lclass0excl = $lclass0excl + $LookaheadClasses[$gc];
						}


						$matched = $this->checkContextMatchMultipleUni($inputGlyphs, $backtrackGlyphs, $lookaheadGlyphs, $ignore, $ptr, $class0excl, $bclass0excl, $lclass0excl );
						if ($matched) {
							if ($this->debugOTL) { $this->_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level); }
							$SubstCount = $this->read_ushort();
							for ($p=0;$p<$SubstCount;$p++) {	// EACH LOOKUP
								$SequenceIndex[$p] = $this->read_ushort();
								$LookupListIndex[$p] = $this->read_ushort();
							}

							for ($p=0;$p<$SubstCount;$p++) {
								// Apply  $LookupListIndex  at   $SequenceIndex
								if ($SequenceIndex[$p] >= $InputGlyphCount) { continue; }
								$lu = $LookupListIndex[$p];
								$luType = $this->GSUBLookups[$lu]['Type'];
								$luFlag = $this->GSUBLookups[$lu]['Flag'];
								$luMarkFilteringSet = $this->GSUBLookups[$lu]['MarkFilteringSet'];

								$luptr = $matched[$SequenceIndex[$p]];
								$lucurrGlyph = $this->OTLdata[$luptr]['hex'];
								$lucurrGID = $this->OTLdata[$luptr]['uni'];

								foreach($this->GSUBLookups[$lu]['Subtables'] AS $luc=>$lusubtable_offset) {
									$shift = $this->_applyGSUBsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this->GSUB_offset) , $luType, $luFlag, $luMarkFilteringSet, $this->GSLuCoverage[$lu][$luc], 1, $currentTag, $is_old_spec, $tagInt);
									if ($shift) { break; }
								}
							}

							if (!defined("OMIT_OTL_FIX_3") || OMIT_OTL_FIX_3 != 1) { return $shift ; }	/* OTL_FIX_3 */
							else return $InputGlyphCount ;	// should be + matched ignores in Input Sequence

						}

					}

				}
			}

			return 0;
		}
 
		//===========
		// Format 3: 
		//===========
		// Format 3: Coverage-based Chaining Context Glyph Substitution  p259
		else if ($SubstFormat==3) {

			$BacktrackGlyphCount = $this->read_ushort();
			for ($b=0;$b<$BacktrackGlyphCount;$b++) {
				$CoverageBacktrackOffset[] = $subtable_offset + $this->read_ushort();	// in glyph sequence order
			}
			$InputGlyphCount = $this->read_ushort();
			for ($b=0;$b<$InputGlyphCount;$b++) {
				$CoverageInputOffset[] = $subtable_offset + $this->read_ushort();	// in glyph sequence order
			}
			$LookaheadGlyphCount = $this->read_ushort();
			for ($b=0;$b<$LookaheadGlyphCount;$b++) {
				$CoverageLookaheadOffset[] = $subtable_offset + $this->read_ushort();	// in glyph sequence order
			}
			$SubstCount = $this->read_ushort();
			$save_pos = $this->_pos;	// Save the point just after PosCount

			$CoverageBacktrackGlyphs = array();
			for ($b=0;$b<$BacktrackGlyphCount;$b++) {
				$this->seek($CoverageBacktrackOffset[$b]);
				$glyphs = $this->_getCoverage();
				$CoverageBacktrackGlyphs[$b] = implode("|",$glyphs);
			}
			$CoverageInputGlyphs = array();
			for ($b=0;$b<$InputGlyphCount;$b++) {
				$this->seek($CoverageInputOffset[$b]);
				$glyphs = $this->_getCoverage();
				$CoverageInputGlyphs[$b] = implode("|",$glyphs);
			}
			$CoverageLookaheadGlyphs = array();
			for ($b=0;$b<$LookaheadGlyphCount;$b++) {
				$this->seek($CoverageLookaheadOffset[$b]);
				$glyphs = $this->_getCoverage();
				$CoverageLookaheadGlyphs[$b] = implode("|",$glyphs);
			}

			$matched = $this->checkContextMatchMultiple($CoverageInputGlyphs, $CoverageBacktrackGlyphs, $CoverageLookaheadGlyphs , $ignore, $ptr);
			if ($matched) {
				if ($this->debugOTL) { $this->_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level); }

				$this->seek($save_pos);	// Return to just after PosCount
				for ($p=0;$p<$SubstCount;$p++) {
					// SubstLookupRecord
					$SubstLookupRecord[$p]['SequenceIndex'] = $this->read_ushort();
					$SubstLookupRecord[$p]['LookupListIndex'] = $this->read_ushort();
				}
				for ($p=0;$p<$SubstCount;$p++) {
					// Apply  $SubstLookupRecord[$p]['LookupListIndex']  at   $SubstLookupRecord[$p]['SequenceIndex']
					if ($SubstLookupRecord[$p]['SequenceIndex'] >= $InputGlyphCount) { continue; }
					$lu = $SubstLookupRecord[$p]['LookupListIndex'];
					$luType = $this->GSUBLookups[$lu]['Type'];
					$luFlag = $this->GSUBLookups[$lu]['Flag'];
					$luMarkFilteringSet = $this->GSUBLookups[$lu]['MarkFilteringSet'];

					$luptr = $matched[$SubstLookupRecord[$p]['SequenceIndex']];
					$lucurrGlyph = $this->OTLdata[$luptr]['hex'];
					$lucurrGID = $this->OTLdata[$luptr]['uni'];

					foreach($this->GSUBLookups[$lu]['Subtables'] AS $luc=>$lusubtable_offset) {
						$shift = $this->_applyGSUBsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this->GSUB_offset), $luType, $luFlag, $luMarkFilteringSet, $this->GSLuCoverage[$lu][$luc], 1, $currentTag, $is_old_spec, $tagInt);
						if ($shift) { break; }
					}
				}
				if (!defined("OMIT_OTL_FIX_3") || OMIT_OTL_FIX_3 != 1) { return (isset($shift) ? $shift : 0) ; }	/* OTL_FIX_3 */
				else return $InputGlyphCount ;	// should be + matched ignores in Input Sequence
			}

			return 0;

		}
	}

	else { die("GSUB Lookup Type ".$Type." not supported."); }

}

function _updateLigatureMarks($pos, $n) {
	if ($n > 0) {
		// Update position of Ligatures and associated Marks
		// Foreach lig/assocMarks
		// Any position lpos or mpos > $pos + count($substitute)
		//	$this->assocMarks = array(); 	// assocMarks[$pos mpos] => array(compID, ligPos)
		//	$this->assocLigs = array();	// Ligatures[$pos lpos] => nc
		for ($p=count($this->OTLdata)-1;$p>=($pos+$n);$p--) {
			if (isset($this->assocLigs[$p])) {
				$tmp = $this->assocLigs[$p];
				unset($this->assocLigs[$p]); 
				$this->assocLigs[($p + $n)] = $tmp;
			}
		}
		for ($p=count($this->OTLdata)-1;$p>=0;$p--) {
			if (isset($this->assocMarks[$p])) {
				if ($this->assocMarks[$p]['ligPos'] >=($pos+$n)) { $this->assocMarks[$p]['ligPos'] += $n; }
				if ($p>=($pos+$n)) {
					$tmp = $this->assocMarks[$p];
					unset($this->assocMarks[$p]); 
					$this->assocMarks[($p + $n)] = $tmp;
				}
			}
		}
	}

	else if ($n<1) { // glyphs removed
		$nrem = -$n;
		// Update position of pre-existing Ligatures and associated Marks
		for ($p=($pos+1);$p<count($this->OTLdata);$p++) {
			if (isset($this->assocLigs[$p])) {
				$tmp = $this->assocLigs[$p];
				unset($this->assocLigs[$p]); 
				$this->assocLigs[($p - $nrem)] = $tmp;
			}
		}
		for ($p=0;$p<count($this->OTLdata);$p++) {
			if (isset($this->assocMarks[$p])) {
				if ($this->assocMarks[$p]['ligPos'] >=($pos)) { $this->assocMarks[$p]['ligPos'] -= $nrem; }
				if ($p>$pos) {
					$tmp = $this->assocMarks[$p];
					unset($this->assocMarks[$p]); 
					$this->assocMarks[($p - $nrem)] = $tmp;
				}
			}
		}
	}
}

function GSUBsubstitute($pos, $substitute, $Type, $GlyphPos=NULL ) {

	// LookupType 1: Simple Substitution Subtable : 1 to 1
	// LookupType 3: Alternate Forms : 1 to 1(n)
	if ($Type == 1 || $Type == 3) {
		$this->OTLdata[$pos]['uni'] = $substitute;
		$this->OTLdata[$pos]['hex'] = $this->unicode_hex($substitute);
		return 1;
	}
	// LookupType 2: Multiple Substitution Subtable : 1 to n
	else if ($Type == 2) {
		for($i=0;$i<count($substitute);$i++) {
			$uni = $substitute[$i];
			$newOTLdata[$i] = array();
			$newOTLdata[$i]['uni'] = $uni;
			$newOTLdata[$i]['hex'] = $this->unicode_hex($uni);


			// Get types of new inserted chars - or replicate type of char being replaced
		//	$bt = UCDN::get_bidi_class($uni);
		//	if (!$bt) { 
				$bt = $this->OTLdata[$pos]['bidi_type']; 
		//	}

			if (strpos($this->GlyphClassMarks, $newOTLdata[$i]['hex'] )!==false) { $gp = 'M'; }
			else if ($uni == 32) { $gp = 'S'; }
			else { $gp = 'C'; }

			// Need to update matra_type ??? of new glyphs inserted ???????????????????????????????????????

			$newOTLdata[$i]['bidi_type'] = $bt;
			$newOTLdata[$i]['group'] = $gp;

			// Need to update details of new glyphs inserted 
			$newOTLdata[$i]['general_category'] = $this->OTLdata[$pos]['general_category'];

			if ($this->shaper=='I' || $this->shaper=='K' || $this->shaper=='S') {
				$newOTLdata[$i]['indic_category'] = $this->OTLdata[$pos]['indic_category'];
				$newOTLdata[$i]['indic_position'] = $this->OTLdata[$pos]['indic_position'];
			}
			else if ($this->shaper=='M') {
				$newOTLdata[$i]['myanmar_category'] = $this->OTLdata[$pos]['myanmar_category'];
				$newOTLdata[$i]['myanmar_position'] = $this->OTLdata[$pos]['myanmar_position'];
			}
			if (isset($this->OTLdata[$pos]['mask'])) { $newOTLdata[$i]['mask'] = $this->OTLdata[$pos]['mask']; }
			if (isset($this->OTLdata[$pos]['syllable'])) { $newOTLdata[$i]['syllable'] = $this->OTLdata[$pos]['syllable']; }

		}
		if ($this->shaper=='K' || $this->shaper=='T' || $this->shaper=='L') {
			if ($this->OTLdata[$pos]['wordend']) { $newOTLdata[count($substitute)-1]['wordend'] = true; }
		}

		array_splice($this->OTLdata, $pos, 1, $newOTLdata);	// Replace 1 with n
		// Update position of Ligatures and associated Marks
		// count($substitute)-1  is the number of glyphs added
		$nadd = count($substitute)-1;
		$this->_updateLigatureMarks($pos, $nadd);
		return count($substitute);
	}
	// LookupType 4: Ligature Substitution Subtable : n to 1
	else if ($Type == 4) {
		// Create Ligatures and associated Marks
		$firstGlyph = $this->OTLdata[$pos]['hex'];

		// If all components of the ligature are marks (and in the same syllable), we call this a mark ligature.
		$contains_marks = false;
		$contains_nonmarks = false;
		if (isset($this->OTLdata[$pos]['syllable'])) { $current_syllable = $this->OTLdata[$pos]['syllable']; }
		else { $current_syllable = 0; }
		for($i=0;$i<count($GlyphPos);$i++) {
			// If subsequent components are not Marks as well - don't ligate
			$unistr = $this->OTLdata[$GlyphPos[$i]]['hex'];
			if ($this->restrictToSyllable && isset($this->OTLdata[$GlyphPos[$i]]['syllable']) && $this->OTLdata[$GlyphPos[$i]]['syllable'] != $current_syllable) {
				return 0;
			}
			if (strpos($this->GlyphClassMarks, $unistr )!==false) { $contains_marks = true; }
			else  { $contains_nonmarks = true; }
		}
		if ($contains_marks && !$contains_nonmarks) {
			// Mark Ligature (all components are Marks)
			$firstMarkAssoc = '';
			if (isset($this->assocMarks[$pos])) { 
				$firstMarkAssoc = $this->assocMarks[$pos]; 
			}
			// If all components of the ligature are marks, we call this a mark ligature.
			for($i=1;$i<count($GlyphPos);$i++) {

				// If subsequent components are not Marks as well - don't ligate
		//		$unistr = $this->OTLdata[$GlyphPos[$i]]['hex'];
		//		if (strpos($this->GlyphClassMarks, $unistr )===false) { return; }

				$nextMarkAssoc = '';
				if (isset($this->assocMarks[$GlyphPos[$i]])) {
					$nextMarkAssoc = $this->assocMarks[$GlyphPos[$i]];
				}
				// If first component was attached to a previous ligature component,
				// all subsequent components should be attached to the same ligature
				// component, otherwise we shouldn't ligate them.
				// If first component was NOT attached to a previous ligature component,
				// all subsequent components should also NOT be attached to any ligature component,
				if ($firstMarkAssoc != $nextMarkAssoc ) { 
					// unless they are attached to the first component itself!
		//			if (!is_array($nextMarkAssoc) || $nextMarkAssoc['ligPos']!= $pos) { return; }

					// Update/Edit - In test with myanmartext font 
					// &#x1004;&#x103a;&#x1039;&#x1000;&#x1039;&#x1000;&#x103b;&#x103c;&#x103d;&#x1031;&#x102d;
					// => Lookup 17  E003 E066B E05A 102D
					// E003 and 102D should form a mark ligature, but 102D is already associated with (non-mark) ligature E05A
					// So instead of disallowing the mark ligature to form, just dissociate...
					if (!is_array($nextMarkAssoc) || $nextMarkAssoc['ligPos']!= $pos) { unset($this->assocMarks[$GlyphPos[$i]]); }
				}
			}

  /*
   * - If it *is* a mark ligature, we don't allocate a new ligature id, and leave
   *   the ligature to keep its old ligature id.  This will allow it to attach to
   *   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,
   *   and LAM,LAM,HEH form a ligature, they will leave SHADDA and FATHA wit a
   *   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature
   *   later, we don't want them to lose their ligature id/component, otherwise
   *   GPOS will fail to correctly position the mark ligature on top of the
   *   LAM,LAM,HEH ligature. 
   */
			// So if is_array($firstMarkAssoc) - the new (Mark) ligature should keep this association

			$lastPos = $GlyphPos[(count($GlyphPos)-1)];
		}
		else {
/*
   * - Ligatures cannot be formed across glyphs attached to different components
   *   of previous ligatures.  Eg. the sequence is LAM,SHADDA,LAM,FATHA,HEH, and
   *   LAM,LAM,HEH form a ligature, leaving SHADDA,FATHA next to eachother.
   *   However, it would be wrong to ligate that SHADDA,FATHA sequence.
   *   There is an exception to this: If a ligature tries ligating with marks that
   *   belong to it itself, go ahead, assuming that the font designer knows what
   *   they are doing (otherwise it can break Indic stuff when a matra wants to
   *   ligate with a conjunct...)
   */

  /*
   * - If a ligature is formed of components that some of which are also ligatures
   *   themselves, and those ligature components had marks attached to *their*
   *   components, we have to attach the marks to the new ligature component
   *   positions!  Now *that*'s tricky!  And these marks may be following the
   *   last component of the whole sequence, so we should loop forward looking
   *   for them and update them.
   *
   *   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a
   *   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature
   *   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature
   *   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to
   *   the new ligature with a component value of 2.
   *
   *   This in fact happened to a font...  See:
   *   https://bugzilla.gnome.org/show_bug.cgi?id=437633
   */

			$currComp = 0;
			for($i=0;$i<count($GlyphPos);$i++) {
				if ($i>0 && isset($this->assocLigs[$GlyphPos[$i]])) {	// One of the other components is already a ligature
					$nc = $this->assocLigs[$GlyphPos[$i]];
				}
				else { $nc = 1; }
			 	// While next char to right is a mark (but not the next matched glyph)
				// ?? + also include a Mark Ligature here
				$ic = 1;
				while((($i==count($GlyphPos)-1) || (isset($GlyphPos[$i+1]) && ($GlyphPos[$i]+$ic) < $GlyphPos[$i+1])) && isset($this->OTLdata[($GlyphPos[$i]+$ic)]) && strpos($this->GlyphClassMarks, $this->OTLdata[($GlyphPos[$i]+$ic)]['hex'])!== false) {
					$newComp = $currComp;
					if (isset($this->assocMarks[$GlyphPos[$i]+$ic])) {	// One of the inbetween Marks is already associated with a Lig
						// OK as long as it is associated with the current Lig
				//		if ($this->assocMarks[($GlyphPos[$i]+$ic)]['ligPos'] != ($GlyphPos[$i]+$ic)) { die("Problem #1"); }
						$newComp += $this->assocMarks[($GlyphPos[$i]+$ic)]['compID']; 
					}
					$this->assocMarks[($GlyphPos[$i]+$ic)] = array('compID'=>$newComp, 'ligPos'=>$pos); 
					$ic++;
				}
				$currComp += $nc;
			}
			$lastPos = $GlyphPos[(count($GlyphPos)-1)]+$ic-1;
			$this->assocLigs[$pos] = $currComp ;	// Number of components in new Ligature
		}

		// Now remove the unwanted glyphs and associated metadata
		$newOTLdata[0] = array();

		// Get types of new inserted chars - or replicate type of char being replaced
	//	$bt = UCDN::get_bidi_class($substitute);
	//	if (!$bt) { 
			$bt = $this->OTLdata[$pos]['bidi_type']; 
	//	}

		if (strpos($this->GlyphClassMarks, $this->unicode_hex($substitute))!==false) { $gp = 'M'; }
		else if ($substitute == 32) { $gp = 'S'; }
		else { $gp = 'C'; }

		// Need to update details of new glyphs inserted 
		$newOTLdata[0]['general_category'] = $this->OTLdata[$pos]['general_category'];

		$newOTLdata[0]['bidi_type'] = $bt;
		$newOTLdata[0]['group'] = $gp;

		// KASHIDA: If forming a ligature when the last component was identified as a kashida point (final form)
		// If previous/first component of ligature is a medial form, then keep this as a kashida point
		// TEST (Arabic Typesetting) &#x64a;&#x64e;&#x646;&#x62a;&#x64f;&#x645;
		$ka = 0;
		if (isset($this->OTLdata[$GlyphPos[(count($GlyphPos)-1)]]['GPOSinfo']['kashida'])) {
			$ka = $this->OTLdata[$GlyphPos[(count($GlyphPos)-1)]]['GPOSinfo']['kashida']; 
		}
		if ($ka==1 && isset($this->OTLdata[$pos]['form']) && $this->OTLdata[$pos]['form']==3) { $newOTLdata[0]['GPOSinfo']['kashida'] = $ka; }

		$newOTLdata[0]['uni'] = $substitute;
		$newOTLdata[0]['hex'] = $this->unicode_hex($substitute);

		if ($this->shaper=='I' || $this->shaper=='K' || $this->shaper=='S') {
			$newOTLdata[0]['indic_category'] = $this->OTLdata[$pos]['indic_category'];
			$newOTLdata[0]['indic_position'] = $this->OTLdata[$pos]['indic_position'];
		}
		else if ($this->shaper=='M') {
			$newOTLdata[0]['myanmar_category'] = $this->OTLdata[$pos]['myanmar_category'];
			$newOTLdata[0]['myanmar_position'] = $this->OTLdata[$pos]['myanmar_position'];
		}
		if (isset($this->OTLdata[$pos]['mask'])) {$newOTLdata[0]['mask'] = $this->OTLdata[$pos]['mask']; }
		if (isset($this->OTLdata[$pos]['syllable'])) {$newOTLdata[0]['syllable'] = $this->OTLdata[$pos]['syllable']; }

		$newOTLdata[0]['is_ligature'] = true;


		array_splice($this->OTLdata, $pos, 1, $newOTLdata);

		// GlyphPos contains array of arr_pos to set null - not necessarily contiguous

		// +- Remove any assocMarks or assocLigs from the main components (the ones that are deleted)
		for($i=count($GlyphPos)-1;$i>0;$i--) {
			$gpos = $GlyphPos[$i];
			array_splice($this->OTLdata, $gpos, 1);
			unset($this->assocLigs[$gpos]);
			unset($this->assocMarks[$gpos]);
		}
		//	$this->assocLigs = array();	// Ligatures[$posarr lpos] => nc
		//	$this->assocMarks = array(); 	// assocMarks[$posarr mpos] => array(compID, ligPos)

		// Update position of pre-existing Ligatures and associated Marks
		// Start after first GlyphPos
		// count($GlyphPos)-1  is the number of glyphs removed from string
		for($p=($GlyphPos[0]+1);$p<(count($this->OTLdata)+count($GlyphPos)-1) ;$p++ ) {
			$nrem = 0;	// Number of Glyphs removed at this point in the string
			for($i=0;$i<count($GlyphPos);$i++) {
				if ($i>0 && $p > $GlyphPos[$i]) { $nrem++; }
			}
			if (isset($this->assocLigs[$p])) {
				$tmp = $this->assocLigs[$p];
				unset($this->assocLigs[$p]); 
				$this->assocLigs[($p - $nrem)] = $tmp;
			}
			if (isset($this->assocMarks[$p])) {
				$tmp = $this->assocMarks[$p];
				unset($this->assocMarks[$p]); 
				if ($tmp['ligPos'] > $GlyphPos[0]) { $tmp['ligPos'] -= $nrem; }
				$this->assocMarks[($p - $nrem)] = $tmp;
			}
		}
		return 1;
	}
	else { return 0; }
}



////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//////////       ARABIC        /////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

function arabic_initialise() {
		// cf. http://unicode.org/Public/UNIDATA/ArabicShaping.txt
		// http://unicode.org/Public/UNIDATA/extracted/DerivedJoiningType.txt
		// JOIN TO FOLLOWING LETTER IN LOGICAL ORDER (i.e. AS INITIAL/MEDIAL FORM) = Unicode Left-Joining (+ Dual-Joining + Join_Causing 00640)
		$this->arabLeftJoining = array(
		0x0620=>1, 0x0626=>1, 0x0628=>1, 0x062A=>1, 0x062B=>1, 0x062C=>1, 0x062D=>1, 0x062E=>1, 
		0x0633=>1, 0x0634=>1, 0x0635=>1, 0x0636=>1, 0x0637=>1, 0x0638=>1, 0x0639=>1, 0x063A=>1, 
		0x063B=>1, 0x063C=>1, 0x063D=>1, 0x063E=>1, 0x063F=>1, 0x0640=>1, 0x0641=>1, 0x0642=>1, 
		0x0643=>1, 0x0644=>1, 0x0645=>1, 0x0646=>1, 0x0647=>1, 0x0649=>1, 0x064A=>1, 0x066E=>1, 
		0x066F=>1, 0x0678=>1, 0x0679=>1, 0x067A=>1, 0x067B=>1, 0x067C=>1, 0x067D=>1, 0x067E=>1, 
		0x067F=>1, 0x0680=>1, 0x0681=>1, 0x0682=>1, 0x0683=>1, 0x0684=>1, 0x0685=>1, 0x0686=>1, 
		0x0687=>1, 0x069A=>1, 0x069B=>1, 0x069C=>1, 0x069D=>1, 0x069E=>1, 0x069F=>1, 0x06A0=>1, 
		0x06A1=>1, 0x06A2=>1, 0x06A3=>1, 0x06A4=>1, 0x06A5=>1, 0x06A6=>1, 0x06A7=>1, 0x06A8=>1, 
		0x06A9=>1, 0x06AA=>1, 0x06AB=>1, 0x06AC=>1, 0x06AD=>1, 0x06AE=>1, 0x06AF=>1, 0x06B0=>1, 
		0x06B1=>1, 0x06B2=>1, 0x06B3=>1, 0x06B4=>1, 0x06B5=>1, 0x06B6=>1, 0x06B7=>1, 0x06B8=>1, 
		0x06B9=>1, 0x06BA=>1, 0x06BB=>1, 0x06BC=>1, 0x06BD=>1, 0x06BE=>1, 0x06BF=>1, 0x06C1=>1, 
		0x06C2=>1, 0x06CC=>1, 0x06CE=>1, 0x06D0=>1, 0x06D1=>1, 0x06FA=>1, 0x06FB=>1, 0x06FC=>1, 
		0x06FF=>1,
		/* Arabic Supplement */
		0x0750=>1, 0x0751=>1, 0x0752=>1, 0x0753=>1, 0x0754=>1, 0x0755=>1, 0x0756=>1, 0x0757=>1, 
		0x0758=>1, 0x075C=>1, 0x075D=>1, 0x075E=>1, 0x075F=>1, 0x0760=>1, 0x0761=>1, 0x0762=>1, 
		0x0763=>1, 0x0764=>1, 0x0765=>1, 0x0766=>1, 0x0767=>1, 0x0768=>1, 0x0769=>1, 0x076A=>1, 
		0x076D=>1, 0x076E=>1, 0x076F=>1, 0x0770=>1, 0x0772=>1, 0x0775=>1, 0x0776=>1, 0x0777=>1, 
		0x077A=>1, 0x077B=>1, 0x077C=>1, 0x077D=>1, 0x077E=>1, 0x077F=>1,
		/* Extended Arabic */
		0x08A0=>1, 0x08A2=>1, 0x08A3=>1, 0x08A4=>1, 0x08A5=>1, 0x08A6=>1, 0x08A7=>1, 0x08A8=>1, 
		0x08A9=>1,
		/* 'syrc' Syriac */
		0x0712=>1, 0x0713=>1, 0x0714=>1, 0x071A=>1, 0x071B=>1, 0x071C=>1, 0x071D=>1, 0x071F=>1, 
		0x0720=>1, 0x0721=>1, 0x0722=>1, 0x0723=>1, 0x0724=>1, 0x0725=>1, 0x0726=>1, 0x0727=>1, 
		0x0729=>1, 0x072B=>1, 0x072D=>1, 0x072E=>1, 0x074E=>1, 0x074F=>1,
		/* N'Ko */
		0x07CA=>1, 0x07CB=>1, 0x07CC=>1, 0x07CD=>1, 0x07CE=>1, 0x07CF=>1, 0x07D0=>1, 0x07D1=>1, 
		0x07D2=>1, 0x07D3=>1, 0x07D4=>1, 0x07D5=>1, 0x07D6=>1, 0x07D7=>1, 0x07D8=>1, 0x07D9=>1, 
		0x07DA=>1, 0x07DB=>1, 0x07DC=>1, 0x07DD=>1, 0x07DE=>1, 0x07DF=>1, 0x07E0=>1, 0x07E1=>1, 
		0x07E2=>1, 0x07E3=>1, 0x07E4=>1, 0x07E5=>1, 0x07E6=>1, 0x07E7=>1, 0x07E8=>1, 0x07E9=>1, 
		0x07EA=>1, 0x07FA=>1,
		/* Mandaic */
		0x0841=>1, 0x0842=>1, 0x0843=>1, 0x0844=>1, 0x0845=>1, 0x0847=>1, 0x0848=>1, 0x084A=>1, 
		0x084B=>1, 0x084C=>1, 0x084D=>1, 0x084E=>1, 0x0850=>1, 0x0851=>1, 0x0852=>1, 0x0853=>1, 
		0x0855=>1, 
		/* ZWJ U+200D */
		0x0200D=>1);

		/* JOIN TO PREVIOUS LETTER IN LOGICAL ORDER (i.e. AS FINAL/MEDIAL FORM) = Unicode Right-Joining (+ Dual-Joining + Join_Causing) */
		$this->arabRightJoining = array(
		0x0620=>1, 0x0622=>1, 0x0623=>1, 0x0624=>1, 0x0625=>1, 0x0626=>1, 0x0627=>1, 0x0628=>1, 
		0x0629=>1, 0x062A=>1, 0x062B=>1, 0x062C=>1, 0x062D=>1, 0x062E=>1, 0x062F=>1, 0x0630=>1, 
		0x0631=>1, 0x0632=>1, 0x0633=>1, 0x0634=>1, 0x0635=>1, 0x0636=>1, 0x0637=>1, 0x0638=>1, 
		0x0639=>1, 0x063A=>1, 0x063B=>1, 0x063C=>1, 0x063D=>1, 0x063E=>1, 0x063F=>1, 0x0640=>1, 
		0x0641=>1, 0x0642=>1, 0x0643=>1, 0x0644=>1, 0x0645=>1, 0x0646=>1, 0x0647=>1, 0x0648=>1, 
		0x0649=>1, 0x064A=>1, 0x066E=>1, 0x066F=>1, 0x0671=>1, 0x0672=>1, 0x0673=>1, 0x0675=>1, 
		0x0676=>1, 0x0677=>1, 0x0678=>1, 0x0679=>1, 0x067A=>1, 0x067B=>1, 0x067C=>1, 0x067D=>1, 
		0x067E=>1, 0x067F=>1, 0x0680=>1, 0x0681=>1, 0x0682=>1, 0x0683=>1, 0x0684=>1, 0x0685=>1, 
		0x0686=>1, 0x0687=>1, 0x0688=>1, 0x0689=>1, 0x068A=>1, 0x068B=>1, 0x068C=>1, 0x068D=>1, 
		0x068E=>1, 0x068F=>1, 0x0690=>1, 0x0691=>1, 0x0692=>1, 0x0693=>1, 0x0694=>1, 0x0695=>1, 
		0x0696=>1, 0x0697=>1, 0x0698=>1, 0x0699=>1, 0x069A=>1, 0x069B=>1, 0x069C=>1, 0x069D=>1, 
		0x069E=>1, 0x069F=>1, 0x06A0=>1, 0x06A1=>1, 0x06A2=>1, 0x06A3=>1, 0x06A4=>1, 0x06A5=>1, 
		0x06A6=>1, 0x06A7=>1, 0x06A8=>1, 0x06A9=>1, 0x06AA=>1, 0x06AB=>1, 0x06AC=>1, 0x06AD=>1, 
		0x06AE=>1, 0x06AF=>1, 0x06B0=>1, 0x06B1=>1, 0x06B2=>1, 0x06B3=>1, 0x06B4=>1, 0x06B5=>1, 
		0x06B6=>1, 0x06B7=>1, 0x06B8=>1, 0x06B9=>1, 0x06BA=>1, 0x06BB=>1, 0x06BC=>1, 0x06BD=>1, 
		0x06BE=>1, 0x06BF=>1, 0x06C0=>1, 0x06C1=>1, 0x06C2=>1, 0x06C3=>1, 0x06C4=>1, 0x06C5=>1, 
		0x06C6=>1, 0x06C7=>1, 0x06C8=>1, 0x06C9=>1, 0x06CA=>1, 0x06CB=>1, 0x06CC=>1, 0x06CD=>1, 
		0x06CE=>1, 0x06CF=>1, 0x06D0=>1, 0x06D1=>1, 0x06D2=>1, 0x06D3=>1, 0x06D5=>1, 0x06EE=>1, 
		0x06EF=>1, 0x06FA=>1, 0x06FB=>1, 0x06FC=>1, 0x06FF=>1,
		/* Arabic Supplement */
		0x0750=>1, 0x0751=>1, 0x0752=>1, 0x0753=>1, 0x0754=>1, 0x0755=>1, 0x0756=>1, 0x0757=>1, 
		0x0758=>1, 0x0759=>1, 0x075A=>1, 0x075B=>1, 0x075C=>1, 0x075D=>1, 0x075E=>1, 0x075F=>1, 
		0x0760=>1, 0x0761=>1, 0x0762=>1, 0x0763=>1, 0x0764=>1, 0x0765=>1, 0x0766=>1, 0x0767=>1, 
		0x0768=>1, 0x0769=>1, 0x076A=>1, 0x076B=>1, 0x076C=>1, 0x076D=>1, 0x076E=>1, 0x076F=>1, 
		0x0770=>1, 0x0771=>1, 0x0772=>1, 0x0773=>1, 0x0774=>1, 0x0775=>1, 0x0776=>1, 0x0777=>1, 
		0x0778=>1, 0x0779=>1, 0x077A=>1, 0x077B=>1, 0x077C=>1, 0x077D=>1, 0x077E=>1, 0x077F=>1,
		/* Extended Arabic */
		0x08A0=>1, 0x08A2=>1, 0x08A3=>1, 0x08A4=>1, 0x08A5=>1, 0x08A6=>1, 0x08A7=>1, 0x08A8=>1, 
		0x08A9=>1, 0x08AA=>1, 0x08AB=>1, 0x08AC=>1,
		/* 'syrc' Syriac */
		0x0710=>1, 0x0712=>1, 0x0713=>1, 0x0714=>1, 0x0715=>1, 0x0716=>1, 0x0717=>1, 0x0718=>1, 
		0x0719=>1, 0x071A=>1, 0x071B=>1, 0x071C=>1, 0x071D=>1, 0x071E=>1, 0x071F=>1, 0x0720=>1, 
		0x0721=>1, 0x0722=>1, 0x0723=>1, 0x0724=>1, 0x0725=>1, 0x0726=>1, 0x0727=>1, 0x0728=>1, 
		0x0729=>1, 0x072A=>1, 0x072B=>1, 0x072C=>1, 0x072D=>1, 0x072E=>1, 0x072F=>1, 0x074D=>1, 
		0x074E=>1, 0x074F,
		/* N'Ko */
		0x07CA=>1, 0x07CB=>1, 0x07CC=>1, 0x07CD=>1, 0x07CE=>1, 0x07CF=>1, 0x07D0=>1, 0x07D1=>1, 
		0x07D2=>1, 0x07D3=>1, 0x07D4=>1, 0x07D5=>1, 0x07D6=>1, 0x07D7=>1, 0x07D8=>1, 0x07D9=>1, 
		0x07DA=>1, 0x07DB=>1, 0x07DC=>1, 0x07DD=>1, 0x07DE=>1, 0x07DF=>1, 0x07E0=>1, 0x07E1=>1, 
		0x07E2=>1, 0x07E3=>1, 0x07E4=>1, 0x07E5=>1, 0x07E6=>1, 0x07E7=>1, 0x07E8=>1, 0x07E9=>1, 
		0x07EA=>1, 0x07FA=>1,
		/* Mandaic */
		0x0841=>1, 0x0842=>1, 0x0843=>1, 0x0844=>1, 0x0845=>1, 0x0847=>1, 0x0848=>1, 0x084A=>1, 
		0x084B=>1, 0x084C=>1, 0x084D=>1, 0x084E=>1, 0x0850=>1, 0x0851=>1, 0x0852=>1, 0x0853=>1, 
		0x0855=>1, 
		0x0840=>1, 0x0846=>1, 0x0849=>1, 0x084F=>1, 0x0854=>1, /* Right joining */
		/* ZWJ U+200D */
		0x0200D=>1);


		/* VOWELS = TRANSPARENT-JOINING = Unicode Transparent-Joining type (not just vowels) */
		$this->arabTransparent = array(
		0x0610=>1, 0x0611=>1, 0x0612=>1, 0x0613=>1, 0x0614=>1, 0x0615=>1, 0x0616=>1, 0x0617=>1, 
		0x0618=>1, 0x0619=>1, 0x061A=>1, 0x064B=>1, 0x064C=>1, 0x064D=>1, 0x064E=>1, 0x064F=>1, 
		0x0650=>1, 0x0651=>1, 0x0652=>1, 0x0653=>1, 0x0654=>1, 0x0655=>1, 0x0656=>1, 0x0657=>1, 
		0x0658=>1, 0x0659=>1, 0x065A=>1, 0x065B=>1, 0x065C=>1, 0x065D=>1, 0x065E=>1, 0x065F=>1, 
		0x0670=>1, 0x06D6=>1, 0x06D7=>1, 0x06D8=>1, 0x06D9=>1, 0x06DA=>1, 0x06DB=>1, 0x06DC=>1, 
		0x06DF=>1, 0x06E0=>1, 0x06E1=>1, 0x06E2=>1, 0x06E3=>1, 0x06E4=>1, 0x06E7=>1, 0x06E8=>1, 
		0x06EA=>1, 0x06EB=>1, 0x06EC=>1, 0x06ED=>1,
		/* Extended Arabic */
		0x08E4=>1, 0x08E5=>1, 0x08E6=>1, 0x08E7=>1, 0x08E8=>1, 0x08E9=>1, 0x08EA=>1, 0x08EB=>1, 
		0x08EC=>1, 0x08ED=>1, 0x08EE=>1, 0x08EF=>1, 0x08F0=>1, 0x08F1=>1, 0x08F2=>1, 0x08F3=>1, 
		0x08F4=>1, 0x08F5=>1, 0x08F6=>1, 0x08F7=>1, 0x08F8=>1, 0x08F9=>1, 0x08FA=>1, 0x08FB=>1, 
		0x08FC=>1, 0x08FD=>1, 0x08FE=>1,
		/* Arabic ligatures in presentation form (converted in 'ccmp' in e.g. Arial and Times ? need to add others in this range) */
		0xFC5E=>1, 0xFC5F=>1, 0xFC60=>1, 0xFC61=>1, 0xFC62=>1,
		/*  'syrc' Syriac */
		0x070F=>1, 0x0711=>1, 0x0730=>1, 0x0731=>1, 0x0732=>1, 0x0733=>1, 0x0734=>1, 0x0735=>1, 
		0x0736=>1, 0x0737=>1, 0x0738=>1, 0x0739=>1, 0x073A=>1, 0x073B=>1, 0x073C=>1, 0x073D=>1, 
		0x073E=>1, 0x073F=>1, 0x0740=>1, 0x0741=>1, 0x0742=>1, 0x0743=>1, 0x0744=>1, 0x0745=>1, 
		0x0746=>1, 0x0747=>1, 0x0748=>1, 0x0749=>1, 0x074A=>1,
		/* N'Ko */
		0x07EB=>1, 0x07EC=>1, 0x07ED=>1, 0x07EE=>1, 0x07EF=>1, 0x07F0=>1, 0x07F1=>1, 0x07F2=>1, 
		0x07F3=>1,
		/* Mandaic */
		0x0859=>1, 0x085A=>1, 0x085B=>1,
		);

}


function arabic_shaper($usetags, $scriptTag) {
		$chars = array();
		for($i=0;$i<count($this->OTLdata);$i++) {
			$chars[] = $this->OTLdata[$i]['hex'];
		}
		$crntChar = null;
		$prevChar = null;
		$nextChar = null;
		$output = array();
		$max = count($chars);
		for ($i = $max - 1; $i >= 0; $i--) {
			$crntChar = $chars[$i];
			if ($i > 0){ $prevChar = hexdec($chars[$i - 1]); }
			else{ $prevChar = NULL; }
			if ($prevChar && isset($this->arabTransparentJoin[$prevChar]) && isset($chars[$i - 2]) ) {
				$prevChar = hexdec($chars[$i - 2]);
				if ($prevChar && isset($this->arabTransparentJoin[$prevChar]) && isset($chars[$i - 3])) {
					$prevChar = hexdec($chars[$i - 3]);
					if ($prevChar && isset($this->arabTransparentJoin[$prevChar]) && isset($chars[$i - 4])) {
						$prevChar = hexdec($chars[$i - 4]);
					}
				}
			}
			if ($crntChar && isset($this->arabTransparentJoin[ hexdec($crntChar)]) ) {
				// If next_char = RightJoining && prev_char = LeftJoining:
				if (isset($chars[$i + 1]) && $chars[$i + 1] && isset($this->arabRightJoining[ hexdec($chars[$i + 1]) ])  && $prevChar && isset($this->arabLeftJoining[$prevChar])) {
					$output[] = $this->get_arab_glyphs($crntChar, 1, $chars, $i, $scriptTag, $usetags);	// <final> form
				} 
				else {
					$output[] = $this->get_arab_glyphs($crntChar, 0, $chars, $i, $scriptTag, $usetags);  // <isolated> form
				}
				continue;
			}
			if (hexdec($crntChar) < 128) {
				$output[] = array($crntChar,0);
				$nextChar = $crntChar;
				continue;
			}
			// 0=ISOLATED FORM :: 1=FINAL :: 2=INITIAL :: 3=MEDIAL
			$form = 0;
			if ($prevChar && isset($this->arabLeftJoining[$prevChar])) {
				$form++;
			}
			if ($nextChar && isset($this->arabRightJoining[ hexdec($nextChar) ])) {
				$form += 2;
			}
			$output[] = $this->get_arab_glyphs($crntChar, $form, $chars, $i, $scriptTag, $usetags) ;
			$nextChar = $crntChar;
		}
		$ra = array_reverse($output);
		for($i=0;$i<count($this->OTLdata);$i++) {
			$this->OTLdata[$i]['uni'] = hexdec($ra[$i][0]);
			$this->OTLdata[$i]['hex'] = $ra[$i][0];
			$this->OTLdata[$i]['form'] = $ra[$i][1];	// Actaul form substituted 0=ISOLATED FORM :: 1=FINAL :: 2=INITIAL :: 3=MEDIAL
		}
}


function get_arab_glyphs($char, $type, &$chars, $i, $scriptTag, $usetags) {

	// Optional Feature settings	// doesn't control Syriac at present
	if (($type===0 && strpos($usetags, 'isol')===false) || ($type===1 && strpos($usetags, 'fina')===false) || ($type===2 && strpos($usetags, 'init')===false) || ($type===3 && strpos($usetags, 'medi')===false)) {
		return array($char,0);
	}

	// 0=ISOLATED FORM :: 1=FINAL :: 2=INITIAL :: 3=MEDIAL (:: 4=MED2 :: 5=FIN2 :: 6=FIN3)
	$retk = -1;
	// Alaph 00710 in Syriac
	if ($scriptTag=='syrc' && $char=='00710') {
		// if there is a preceding (base?) character *** should search back to previous base - ignoring vowels and change $n
		// set $n as the position of the last base; for now we'll just do this:
		$n = $i-1;
		// if the preceding (base) character cannot be joined to
		// not in $this->arabLeftJoining i.e. not a char which can join to the next one
		if (isset($chars[$n]) && isset($this->arabLeftJoining[hexdec($chars[$n])])) {
			// if in the middle of Syriac words
			if (isset($chars[$i+1]) && preg_match('/[\x{0700}-\x{0745}]/u',code2utf(hexdec($chars[$n]))) && preg_match('/[\x{0700}-\x{0745}]/u',code2utf(hexdec($chars[$i+1]))) && isset($this->arabGlyphs[$char][4])) { $retk = 4; }
			// if at the end of Syriac words
			else if(!isset($chars[$i+1]) || !preg_match('/[\x{0700}-\x{0745}]/u',code2utf(hexdec($chars[$i+1])))) {
				// if preceding base character IS (00715|00716|0072A)
				if (strpos('0715|0716|072A',$chars[$n])!==false && isset($this->arabGlyphs[$char][6])) { $retk = 6; }

				// else if preceding base character is NOT (00715|00716|0072A) 
				else if (isset($this->arabGlyphs[$char][5])) { $retk = 5; }
			}
		}
		if ($retk != -1) { 
			return array($this->arabGlyphs[$char][$retk],$retk);
		}
		else { return array($char,0); }
	}

	if (($type>0 || $type===0) && isset($this->arabGlyphs[$char][$type])) {
		$retk = $type; 
	}
	else if ($type==3 && isset($this->arabGlyphs[$char][1])) {	// if <medial> not defined, but <final>, return <final>
		$retk = 1;
	}
	else if ($type==2 && isset($this->arabGlyphs[$char][0])) {	// if <initial> not defined, but <isolated>, return <isolated>
		$retk = 0;
	}
	if ($retk != -1) {
		$match = true;
		// If GSUB includes a Backtrack or Lookahead condition (e.g. font ArabicTypesetting)
		if (isset($this->arabGlyphs[$char]['prel'][$retk]) && $this->arabGlyphs[$char]['prel'][$retk]) {
			$ig = 1;
			foreach($this->arabGlyphs[$char]['prel'][$retk] AS $k=>$v) {	// $k starts 0, 1...
				if (!isset($chars[$i-$ig-$k])) { $match = false; }
				else if (strpos($v,$chars[$i-$ig-$k])===false) { 
					while (strpos($this->arabGlyphs[$char]['ignore'][$retk],$chars[$i-$ig-$k])!==false) { 	// ignore
						$ig++;
					}
					if (!isset($chars[$i-$ig-$k])) { $match = false; }
					else if (strpos($v,$chars[$i-$ig-$k])===false) { $match = false; }
				}
			}
		}
		if (isset($this->arabGlyphs[$char]['postl'][$retk]) && $this->arabGlyphs[$char]['postl'][$retk]) {
			$ig = 1;
			foreach($this->arabGlyphs[$char]['postl'][$retk] AS $k=>$v) {	// $k starts 0, 1...
				if (!isset($chars[$i+$ig+$k])) { $match = false; }
				else if (strpos($v,$chars[$i+$ig+$k])===false) { 
					while (strpos($this->arabGlyphs[$char]['ignore'][$retk],$chars[$i+$ig+$k])!==false) { 	// ignore
						$ig++;
					}
					if (!isset($chars[$i+$ig+$k])) { $match = false; }
					else if (strpos($v,$chars[$i+$ig+$k])===false) { $match = false; }
				}
			}
		}
		if ($match) {
			return array($this->arabGlyphs[$char][$retk],$retk);
		}
		else { return array($char,0); }
	}
	else { return array($char,0); }
}


////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
/////////////////       LINE BREAKING    ///////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
/////////////       TIBETAN LINE BREAKING    ///////////////////
////////////////////////////////////////////////////////////////
// Sets $this->OTLdata[$i]['wordend']=true at possible end of word boundaries
function TibetanlineBreaking() {
	for ($ptr=0; $ptr<count($this->OTLdata);$ptr++) {
		// Break opportunities at U+0F0B Tsheg or U=0F0D
		if (isset($this->OTLdata[$ptr]['uni']) && ($this->OTLdata[$ptr]['uni']==0x0F0B || $this->OTLdata[$ptr]['uni']==0x0F0D)) {
			if (isset($this->OTLdata[$ptr+1]['uni']) && ($this->OTLdata[$ptr+1]['uni']==0x0F0D || $this->OTLdata[$ptr+1]['uni']==0xF0E)) { continue; }
			// Set end of word marker in OTLdata at matchpos
			$this->OTLdata[$ptr]['wordend'] = true;
		}
	}

}

////////////////////////////////////////////////////////////////
//////////       SOUTH EAST ASIAN LINE BREAKING    /////////////
////////////////////////////////////////////////////////////////
// South East Asian Linebreaking (Thai, Khmer and Lao) using dictionary of words
// Sets $this->OTLdata[$i]['wordend']=true at possible end of word boundaries
function SEAlineBreaking() {
	// Load Line-breaking dictionary
	if (!isset($this->lbdicts[$this->shaper]) && file_exists(_MPDF_PATH.'includes/linebrdict'.$this->shaper.'.dat')) { $this->lbdicts[$this->shaper] = file_get_contents(_MPDF_PATH.'includes/linebrdict'.$this->shaper.'.dat'); }

	$dict =&$this->lbdicts[$this->shaper];

	// Find all word boundaries and mark end of word $this->OTLdata[$i]['wordend']=true on last character
	// If Thai, allow for possible suffixes (not in Lao or Khmer)

	// repeater/ellision characters
	// (0x0E2F);		// Ellision character THAI_PAIYANNOI 0x0E2F  UTF-8 0xE0 0xB8 0xAF 
	// (0x0E46);		// Repeat character THAI_MAIYAMOK 0x0E46   UTF-8 0xE0 0xB9 0x86
	// (0x0EC6);		// Repeat character LAO   UTF-8 0xE0 0xBB 0x86

	$rollover = array();
	$ptr = 0;
	while ($ptr<count($this->OTLdata)-3) {
		if (count($rollover)) {
			$matches = $rollover;
			$rollover = array();
		}
		else {
			$matches = $this->checkwordmatch($dict, $ptr);
		}
		if (count($matches)==1) {
			$matchpos = $matches[0];
			// Check for repeaters - if so $matchpos++
			if (isset($this->OTLdata[$matchpos+1]['uni']) && ($this->OTLdata[$matchpos+1]['uni']==0x0E2F || $this->OTLdata[$matchpos+1]['uni']==0x0E46 || $this->OTLdata[$matchpos+1]['uni']==0x0EC6)) { $matchpos++; }
			// Set end of word marker in OTLdata at matchpos
			$this->OTLdata[$matchpos]['wordend'] = true;
			$ptr = $matchpos + 1;
		}
		else if (empty($matches)) {
			$ptr++;
			// Move past any ASCII characters 
			while (isset($this->OTLdata[$ptr]['uni']) && ($this->OTLdata[$ptr]['uni'] >> 8) == 0) { $ptr++; }
		}
		else {	// Multiple matches
			$secondmatch = false;
			for ($m=count($matches)-1;$m>=0;$m--) {
			//for ($m=0;$m<count($matches);$m++) {
				$firstmatch = $matches[$m];
				$matches2 = $this->checkwordmatch($dict, $firstmatch+1);
				if (count($matches2)) {
					// Set end of word marker in OTLdata at matchpos
					$this->OTLdata[$firstmatch]['wordend'] = true;
					$ptr = $firstmatch + 1;
					$rollover = $matches2;
					$secondmatch = true;
					break;
				}
			}
			if (!$secondmatch) {
				// Set end of word marker in OTLdata at end of longest first match
				$this->OTLdata[$matches[count($matches)-1]]['wordend'] = true;
				$ptr = $matches[count($matches)-1] + 1;
				// Move past any ASCII characters 
				while (isset($this->OTLdata[$ptr]['uni']) && ($this->OTLdata[$ptr]['uni'] >> 8) == 0) { $ptr++; }
			}
		}

	}

}

function checkwordmatch(&$dict, $ptr) {
/*
define("_DICT_NODE_TYPE_SPLIT", 0x01);
define("_DICT_NODE_TYPE_LINEAR", 0x02);
define("_DICT_INTERMEDIATE_MATCH", 0x03);
define("_DICT_FINAL_MATCH", 0x04);

Node type: Split.
Divide at < 98 >= 98
Offset for >= 98 == 79	(long 4-byte unsigned)

Node type: Linear match. 
Char = 97

Intermediate match

Final match
*/

	$dictptr = 0;
	$ok = true;
	$matches = array();
	while ($ok) {
		$x = ord($dict{$dictptr});
		$c = $this->OTLdata[$ptr]['uni'] & 0xFF;
		if ($x==_DICT_INTERMEDIATE_MATCH) {
//echo "DICT_INTERMEDIATE_MATCH: ".dechex($c).'<br />';
			// Do not match if next character in text is a Mark
			if (isset($this->OTLdata[$ptr]['uni']) && strpos($this->GlyphClassMarks, $this->OTLdata[$ptr]['hex'])===false) { 
				$matches[] = $ptr - 1;
			}
			$dictptr++;
		}
		else if ($x==_DICT_FINAL_MATCH) {
//echo "DICT_FINAL_MATCH: ".dechex($c).'<br />';
			// Do not match if next character in text is a Mark
			if (isset($this->OTLdata[$ptr]['uni']) && strpos($this->GlyphClassMarks, $this->OTLdata[$ptr]['hex'])===false) { 
				$matches[] = $ptr - 1;
			}
			return $matches;
		}
		else if ($x==_DICT_NODE_TYPE_LINEAR) {
//echo "DICT_NODE_TYPE_LINEAR: ".dechex($c).'<br />';
			$dictptr++;
			$m = ord($dict{$dictptr});
			if ($c == $m) {
				$ptr++;
				if ($ptr > count($this->OTLdata)-1) {
					$next = ord($dict{$dictptr+1});
					if ($next==_DICT_INTERMEDIATE_MATCH || $next==_DICT_FINAL_MATCH) {
						// Do not match if next character in text is a Mark
						if (isset($this->OTLdata[$ptr]['uni']) && strpos($this->GlyphClassMarks, $this->OTLdata[$ptr]['hex'])===false) { 
							$matches[] = $ptr - 1;
						}
					}
					return $matches;
				}
				$dictptr++;
				continue;
			}
			else {
//echo "DICT_NODE_TYPE_LINEAR NOT: ".dechex($c).'<br />';
				return $matches;
			}
		}
		else if ($x==_DICT_NODE_TYPE_SPLIT) {
//echo "DICT_NODE_TYPE_SPLIT ON ".dechex($d).": ".dechex($c).'<br />';
			$dictptr++;
			$d = ord($dict{$dictptr});
			if ($c < $d) {
				$dictptr += 5;
			}
			else {
				$dictptr++;
				// Unsigned long 32-bit offset
				$offset = (ord($dict{$dictptr})*16777216) + (ord($dict{$dictptr+1})<<16) + (ord($dict{$dictptr+2})<<8) + ord($dict{$dictptr+3});
				$dictptr = $offset;
			}
		}
		else {
//echo "PROBLEM: ".($x).'<br />';
			$ok = false;	// Something has gone wrong
		}
	}

	return $matches;
}



////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//////////       GPOS    ///////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

function _applyGPOSrules($LookupList, $is_old_spec=false) {
	foreach($LookupList AS $lu=>$tag) {
		$Type = $this->GPOSLookups[$lu]['Type'];
		$Flag = $this->GPOSLookups[$lu]['Flag'];
		$MarkFilteringSet = '';
		if (isset($this->GPOSLookups[$lu]['MarkFilteringSet']))
			$MarkFilteringSet = $this->GPOSLookups[$lu]['MarkFilteringSet'];
		$ptr = 0;
		// Test each glyph sequentially
		while($ptr < (count($this->OTLdata))) {	// whilst there is another glyph ..0064
			$currGlyph = $this->OTLdata[$ptr]['hex'];
			$currGID = $this->OTLdata[$ptr]['uni'];
			$shift = 1;
			foreach($this->GPOSLookups[$lu]['Subtables'] AS $c=>$subtable_offset) {
				// NB Coverage only looks at glyphs for position 1 (esp. 7.3 and 8.3)
				if (isset($this->LuCoverage[$lu][$c][$currGID])) {
					// Get rules from font GPOS subtable
					if (isset($this->OTLdata[$ptr]['bidi_type'])) { 	// No need to check bidi_type - just a check that it exists
						$shift = $this->_applyGPOSsubtable($lu, $c, $ptr, $currGlyph, $currGID, ($subtable_offset - $this->GPOS_offset + $this->GSUB_length), $Type, $Flag, $MarkFilteringSet, $this->LuCoverage[$lu][$c], $tag, 0, $is_old_spec);
						if ($shift) { break; }
					}
				}
			}
			if ($shift == 0) { $shift = 1; }
			$ptr += $shift;

		}
	}
}

	//////////////////////////////////////////////////////////////////////////////////
		// GPOS Types
			// Lookup Type 1: Single Adjustment Positioning Subtable		Adjust position of a single glyph
			// Lookup Type 2: Pair Adjustment Positioning Subtable		Adjust position of a pair of glyphs
			// Lookup Type 3: Cursive Attachment Positioning Subtable		Attach cursive glyphs
			// Lookup Type 4: MarkToBase Attachment Positioning Subtable	Attach a combining mark to a base glyph
			// Lookup Type 5: MarkToLigature Attachment Positioning Subtable	Attach a combining mark to a ligature
			// Lookup Type 6: MarkToMark Attachment Positioning Subtable	Attach a combining mark to another mark
			// Lookup Type 7: Contextual Positioning Subtables			Position one or more glyphs in context
			// Lookup Type 8: Chaining Contextual Positioning Subtable		Position one or more glyphs in chained context
			// Lookup Type 9: Extension positioning
	//////////////////////////////////////////////////////////////////////////////////
function _applyGPOSvaluerecord($basepos,$Value) {

	// If current glyph is a mark with a defined width, any XAdvance is considered to REPLACE the character Advance Width
	// Test case <div style="font-family:myanmartext">&#x1004;&#x103a;&#x1039;&#x1000;&#x1039;&#x1000;&#x103b;&#x103c;&#x103d;&#x1031;&#x102d;</div>
	if (strpos($this->GlyphClassMarks, $this->OTLdata[$basepos]['hex'])!==false) { 
		$cw = round($this->mpdf->_getCharWidth($this->mpdf->CurrentFont['cw'], $this->OTLdata[$basepos]['uni']) * $this->mpdf->CurrentFont['unitsPerEm'] / 1000);	// convert back to font design units
	}
	else { 
		$cw = 0; 
	}

	$apos = $this->_getXAdvancePos($basepos);

	if (isset($Value['XAdvance']) && ($Value['XAdvance']-$cw) != 0) {
		// However DON'T REPLACE the character Advance Width if Advance Width is negative
		// Test case <div style="font-family: dejavusansmono">&#x440;&#x443;&#x301;&#x441;&#x441;&#x43a;&#x438;&#x439;</div>
		if ($Value['XAdvance'] < 0) { $cw = 0; }

		// For LTR apply XAdvanceL to the last mark following the base = at $apos
		// For RTL apply XAdvanceR to base = at $basepos
		if (isset($this->OTLdata[$apos]['GPOSinfo']['XAdvanceL'])) { $this->OTLdata[$apos]['GPOSinfo']['XAdvanceL'] += $Value['XAdvance']-$cw; }
		else { $this->OTLdata[$apos]['GPOSinfo']['XAdvanceL'] = $Value['XAdvance']-$cw; }
		if (isset($this->OTLdata[$basepos]['GPOSinfo']['XAdvanceR'])) { $this->OTLdata[$basepos]['GPOSinfo']['XAdvanceR'] += $Value['XAdvance']-$cw; }
		else { $this->OTLdata[$basepos]['GPOSinfo']['XAdvanceR'] = $Value['XAdvance']-$cw; }
	}

	// Any XPlacement (? and Y Placement) apply to base and marks (from basepos to apos)
	for ($a=$basepos;$a<=$apos;$a++) {
		if (isset($Value['XPlacement'])) { 
			if (isset($this->OTLdata[$a]['GPOSinfo']['XPlacement'])) { $this->OTLdata[$a]['GPOSinfo']['XPlacement'] += $Value['XPlacement']; }
			else { $this->OTLdata[$a]['GPOSinfo']['XPlacement'] = $Value['XPlacement']; }
		}
		if (isset($Value['YPlacement'])) { 
			if (isset($this->OTLdata[$a]['GPOSinfo']['YPlacement'])) { $this->OTLdata[$a]['GPOSinfo']['YPlacement'] += $Value['YPlacement']; }
			else { $this->OTLdata[$a]['GPOSinfo']['YPlacement'] = $Value['YPlacement']; }
		}
	}
}



// If XAdvance is aplied to $ptr - in order for PDF to position the Advance correctly need to place it on
// the last of any Marks which immediately follow the current glyph
function _getXAdvancePos($pos) {
	// NB Not all fonts have all marks specified in GlyphClassMarks

	// If the current glyph is not a base (but a mark) then ignore this, and apply to the current position
	if (strpos($this->GlyphClassMarks, $this->OTLdata[$pos]['hex'])!==false) { return $pos; }

	while(isset($this->OTLdata[$pos+1]['hex']) && strpos($this->GlyphClassMarks, $this->OTLdata[$pos+1]['hex'])!==false) { $pos++; }
	return $pos ;
}




function _applyGPOSsubtable($lookupID, $subtable, $ptr, $currGlyph, $currGID, $subtable_offset, $Type, $Flag, $MarkFilteringSet, $LuCoverage, $tag, $level=0, $is_old_spec) {
	if (($Flag  & 0x0001) == 1) { $dir = 'RTL'; }	// only used for Type 3
	else { $dir = 'LTR'; }
	$ignore = $this->_getGCOMignoreString($Flag, $MarkFilteringSet);

	// Lets start
	$this->seek($subtable_offset);
	$PosFormat = $this->read_ushort();

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 1: Single adjustment 	Adjust position of a single glyph (e.g. SmallCaps/Sups/Subs)
	////////////////////////////////////////////////////////////////////////////////
	if ($Type == 1) {
		//===========
		// Format 1: 
		//===========
		if ($PosFormat==1) {
			$Coverage = $subtable_offset + $this->read_ushort();
			$ValueFormat = $this->read_ushort();
			$Value = $this->_getValueRecord($ValueFormat);
		}
		//===========
		// Format 2: 
		//===========
		else if ($PosFormat==2) {	
			$Coverage = $subtable_offset + $this->read_ushort();
			$ValueFormat = $this->read_ushort();
			$ValueCount = $this->read_ushort();
			$GlyphPos = $LuCoverage[$currGID];
			$this->skip($GlyphPos * 2 * $this->count_bits($ValueFormat) );
			$Value = $this->_getValueRecord($ValueFormat);
		}
		$this->_applyGPOSvaluerecord($ptr,$Value);
		if ($this->debugOTL) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
		return 1; 
	}

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 2: Pair adjustment 	Adjust position of a pair of glyphs (Kerning)
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 2) {
		$Coverage = $subtable_offset + $this->read_ushort();
		$ValueFormat1 = $this->read_ushort();
		$ValueFormat2 = $this->read_ushort();
		$sizeOfPair = ( 2*$this->count_bits($ValueFormat1) ) + ( 2*$this->count_bits($ValueFormat2) );
		//===========
		// Format 1: 
		//===========
		if ($PosFormat==1) {	
			$PairSetCount = $this->read_ushort();
			$PairSetOffset = array();
			for($p=0;$p<$PairSetCount;$p++) {
				$PairSetOffset[] = $subtable_offset + $this->read_ushort();
			}
			for($p=0;$p<$PairSetCount;$p++) {
				if (isset($LuCoverage[$currGID]) && $LuCoverage[$currGID]==$p) {
					$this->seek($PairSetOffset[$p]);
					//PairSet table
					$PairValueCount = $this->read_ushort();
					for($pv=0;$pv<$PairValueCount;$pv++) {
						//PairValueRecord
						$gid = $this->read_ushort();
						$SecondGlyph = $this->glyphToChar($gid); 
						$FirstGlyph = $this->OTLdata[$ptr]['uni']; 

						$checkpos = $ptr;
						$checkpos++;
						while (isset($this->OTLdata[$checkpos]) && strpos($ignore, $this->OTLdata[$checkpos]['hex'])!==false) {
							 $checkpos++; 
						}
						if (isset($this->OTLdata[$checkpos]) && $this->OTLdata[$checkpos]['uni']==$SecondGlyph) {
								$matchedpos = $checkpos;
						}
						else { $matchedpos = false; }

						if ($matchedpos !== false) {
							$Value1 = $this->_getValueRecord($ValueFormat1);
							$Value2 = $this->_getValueRecord($ValueFormat2);
							if($ValueFormat1) {
								$this->_applyGPOSvaluerecord($ptr,$Value1);
							}
							if($ValueFormat2) { 
								$this->_applyGPOSvaluerecord($matchedpos,$Value2);
								if ($this->debugOTL) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
								return $matchedpos - $ptr +1; 
							}
							if ($this->debugOTL) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
							return $matchedpos - $ptr;
						}
						else {
							$this->skip($sizeOfPair);
						}
					}
				}
			}
			return 0;
		}
		//===========
		// Format 2: 
		//===========
		else if ($PosFormat==2) {
			$ClassDef1 = $subtable_offset + $this->read_ushort();
			$ClassDef2 = $subtable_offset + $this->read_ushort();
			$Class1Count = $this->read_ushort();
			$Class2Count = $this->read_ushort();

			$sizeOfValueRecords = $Class1Count * $Class2Count * $sizeOfPair;

			//$this->skip($sizeOfValueRecords );  ???? NOT NEEDED

			// NB Class1Count includes Class 0 even though it is not defined by $ClassDef1
			// i.e. Class1Count = 5; Class1 will contain array(indices 1-4);
			$Class1 = $this->_getClassDefinitionTable($ClassDef1);
			$Class2 = $this->_getClassDefinitionTable($ClassDef2);
			$FirstGlyph = $this->OTLdata[$ptr]['uni'];
			$checkpos = $ptr;
			$checkpos++;
			while (isset($this->OTLdata[$checkpos]) && strpos($ignore, $this->OTLdata[$checkpos]['hex'])!==false) {
				$checkpos++; 
			}
			if (isset($this->OTLdata[$checkpos])) { $matchedpos = $checkpos; }
			else { return 0; }

			$SecondGlyph = $this->OTLdata[$matchedpos]['uni'];
			for($i=0;$i<$Class1Count;$i++) {
				if (isset($Class1[$i]) && count($Class1[$i])) {
					$FirstClassPos = array_search($FirstGlyph, $Class1[$i]);
					if ($FirstClassPos === false) { continue; }
					else {
						for($j=0;$j<$Class2Count;$j++) {
							if (isset($Class2[$j]) && count($Class2[$j])) {

									$SecondClassPos = array_search($SecondGlyph, $Class2[$j]);
									if ($SecondClassPos === false) { continue; }

									// Get ValueRecord[$i][$j]
									$offs = ($i*$Class2Count*$sizeOfPair) + ($j*$sizeOfPair);
									$this->seek($subtable_offset + 16 + $offs);

									$Value1 = $this->_getValueRecord($ValueFormat1);
									$Value2 = $this->_getValueRecord($ValueFormat2);
									if($ValueFormat1) {
										$this->_applyGPOSvaluerecord($ptr,$Value1);
									}
									if($ValueFormat2) { 
										$this->_applyGPOSvaluerecord($matchedpos,$Value2);
										if ($this->debugOTL) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
										return $matchedpos - $ptr +1; 
									}
									if ($this->debugOTL) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
									return $matchedpos - $ptr;
							}
						}
					}

				}
			}
			return 0;
		}
	}

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 3: Cursive attachment 	Attach cursive glyphs
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 3) {
		$this->skip(4);
		// Need default XAdvance for glyph
		$pdfWidth = $this->mpdf->_getCharWidth($this->mpdf->CurrentFont['cw'], hexdec($currGlyph));	// DON'T convert back to design units

		$CPos = $LuCoverage[$currGID];
		$this->skip($CPos * 4);
		$EntryAnchor = $this->read_ushort();
		$ExitAnchor = $this->read_ushort();
		if ($EntryAnchor != 0) {
			$EntryAnchor += $subtable_offset;
			list($x,$y) = $this->_getAnchorTable($EntryAnchor);
			if ($dir == 'RTL') {
				if (round($pdfWidth) == round($x * 1000/ $this->mpdf->CurrentFont['unitsPerEm']) ) {
					$x = 0;
				}
				else { $x = $x - ($pdfWidth * $this->mpdf->CurrentFont['unitsPerEm']/1000); }
			}

			$this->Entry[$ptr] = array('X'=>$x, 'Y'=>$y, 'dir'=>$dir);
		}
		if ($ExitAnchor != 0) {
			$ExitAnchor += $subtable_offset;
			list($x,$y) = $this->_getAnchorTable($ExitAnchor);
			if ($dir == 'LTR') {
				if (round($pdfWidth) == round($x * 1000/ $this->mpdf->CurrentFont['unitsPerEm']) ) {
					$x = 0;
				}
				else { $x = $x - ($pdfWidth * $this->mpdf->CurrentFont['unitsPerEm']/1000); }
			}
			$this->Exit[$ptr] = array('X'=>$x, 'Y'=>$y, 'dir'=>$dir);
		}
		if ($this->debugOTL) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
		return 1;
	}

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 4: MarkToBase attachment 	Attach a combining mark to a base glyph
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 4) {
		$MarkCoverage = $subtable_offset + $this->read_ushort();
		//$MarkCoverage is already set in $LuCoverage 00065|00073 etc
		$BaseCoverage = $subtable_offset + $this->read_ushort();
		$ClassCount = $this->read_ushort(); // Number of classes defined for marks = Number of mark glyphs in the MarkCoverage table
		$MarkArray = $subtable_offset + $this->read_ushort();	// Offset to MarkArray table
		$BaseArray = $subtable_offset + $this->read_ushort(); // Offset to BaseArray table

		$this->seek($BaseCoverage);
		$BaseGlyphs = implode('|',$this->_getCoverage());

		$checkpos = $ptr;
		$checkpos--;

		// ZZZ93
		// In Lohit-Kannada font (old-spec), rules specify a Type 4 GPOS to attach below-forms to base glyph
		// the repositioning does not happen in MS Word, and shouldn't happen comparing with other fonts
		// ?Why not
		// This Fix blocks the GPOS rule if the "mark" is not actually classified as a mark in the GlyphClasses of GDEF
		// but only in Indic old-spec.
		// Test cases: &#xca8;&#xccd;&#xca8;&#xcc1; and &#xc95;&#xccd;&#xcb0;&#xccc;
		if ($this->shaper=='I' && $is_old_spec && strpos($this->GlyphClassMarks, $this->OTLdata[$ptr]['hex'])===false) { return; }


		// "To identify the base glyph that combines with a mark, the text-processing client must look backward in the glyph string from the mark to the preceding base glyph."
		while (isset($this->OTLdata[$checkpos]) && strpos($this->GlyphClassMarks, $this->OTLdata[$checkpos]['hex'])!==false) {
			$checkpos--; 
		}

		if (isset($this->OTLdata[$checkpos]) && strpos($BaseGlyphs, $this->OTLdata[$checkpos]['hex'])!==false) {
			$matchedpos = $checkpos;
		}
		else { $matchedpos = false; }

		if ($matchedpos !== false) {

			// Get the relevant MarkRecord
			$MarkPos = $LuCoverage[$currGID];
			$MarkRecord = $this->_getMarkRecord($MarkArray, $MarkPos);	// e.g. Array ( [Class] => 0 [AnchorX] => -549 [AnchorY] => 1548 ) 
			//Mark Class is = $MarkRecord['Class']

			// Get the relevant BaseRecord
			$this->seek($BaseArray);
			$BaseCount = $this->read_ushort();
			$BasePos = strpos($BaseGlyphs, $this->OTLdata[$matchedpos]['hex'])/6;

			// Move to the BaseRecord we want
			$nSkip = (2 * $BasePos * $ClassCount );
			$this->skip($nSkip);

			// Read BaseRecord we want for appropriate Class
			$nSkip = 2*$MarkRecord['Class'];
			$this->skip($nSkip);
			$BaseRecordOffset = $BaseArray + $this->read_ushort();
			list($x,$y) = $this->_getAnchorTable($BaseRecordOffset);
			$BaseRecord = array('AnchorX'=>$x, 'AnchorY'=>$y);	// e.g. Array ( [AnchorX] => 660 [AnchorY] => 1556 ) 

			// Need default XAdvance for Base glyph
			$BaseWidth = $this->mpdf->_getCharWidth($this->mpdf->CurrentFont['cw'], $this->OTLdata[$matchedpos]['uni']) * $this->mpdf->CurrentFont['unitsPerEm'] / 1000;	// convert back to font design units
			$this->OTLdata[$ptr]['GPOSinfo']['BaseWidth'] = $BaseWidth;
			// And any intervening (ignored) characters
			if (($ptr - $matchedpos) > 1) {
				for ($i=$matchedpos+1; $i<$ptr; $i++) {
					$BaseWidthExtra = $this->mpdf->_getCharWidth($this->mpdf->CurrentFont['cw'], $this->OTLdata[$i]['uni']) * $this->mpdf->CurrentFont['unitsPerEm'] / 1000;	// convert back to font design units
					$this->OTLdata[$ptr]['GPOSinfo']['BaseWidth'] += $BaseWidthExtra;

				}
			}

			// Align to previous Glyph by attachment - so need to add to previous placement values
			$prevXPlacement = (isset($this->OTLdata[$matchedpos]['GPOSinfo']['XPlacement']) ? $this->OTLdata[$matchedpos]['GPOSinfo']['XPlacement'] : 0);
			$prevYPlacement = (isset($this->OTLdata[$matchedpos]['GPOSinfo']['YPlacement']) ? $this->OTLdata[$matchedpos]['GPOSinfo']['YPlacement'] : 0);

			$this->OTLdata[$ptr]['GPOSinfo']['XPlacement'] = $prevXPlacement + $BaseRecord['AnchorX'] - $MarkRecord['AnchorX'];
			$this->OTLdata[$ptr]['GPOSinfo']['YPlacement'] = $prevYPlacement + $BaseRecord['AnchorY'] - $MarkRecord['AnchorY'];
			if ($this->debugOTL) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
			return 1;

		}
		return 0;
	}

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 5: MarkToLigature attachment 	Attach a combining mark to a ligature
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 5) {
		$MarkCoverage = $subtable_offset + $this->read_ushort();
		//$MarkCoverage is already set in $LuCoverage 00065|00073 etc
		$LigatureCoverage = $subtable_offset + $this->read_ushort();
		$ClassCount = $this->read_ushort(); // Number of classes defined for marks = Number of mark glyphs in the MarkCoverage table
		$MarkArray = $subtable_offset + $this->read_ushort();	// Offset to MarkArray table
		$LigatureArray = $subtable_offset + $this->read_ushort(); // Offset to LigatureArray table

		$this->seek($LigatureCoverage);
		$LigatureGlyphs = implode('|',$this->_getCoverage());


		$checkpos = $ptr;
		$checkpos--;

		// "To position a combining mark using a MarkToLigature attachment subtable, the text-processing client must work backward from the mark to the preceding ligature glyph."
		while (isset($this->OTLdata[$checkpos]) && strpos($this->GlyphClassMarks, $this->OTLdata[$checkpos]['hex'])!==false) {
			$checkpos--; 
		}

		if (isset($this->OTLdata[$checkpos]) && strpos($LigatureGlyphs, $this->OTLdata[$checkpos]['hex'])!==false) {
			$matchedpos = $checkpos;
		}
		else { $matchedpos = false; }

		if ($matchedpos !== false) {

			// Get the relevant MarkRecord
			$MarkPos = $LuCoverage[$currGID];
			$MarkRecord = $this->_getMarkRecord($MarkArray, $MarkPos);	// e.g. Array ( [Class] => 0 [AnchorX] => -549 [AnchorY] => 1548 ) 
			//Mark Class is = $MarkRecord['Class']


			// Get the relevant LigatureRecord
			$this->seek($LigatureArray);
			$LigatureCount = $this->read_ushort();
			$LigaturePos = strpos($LigatureGlyphs, $this->OTLdata[$matchedpos]['hex'])/6;

			// Move to the LigatureAttach table Record we want
			$nSkip = (2 * $LigaturePos);
			$this->skip($nSkip);
			$LigatureAttachOffset = $LigatureArray + $this->read_ushort();
			$this->seek($LigatureAttachOffset);
			$ComponentCount = $this->read_ushort();
			$offsets = array();
			for ($comp=0;$comp<$ComponentCount;$comp++) {
				// ComponentRecords
				for ($class=0;$class<$ClassCount;$class++) {
					$offsets[$comp][$class] = $this->read_ushort();
				}
			}

			// Get the specific component for this mark attachment
			if (isset($this->assocLigs[$matchedpos]) && isset($this->assocMarks[$ptr]['ligPos']) && $this->assocMarks[$ptr]['ligPos']==$matchedpos) {
				$component = $this->assocMarks[$ptr]['compID'] ;
			}
			else { $component = $ComponentCount-1; }

			$offset = $offsets[$component][$MarkRecord['Class']];
			if ($offset!=0) { 
				$LigatureRecordOffset = $offset + $LigatureAttachOffset; 
					list($x,$y) = $this->_getAnchorTable($LigatureRecordOffset);
					$LigatureRecord = array('AnchorX'=>$x, 'AnchorY'=>$y);

					// Need default XAdvance for Ligature glyph
					$LigatureWidth = $this->mpdf->_getCharWidth($this->mpdf->CurrentFont['cw'], $this->OTLdata[$matchedpos]['uni']) * $this->mpdf->CurrentFont['unitsPerEm'] / 1000;	// convert back to font design units
					$this->OTLdata[$ptr]['GPOSinfo']['BaseWidth'] = $LigatureWidth;
					// And any intervening (ignored)characters
					if (($ptr - $matchedpos) > 1) {
						for ($i=$matchedpos+1; $i<$ptr; $i++) {
							$LigatureWidthExtra = $this->mpdf->_getCharWidth($this->mpdf->CurrentFont['cw'], $this->OTLdata[$i]['uni']) * $this->mpdf->CurrentFont['unitsPerEm'] / 1000;	// convert back to font design units
							$this->OTLdata[$ptr]['GPOSinfo']['BaseWidth'] += $LigatureWidthExtra;

						}
					}

					// Align to previous Ligature by attachment - so need to add to previous placement values
					if (isset($this->OTLdata[$matchedpos]['GPOSinfo']['XPlacement'])) $prevXPlacement = $this->OTLdata[$matchedpos]['GPOSinfo']['XPlacement'];
					else { $prevXPlacement = 0; }
					if (isset($this->OTLdata[$matchedpos]['GPOSinfo']['YPlacement'])) { $prevYPlacement = $this->OTLdata[$matchedpos]['GPOSinfo']['YPlacement']; }
					else { $prevYPlacement = 0; }

					$this->OTLdata[$ptr]['GPOSinfo']['XPlacement'] = $prevXPlacement + $LigatureRecord['AnchorX'] - $MarkRecord['AnchorX'];
					$this->OTLdata[$ptr]['GPOSinfo']['YPlacement'] = $prevYPlacement + $LigatureRecord['AnchorY'] - $MarkRecord['AnchorY'];
					if ($this->debugOTL) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
					return 1;

			}
		}
		return 0;
	}

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 6: MarkToMark attachment 	Attach a combining mark to another mark
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 6) {
		$Mark1Coverage = $subtable_offset + $this->read_ushort();	// Combining Mark
		//$Mark1Coverage is already set in $LuCoverage 0065|0073 etc
		$Mark2Coverage = $subtable_offset + $this->read_ushort();	// Base Mark
		$ClassCount = $this->read_ushort(); // Number of classes defined for marks = No. of Combining mark1 glyphs in the MarkCoverage table
		$Mark1Array = $subtable_offset + $this->read_ushort();	// Offset to MarkArray table
		$Mark2Array = $subtable_offset + $this->read_ushort(); // Offset to Mark2Array table
		$this->seek($Mark2Coverage);
		$Mark2Glyphs = implode('|',$this->_getCoverage());
		$checkpos = $ptr;
		$checkpos--;
		while (isset($this->OTLdata[$checkpos]) && strpos($ignore, $this->OTLdata[$checkpos]['hex'])!==false) {
			$checkpos--; 
		}
		if (isset($this->OTLdata[$checkpos]) && strpos($Mark2Glyphs, $this->OTLdata[$checkpos]['hex'])!==false) {
			$matchedpos = $checkpos;
		}
		else { $matchedpos = false; }

		if ($matchedpos !== false) {

			// Get the relevant MarkRecord
			$Mark1Pos = $LuCoverage[$currGID];
			$Mark1Record = $this->_getMarkRecord($Mark1Array, $Mark1Pos); // e.g. Array ( [Class] => 0 [AnchorX] => -549 [AnchorY] => 1548 ) 
			//Mark Class is = $Mark1Record['Class']

			// Get the relevant Mark2Record
			$this->seek($Mark2Array);
			$Mark2Count = $this->read_ushort();
			$Mark2Pos = strpos($Mark2Glyphs, $this->OTLdata[$matchedpos]['hex'])/6;

			// Move to the Mark2Record we want
			$nSkip = (2 * $Mark2Pos * $ClassCount );
			$this->skip($nSkip);

			// Read Mark2Record we want for appropriate Class
			$nSkip = 2*$Mark1Record['Class'];
			$this->skip($nSkip);
			$Mark2RecordOffset = $Mark2Array + $this->read_ushort();
			list($x,$y) = $this->_getAnchorTable($Mark2RecordOffset);
			$Mark2Record = array('AnchorX'=>$x, 'AnchorY'=>$y);	// e.g. Array ( [AnchorX] => 660 [AnchorY] => 1556 ) 

			// Need default XAdvance for Mark2 glyph
			$Mark2Width = $this->mpdf->_getCharWidth($this->mpdf->CurrentFont['cw'], $this->OTLdata[$matchedpos]['uni']) * $this->mpdf->CurrentFont['unitsPerEm'] / 1000;	// convert back to font design units


			// IF combining marks are set on different components of a ligature glyph, do not apply this rule
			// Test: arabictypesetting: &#x625;&#x650;&#x644;&#x64e;&#x649;&#x670;&#x653;
			// Test: arabictypesetting: &#x628;&#x651;&#x64e;&#x64a;&#x652;&#x646;&#x64e;&#x643;&#x64f;&#x645;&#x652;
			$prevLig = -1;
			$thisLig = -1;
			$prevComp = -1;
			$thisComp = -1;
			if (isset($this->assocMarks[$matchedpos])) { 
				$prevLig = $this->assocMarks[$matchedpos]['ligPos']; 
				$prevComp = $this->assocMarks[$matchedpos]['compID']; 
			}
			if (isset($this->assocMarks[$ptr])) {
				$thisLig = $this->assocMarks[$ptr]['ligPos']; 
				$thisComp = $this->assocMarks[$ptr]['compID']; 
			}

			// However IF Mark2 (first in logical order, i.e. being attached to) is not associated with a base, carry on
			// This happens in Indic when the Mark being attached to e.g. [Halant Ma lig] -> MatraU,  [U+0B4D + U+B2E as E0F5]-> U+0B41 become E135
			if (!defined("OMIT_OTL_FIX_1") || OMIT_OTL_FIX_1 != 1) { 
			/* OTL_FIX_1 */
				if (isset($this->assocMarks[$matchedpos]) && ($prevLig != $thisLig || $prevComp != $thisComp ))  { return 0; }
			}
			else {
			/* Original code */
				if ($prevLig != $thisLig || $prevComp != $thisComp ) { return 0; }
			}


			if (!defined("OMIT_OTL_FIX_2") || OMIT_OTL_FIX_2 != 1) {
			/* OTL_FIX_2 */ 
				if (!isset($this->OTLdata[$matchedpos]['GPOSinfo']['BaseWidth']) || !$this->OTLdata[$matchedpos]['GPOSinfo']['BaseWidth']) { $this->OTLdata[$ptr]['GPOSinfo']['BaseWidth'] = $Mark2Width; }
			}

			// ZZZ99Q - Test Case font-family: garuda &#xe19;&#xe49;&#xe33;
			if (isset($this->OTLdata[$matchedpos]['GPOSinfo']['BaseWidth']) && $this->OTLdata[$matchedpos]['GPOSinfo']['BaseWidth']) { $this->OTLdata[$ptr]['GPOSinfo']['BaseWidth'] = $this->OTLdata[$matchedpos]['GPOSinfo']['BaseWidth']; }

			// Align to previous Mark by attachment - so need to add the previous placement values
			$prevXPlacement = (isset($this->OTLdata[$matchedpos]['GPOSinfo']['XPlacement']) ? $this->OTLdata[$matchedpos]['GPOSinfo']['XPlacement'] : 0);
			$prevYPlacement = (isset($this->OTLdata[$matchedpos]['GPOSinfo']['YPlacement']) ? $this->OTLdata[$matchedpos]['GPOSinfo']['YPlacement'] : 0);
			$this->OTLdata[$ptr]['GPOSinfo']['XPlacement'] = $prevXPlacement + $Mark2Record['AnchorX'] - $Mark1Record['AnchorX'];
			$this->OTLdata[$ptr]['GPOSinfo']['YPlacement'] = $prevYPlacement + $Mark2Record['AnchorY'] - $Mark1Record['AnchorY'];
			if ($this->debugOTL) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
			return 1;

		}
		return 0;
	}

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 7: Context positioning 	Position one or more glyphs in context
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 7) {
		//===========
		// Format 1: 
		//===========
		if ($PosFormat==1) {	
			die("GPOS Lookup Type ".$Type." Format ".$PosFormat." not TESTED YET."); 
			return 0;
		}
		//===========
		// Format 2: 
		//===========
		else if ($PosFormat==2) {	
			$CoverageTableOffset = $subtable_offset + $this->read_ushort();
			$InputClassDefOffset = $subtable_offset + $this->read_ushort();
			$PosClassSetCnt = $this->read_ushort();
			$PosClassSetOffset = array();
			for ($b=0;$b<$PosClassSetCnt;$b++) {
				$offset = $this->read_ushort();
				if ($offset==0x0000) {
					$PosClassSetOffset[] = $offset;
				}
				else {
					$PosClassSetOffset[] = $subtable_offset + $offset;
				}
			}

			$InputClasses = $this->_getClasses($InputClassDefOffset);

			for ($s=0;$s<$PosClassSetCnt;$s++) {	// $ChainPosClassSet is ordered by input class-may be NULL
				// Select $PosClassSet if currGlyph is in First Input Class
				if ($PosClassSetOffset[$s]>0 && isset($InputClasses[$s][$currGID])) {
					$this->seek($PosClassSetOffset[$s]);
					$PosClassRuleCnt = $this->read_ushort();
					$PosClassRule = array();
					for($b=0;$b<$PosClassRuleCnt;$b++) {
						$PosClassRule[$b] = $PosClassSetOffset[$s]+$this->read_ushort();
					}

					for($b=0;$b<$PosClassRuleCnt;$b++) {		// EACH RULE
						$this->seek($PosClassRule[$b]);
						$InputGlyphCount = $this->read_ushort();
						$PosCount = $this->read_ushort();

						$Input = array();
						for ($r=1;$r<$InputGlyphCount;$r++) {
							$Input[$r] = $this->read_ushort();
						}
						$inputClass = $s;

						$inputGlyphs = array();
						$inputGlyphs[0] = $InputClasses[$inputClass];

						if ($InputGlyphCount>1) {
							//  NB starts at 1 
							for ($gcl=1;$gcl<$InputGlyphCount;$gcl++) {
								$classindex = $Input[$gcl];
								if (isset($InputClasses[$classindex])) { $inputGlyphs[$gcl] = $InputClasses[$classindex]; }
								else { $inputGlyphs[$gcl] = ''; }
							}
						}

						// Class 0 contains all the glyphs NOT in the other classes
						$class0excl = array();
						for ($gc=1;$gc<=count($InputClasses);$gc++) {
							if (is_array($InputClasses[$gc])) $class0excl = $class0excl + $InputClasses[$gc];
						}

						$backtrackGlyphs = array();
						$lookaheadGlyphs = array();

						$matched = $this->checkContextMatchMultipleUni($inputGlyphs, $backtrackGlyphs, $lookaheadGlyphs, $ignore, $ptr, $class0excl );
						if ($matched) {
							for ($p=0;$p<$PosCount;$p++) {	// EACH LOOKUP
								$SequenceIndex[$p] = $this->read_ushort();
								$LookupListIndex[$p] = $this->read_ushort();
							}

							for ($p=0;$p<$PosCount;$p++) {
								// Apply  $LookupListIndex  at   $SequenceIndex
								if ($SequenceIndex[$p] >= $InputGlyphCount) { continue; }
								$lu = $LookupListIndex[$p];
								$luType = $this->GPOSLookups[$lu]['Type'];
								$luFlag = $this->GPOSLookups[$lu]['Flag'];
								$luMarkFilteringSet = $this->GPOSLookups[$lu]['MarkFilteringSet'];

								$luptr = $matched[$SequenceIndex[$p]];
								$lucurrGlyph = $this->OTLdata[$luptr]['hex'];
								$lucurrGID = $this->OTLdata[$luptr]['uni'];

								foreach($this->GPOSLookups[$lu]['Subtables'] AS $luc=>$lusubtable_offset) {
									$shift = $this->_applyGPOSsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this->GPOS_offset + $this->GSUB_length), $luType, $luFlag, $luMarkFilteringSet, $this->LuCoverage[$lu][$luc], $tag, 1, $is_old_spec);
									if ($this->debugOTL && $shift) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
									if ($shift) { break; }
								}
							}

							if (!defined("OMIT_OTL_FIX_3") || OMIT_OTL_FIX_3 != 1) { return $shift ; }	/* OTL_FIX_3 */
							else return $InputGlyphCount ;	// should be + matched ignores in Input Sequence

						}
					}

				}
			}

			return 0;
		}
		//===========
		// Format 3: 
		//===========
		else if ($PosFormat==3) {	
			die("GPOS Lookup Type ".$Type." Format ".$PosFormat." not TESTED YET."); 
			return 0;
		}
		else { die("GPOS Lookup Type ".$Type.", Format ".$PosFormat." not supported."); }
	}

	////////////////////////////////////////////////////////////////////////////////
	// LookupType 8: Chained Context positioning 	Position one or more glyphs in chained context
	////////////////////////////////////////////////////////////////////////////////
	else if ($Type == 8) {
		//===========
		// Format 1: 
		//===========
		if ($PosFormat==1) {
			die("GPOS Lookup Type ".$Type." Format ".$PosFormat." not TESTED YET."); 
			return 0;
		}
		//===========
		// Format 2: 
		//===========
		else if ($PosFormat==2) {

			$CoverageTableOffset = $subtable_offset + $this->read_ushort();
			$BacktrackClassDefOffset = $subtable_offset + $this->read_ushort();
			$InputClassDefOffset = $subtable_offset + $this->read_ushort();
			$LookaheadClassDefOffset = $subtable_offset + $this->read_ushort();
			$ChainPosClassSetCnt = $this->read_ushort();
			$ChainPosClassSetOffset = array();
			for ($b=0;$b<$ChainPosClassSetCnt;$b++) {
				$offset = $this->read_ushort();
				if ($offset==0x0000) {
					$ChainPosClassSetOffset[] = $offset;
				}
				else {
					$ChainPosClassSetOffset[] = $subtable_offset + $offset;
				}
			}

			$BacktrackClasses = $this->_getClasses($BacktrackClassDefOffset);
			$InputClasses = $this->_getClasses($InputClassDefOffset);
			$LookaheadClasses = $this->_getClasses($LookaheadClassDefOffset);

			for ($s=0;$s<$ChainPosClassSetCnt;$s++) {	// $ChainPosClassSet is ordered by input class-may be NULL
				// Select $ChainPosClassSet if currGlyph is in First Input Class
				if ($ChainPosClassSetOffset[$s]>0 && isset($InputClasses[$s][$currGID])) {
					$this->seek($ChainPosClassSetOffset[$s]);
					$ChainPosClassRuleCnt = $this->read_ushort();
					$ChainPosClassRule = array();
					for($b=0;$b<$ChainPosClassRuleCnt;$b++) {
						$ChainPosClassRule[$b] = $ChainPosClassSetOffset[$s]+$this->read_ushort();
					}

					for($b=0;$b<$ChainPosClassRuleCnt;$b++) {		// EACH RULE
						$this->seek($ChainPosClassRule[$b]);
						$BacktrackGlyphCount = $this->read_ushort();
						$Backtrack = array();
						for ($r=0;$r<$BacktrackGlyphCount;$r++) {
							$Backtrack[$r] = $this->read_ushort();
						}
						$InputGlyphCount = $this->read_ushort();
						$Input = array();
						for ($r=1;$r<$InputGlyphCount;$r++) {
							$Input[$r] = $this->read_ushort();
						}
						$LookaheadGlyphCount = $this->read_ushort();
						$Lookahead = array();
						for ($r=0;$r<$LookaheadGlyphCount;$r++) {
							$Lookahead[$r] = $this->read_ushort();
						}

						$inputClass = $s;	//???

						$inputGlyphs = array();
						$inputGlyphs[0] = $InputClasses[$inputClass];

						if ($InputGlyphCount>1) {
							//  NB starts at 1 
							for ($gcl=1;$gcl<$InputGlyphCount;$gcl++) {
								$classindex = $Input[$gcl];
								if (isset($InputClasses[$classindex])) { $inputGlyphs[$gcl] = $InputClasses[$classindex]; }
								else { $inputGlyphs[$gcl] = ''; }
							}
						}

						// Class 0 contains all the glyphs NOT in the other classes
						$class0excl = array();
						for ($gc=1;$gc<=count($InputClasses);$gc++) {
							if (isset($InputClasses[$gc]) && is_array($InputClasses[$gc])) $class0excl = $class0excl + $InputClasses[$gc];
						}

						if ($BacktrackGlyphCount) {
							$backtrackGlyphs = array();
							for ($gcl=0;$gcl<$BacktrackGlyphCount;$gcl++) {
								$classindex = $Backtrack[$gcl];
								if (isset($BacktrackClasses[$classindex])) { $backtrackGlyphs[$gcl] = $BacktrackClasses[$classindex]; }
								else { $backtrackGlyphs[$gcl] = ''; }
							}
						}
						else { $backtrackGlyphs = array(); }

						// Class 0 contains all the glyphs NOT in the other classes
						$bclass0excl = array();
						for ($gc=1;$gc<=count($BacktrackClasses);$gc++) {
							if (isset($BacktrackClasses[$gc]) && is_array($BacktrackClasses[$gc])) $bclass0excl = $bclass0excl + $BacktrackClasses[$gc];
						}

						if ($LookaheadGlyphCount) {
							$lookaheadGlyphs = array();
							for ($gcl=0;$gcl<$LookaheadGlyphCount;$gcl++) {
								$classindex = $Lookahead[$gcl];
								if (isset($LookaheadClasses[$classindex])) { $lookaheadGlyphs[$gcl] = $LookaheadClasses[$classindex]; }
								else { $lookaheadGlyphs[$gcl] = ''; }
							}
						}
						else { $lookaheadGlyphs = array(); }

						// Class 0 contains all the glyphs NOT in the other classes
						$lclass0excl = array();
						for ($gc=1;$gc<=count($LookaheadClasses);$gc++) {
							if (isset($LookaheadClasses[$gc]) && is_array($LookaheadClasses[$gc])) $lclass0excl = $lclass0excl + $LookaheadClasses[$gc];
						}

						$matched = $this->checkContextMatchMultipleUni($inputGlyphs, $backtrackGlyphs, $lookaheadGlyphs, $ignore, $ptr, $class0excl, $bclass0excl, $lclass0excl );
						if ($matched) {
							$PosCount = $this->read_ushort();
							$SequenceIndex = array();
							$LookupListIndex = array();
							for ($p=0;$p<$PosCount;$p++) {	// EACH LOOKUP
								$SequenceIndex[$p] = $this->read_ushort();
								$LookupListIndex[$p] = $this->read_ushort();
							}

							for ($p=0;$p<$PosCount;$p++) {
								// Apply  $LookupListIndex  at   $SequenceIndex
								if ($SequenceIndex[$p] >= $InputGlyphCount) { continue; }
								$lu = $LookupListIndex[$p];
								$luType = $this->GPOSLookups[$lu]['Type'];
								$luFlag = $this->GPOSLookups[$lu]['Flag'];
								$luMarkFilteringSet = $this->GPOSLookups[$lu]['MarkFilteringSet'];

								$luptr = $matched[$SequenceIndex[$p]];
								$lucurrGlyph = $this->OTLdata[$luptr]['hex'];
								$lucurrGID = $this->OTLdata[$luptr]['uni'];

								foreach($this->GPOSLookups[$lu]['Subtables'] AS $luc=>$lusubtable_offset) {
									$shift = $this->_applyGPOSsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this->GPOS_offset + $this->GSUB_length), $luType, $luFlag, $luMarkFilteringSet, $this->LuCoverage[$lu][$luc], $tag, 1, $is_old_spec);
									if ($this->debugOTL && $shift) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
									if ($shift) { break; }
								}
							}

							if (!defined("OMIT_OTL_FIX_3") || OMIT_OTL_FIX_3 != 1) { return $shift ; }	/* OTL_FIX_3 */
							else return $InputGlyphCount ;	// should be + matched ignores in Input Sequence

						}
					}

				}
			}

			return 0;
		}
		//===========
		// Format 3: 
		//===========
		else if ($PosFormat==3) {
			$BacktrackGlyphCount = $this->read_ushort();
			for ($b=0;$b<$BacktrackGlyphCount;$b++) {
				$CoverageBacktrackOffset[] = $subtable_offset + $this->read_ushort();	// in glyph sequence order
			}
			$InputGlyphCount = $this->read_ushort();
			for ($b=0;$b<$InputGlyphCount;$b++) {
				$CoverageInputOffset[] = $subtable_offset + $this->read_ushort();	// in glyph sequence order
			}
			$LookaheadGlyphCount = $this->read_ushort();
			for ($b=0;$b<$LookaheadGlyphCount;$b++) {
				$CoverageLookaheadOffset[] = $subtable_offset + $this->read_ushort();	// in glyph sequence order
			}
			$PosCount = $this->read_ushort();
			$save_pos = $this->_pos;	// Save the point just after PosCount

			$CoverageBacktrackGlyphs = array();
			for ($b=0;$b<$BacktrackGlyphCount;$b++) {
				$this->seek($CoverageBacktrackOffset[$b]);
				$glyphs = $this->_getCoverage();
				$CoverageBacktrackGlyphs[$b] = implode("|",$glyphs);
			}
			$CoverageInputGlyphs = array();
			for ($b=0;$b<$InputGlyphCount;$b++) {
				$this->seek($CoverageInputOffset[$b]);
				$glyphs = $this->_getCoverage();
				$CoverageInputGlyphs[$b] = implode("|",$glyphs);
			}
			$CoverageLookaheadGlyphs = array();
			for ($b=0;$b<$LookaheadGlyphCount;$b++) {
				$this->seek($CoverageLookaheadOffset[$b]);
				$glyphs = $this->_getCoverage();
				$CoverageLookaheadGlyphs[$b] = implode("|",$glyphs);
			}
			$matched = $this->checkContextMatchMultiple($CoverageInputGlyphs, $CoverageBacktrackGlyphs, $CoverageLookaheadGlyphs , $ignore, $ptr);
			if ($matched) {

				$this->seek($save_pos);	// Return to just after PosCount
				for ($p=0;$p<$PosCount;$p++) {
					// PosLookupRecord
					$PosLookupRecord[$p]['SequenceIndex'] = $this->read_ushort();
					$PosLookupRecord[$p]['LookupListIndex'] = $this->read_ushort();
				}
				for ($p=0;$p<$PosCount;$p++) {
					// Apply  $PosLookupRecord[$p]['LookupListIndex']  at   $PosLookupRecord[$p]['SequenceIndex']
					if ($PosLookupRecord[$p]['SequenceIndex'] >= $InputGlyphCount) { continue; }
					$lu = $PosLookupRecord[$p]['LookupListIndex'];
					$luType = $this->GPOSLookups[$lu]['Type'];
					$luFlag = $this->GPOSLookups[$lu]['Flag'];
					if (isset($this->GPOSLookups[$lu]['MarkFilteringSet'])) { $luMarkFilteringSet = $this->GPOSLookups[$lu]['MarkFilteringSet']; }
					else { $luMarkFilteringSet = ''; }

					$luptr = $matched[$PosLookupRecord[$p]['SequenceIndex']];
					$lucurrGlyph = $this->OTLdata[$luptr]['hex'];
					$lucurrGID = $this->OTLdata[$luptr]['uni'];

					foreach($this->GPOSLookups[$lu]['Subtables'] AS $luc=>$lusubtable_offset) {
						$shift = $this->_applyGPOSsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this->GPOS_offset + $this->GSUB_length), $luType, $luFlag, $luMarkFilteringSet, $this->LuCoverage[$lu][$luc], $tag, 1, $is_old_spec);
						if ($this->debugOTL && $shift) { $this->_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level); }
						if ($shift) { break; }
					}
				}
			}


		}
		else { die("GPOS Lookup Type ".$Type.", Format ".$PosFormat." not supported."); }
	}

	else { die("GPOS Lookup Type ".$Type." not supported."); }
}

	//////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////
	// GPOS / GSUB / GCOM (common) functions
	//////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////

	function checkContextMatch($Input, $Backtrack, $Lookahead, $ignore, $ptr) {
		// Input etc are single numbers - GSUB Format 6.1
		// Input starts with (1=>xxx)
		// return false if no match, else an array of ptr for matches (0=>0, 1=>3,...)

		$current_syllable = (isset($this->OTLdata[$ptr]['syllable']) ? $this->OTLdata[$ptr]['syllable'] : 0);

		// BACKTRACK
		$checkpos = $ptr;
		for ($i=0;$i<count($Backtrack);$i++) {
			$checkpos--;
			while (isset($this->OTLdata[$checkpos]) && strpos($ignore, $this->OTLdata[$checkpos]['hex'])!==false) { $checkpos--; }
			// If outside scope of current syllable - return no match
			if ($this->restrictToSyllable && isset($this->OTLdata[$checkpos]['syllable']) && $this->OTLdata[$checkpos]['syllable'] != $current_syllable) {
				return false;
			}
			else if (!isset($this->OTLdata[$checkpos]) || $this->OTLdata[$checkpos]['uni'] != $Backtrack[$i]) {
				return false;
			}
		}

		// INPUT
		$matched = array(0=>$ptr);
		$checkpos = $ptr;
		for ($i=1;$i<count($Input);$i++) {
			$checkpos++;
			while (isset($this->OTLdata[$checkpos]) && strpos($ignore, $this->OTLdata[$checkpos]['hex'])!==false) { $checkpos++; }
			// If outside scope of current syllable - return no match
			if ($this->restrictToSyllable && isset($this->OTLdata[$checkpos]['syllable']) && $this->OTLdata[$checkpos]['syllable'] != $current_syllable) {
				return false;
			}
			else if (isset($this->OTLdata[$checkpos]) && $this->OTLdata[$checkpos]['uni'] == $Input[$i]) {
					$matched[] = $checkpos;
			}
			else { return false; }
		}
		
		// LOOKAHEAD
		for ($i=0;$i<count($Lookahead);$i++) {
			$checkpos++;
			while (isset($this->OTLdata[$checkpos]) && strpos($ignore, $this->OTLdata[$checkpos]['hex'])!==false) { $checkpos++; }
			// If outside scope of current syllable - return no match
			if ($this->restrictToSyllable && isset($this->OTLdata[$checkpos]['syllable']) && $this->OTLdata[$checkpos]['syllable'] != $current_syllable) {
				return false;
			}
			else if (!isset($this->OTLdata[$checkpos]) || $this->OTLdata[$checkpos]['uni'] != $Lookahead[$i]) {
				return false;
			}
		}

		return $matched;
	}


	function checkContextMatchMultiple($Input, $Backtrack, $Lookahead, $ignore, $ptr, $class0excl='', $bclass0excl='', $lclass0excl='') {
		// Input etc are string/array of glyph strings  - GSUB Format 5.2, 5.3, 6.2, 6.3, GPOS Format 7.2, 7.3, 8.2, 8.3
		// Input starts with (1=>xxx)
		// return false if no match, else an array of ptr for matches (0=>0, 1=>3,...)
		// $class0excl is the string of glyphs in all classes except Class 0 (GSUB 5.2, 6.2, GPOS 7.2, 8.2)
		// $bclass0excl & $lclass0excl are the same for lookahead and backtrack (GSUB 6.2, GPOS 8.2)

		$current_syllable = (isset($this->OTLdata[$ptr]['syllable']) ? $this->OTLdata[$ptr]['syllable'] : 0);

		// BACKTRACK
		$checkpos = $ptr;
		for ($i=0;$i<count($Backtrack);$i++) {
			$checkpos--;
			while (isset($this->OTLdata[$checkpos]) && strpos($ignore, $this->OTLdata[$checkpos]['hex'])!==false) { $checkpos--; }
			// If outside scope of current syllable - return no match
			if ($this->restrictToSyllable && isset($this->OTLdata[$checkpos]['syllable']) && $this->OTLdata[$checkpos]['syllable'] != $current_syllable) {
				return false;
			}
			// If Class 0 specified, matches anything NOT in $bclass0excl 
			else if (!$Backtrack[$i] && isset($this->OTLdata[$checkpos]) && strpos($bclass0excl,$this->OTLdata[$checkpos]['hex'])!==false) {
				return false;
			}
			else if (!isset($this->OTLdata[$checkpos]) || strpos($Backtrack[$i], $this->OTLdata[$checkpos]['hex'])===false) {
				return false;
			}
		}

		// INPUT
		$matched = array(0=>$ptr);
		$checkpos = $ptr;
		for ($i=1;$i<count($Input);$i++) {	// Start at 1 - already matched the first InputGlyph
			$checkpos++;
			while (isset($this->OTLdata[$checkpos]) && strpos($ignore, $this->OTLdata[$checkpos]['hex'])!==false) { $checkpos++; }
			// If outside scope of current syllable - return no match
			if ($this->restrictToSyllable && isset($this->OTLdata[$checkpos]['syllable']) && $this->OTLdata[$checkpos]['syllable'] != $current_syllable) {
				return false;
			}
			// If Input Class 0 specified, matches anything NOT in $class0excl 
			else if (!$Input[$i] && isset($this->OTLdata[$checkpos]) && strpos($class0excl,$this->OTLdata[$checkpos]['hex'])===false) {
					$matched[] = $checkpos;
			}
			else if (isset($this->OTLdata[$checkpos]) && strpos($Input[$i],$this->OTLdata[$checkpos]['hex'])!==false) {
					$matched[] = $checkpos;
			}
			else { return false; }
		}
		
		// LOOKAHEAD
		for ($i=0;$i<count($Lookahead);$i++) {
			$checkpos++;
			while (isset($this->OTLdata[$checkpos]) && strpos($ignore, $this->OTLdata[$checkpos]['hex'])!==false) { $checkpos++; }
			// If outside scope of current syllable - return no match
			if ($this->restrictToSyllable && isset($this->OTLdata[$checkpos]['syllable']) && $this->OTLdata[$checkpos]['syllable'] != $current_syllable) {
				return false;
			}
			// If Class 0 specified, matches anything NOT in $lclass0excl 
			else if (!$Lookahead[$i] && isset($this->OTLdata[$checkpos]) && strpos($lclass0excl,$this->OTLdata[$checkpos]['hex'])!==false) {
				return false;
			}
			else if (!isset($this->OTLdata[$checkpos]) || strpos($Lookahead[$i],$this->OTLdata[$checkpos]['hex'])===false) {
				return false;
			}
		}
		return $matched;
	}

	function checkContextMatchMultipleUni($Input, $Backtrack, $Lookahead, $ignore, $ptr, $class0excl=array(), $bclass0excl=array(), $lclass0excl=array()) {
		// Input etc are array of glyphs - GSUB Format 5.2, 5.3, 6.2, 6.3, GPOS Format 7.2, 7.3, 8.2, 8.3
		// Input starts with (1=>xxx)
		// return false if no match, else an array of ptr for matches (0=>0, 1=>3,...)
		// $class0excl 